// @generated by protoc-gen-connect-es v1.1.3 with parameter "target=js+dts+ts"
// @generated from file flyteidl/datacatalog/datacatalog.proto (package datacatalog, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { AddTagRequest, AddTagResponse, CreateArtifactRequest, CreateArtifactResponse, CreateDatasetRequest, CreateDatasetResponse, GetArtifactRequest, GetArtifactResponse, GetDatasetRequest, GetDatasetResponse, GetOrExtendReservationRequest, GetOrExtendReservationResponse, ListArtifactsRequest, ListArtifactsResponse, ListDatasetsRequest, ListDatasetsResponse, ReleaseReservationRequest, ReleaseReservationResponse, UpdateArtifactRequest, UpdateArtifactResponse } from "./datacatalog_pb.js";
import { MethodKind } from "@bufbuild/protobuf";

/**
 *
 * Data Catalog service definition
 * Data Catalog is a service for indexing parameterized, strongly-typed data artifacts across revisions.
 * Artifacts are associated with a Dataset, and can be tagged for retrieval.
 *
 * @generated from service datacatalog.DataCatalog
 */
export declare const DataCatalog: {
  readonly typeName: "datacatalog.DataCatalog",
  readonly methods: {
    /**
     * Create a new Dataset. Datasets are unique based on the DatasetID. Datasets are logical groupings of artifacts.
     * Each dataset can have one or more artifacts
     *
     * @generated from rpc datacatalog.DataCatalog.CreateDataset
     */
    readonly createDataset: {
      readonly name: "CreateDataset",
      readonly I: typeof CreateDatasetRequest,
      readonly O: typeof CreateDatasetResponse,
      readonly kind: MethodKind.Unary,
    },
    /**
     * Get a Dataset by the DatasetID. This returns the Dataset with the associated metadata.
     *
     * @generated from rpc datacatalog.DataCatalog.GetDataset
     */
    readonly getDataset: {
      readonly name: "GetDataset",
      readonly I: typeof GetDatasetRequest,
      readonly O: typeof GetDatasetResponse,
      readonly kind: MethodKind.Unary,
    },
    /**
     * Create an artifact and the artifact data associated with it. An artifact can be a hive partition or arbitrary
     * files or data values
     *
     * @generated from rpc datacatalog.DataCatalog.CreateArtifact
     */
    readonly createArtifact: {
      readonly name: "CreateArtifact",
      readonly I: typeof CreateArtifactRequest,
      readonly O: typeof CreateArtifactResponse,
      readonly kind: MethodKind.Unary,
    },
    /**
     * Retrieve an artifact by an identifying handle. This returns an artifact along with the artifact data.
     *
     * @generated from rpc datacatalog.DataCatalog.GetArtifact
     */
    readonly getArtifact: {
      readonly name: "GetArtifact",
      readonly I: typeof GetArtifactRequest,
      readonly O: typeof GetArtifactResponse,
      readonly kind: MethodKind.Unary,
    },
    /**
     * Associate a tag with an artifact. Tags are unique within a Dataset.
     *
     * @generated from rpc datacatalog.DataCatalog.AddTag
     */
    readonly addTag: {
      readonly name: "AddTag",
      readonly I: typeof AddTagRequest,
      readonly O: typeof AddTagResponse,
      readonly kind: MethodKind.Unary,
    },
    /**
     * Return a paginated list of artifacts
     *
     * @generated from rpc datacatalog.DataCatalog.ListArtifacts
     */
    readonly listArtifacts: {
      readonly name: "ListArtifacts",
      readonly I: typeof ListArtifactsRequest,
      readonly O: typeof ListArtifactsResponse,
      readonly kind: MethodKind.Unary,
    },
    /**
     * Return a paginated list of datasets
     *
     * @generated from rpc datacatalog.DataCatalog.ListDatasets
     */
    readonly listDatasets: {
      readonly name: "ListDatasets",
      readonly I: typeof ListDatasetsRequest,
      readonly O: typeof ListDatasetsResponse,
      readonly kind: MethodKind.Unary,
    },
    /**
     * Updates an existing artifact, overwriting the stored artifact data in the underlying blob storage.
     *
     * @generated from rpc datacatalog.DataCatalog.UpdateArtifact
     */
    readonly updateArtifact: {
      readonly name: "UpdateArtifact",
      readonly I: typeof UpdateArtifactRequest,
      readonly O: typeof UpdateArtifactResponse,
      readonly kind: MethodKind.Unary,
    },
    /**
     * Attempts to get or extend a reservation for the corresponding artifact. If one already exists
     * (ie. another entity owns the reservation) then that reservation is retrieved.
     * Once you acquire a reservation, you need to  periodically extend the reservation with an
     * identical call. If the reservation is not extended before the defined expiration, it may be
     * acquired by another task.
     * Note: We may have multiple concurrent tasks with the same signature and the same input that
     * try to populate the same artifact at the same time. Thus with reservation, only one task can
     * run at a time, until the reservation expires.
     * Note: If task A does not extend the reservation in time and the reservation expires, another
     * task B may take over the reservation, resulting in two tasks A and B running in parallel. So
     * a third task C may get the Artifact from A or B, whichever writes last.
     *
     * @generated from rpc datacatalog.DataCatalog.GetOrExtendReservation
     */
    readonly getOrExtendReservation: {
      readonly name: "GetOrExtendReservation",
      readonly I: typeof GetOrExtendReservationRequest,
      readonly O: typeof GetOrExtendReservationResponse,
      readonly kind: MethodKind.Unary,
    },
    /**
     * Release the reservation when the task holding the spot fails so that the other tasks
     * can grab the spot.
     *
     * @generated from rpc datacatalog.DataCatalog.ReleaseReservation
     */
    readonly releaseReservation: {
      readonly name: "ReleaseReservation",
      readonly I: typeof ReleaseReservationRequest,
      readonly O: typeof ReleaseReservationResponse,
      readonly kind: MethodKind.Unary,
    },
  }
};

