// @generated by protoc-gen-es v1.4.2 with parameter "target=js+dts+ts,keep_empty_files=false"
// @generated from file flyteidl/core/condition.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Primitive, Scalar } from "./literals_pb.js";

/**
 * Defines a 2-level tree where the root is a comparison operator and Operands are primitives or known variables.
 * Each expression results in a boolean result.
 *
 * @generated from message flyteidl.core.ComparisonExpression
 */
export declare class ComparisonExpression extends Message<ComparisonExpression> {
  /**
   * @generated from field: flyteidl.core.ComparisonExpression.Operator operator = 1;
   */
  operator: ComparisonExpression_Operator;

  /**
   * @generated from field: flyteidl.core.Operand left_value = 2;
   */
  leftValue?: Operand;

  /**
   * @generated from field: flyteidl.core.Operand right_value = 3;
   */
  rightValue?: Operand;

  constructor(data?: PartialMessage<ComparisonExpression>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.ComparisonExpression";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComparisonExpression;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComparisonExpression;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComparisonExpression;

  static equals(a: ComparisonExpression | PlainMessage<ComparisonExpression> | undefined, b: ComparisonExpression | PlainMessage<ComparisonExpression> | undefined): boolean;
}

/**
 * Binary Operator for each expression
 *
 * @generated from enum flyteidl.core.ComparisonExpression.Operator
 */
export declare enum ComparisonExpression_Operator {
  /**
   * @generated from enum value: EQ = 0;
   */
  EQ = 0,

  /**
   * @generated from enum value: NEQ = 1;
   */
  NEQ = 1,

  /**
   * Greater Than
   *
   * @generated from enum value: GT = 2;
   */
  GT = 2,

  /**
   * @generated from enum value: GTE = 3;
   */
  GTE = 3,

  /**
   * Less Than
   *
   * @generated from enum value: LT = 4;
   */
  LT = 4,

  /**
   * @generated from enum value: LTE = 5;
   */
  LTE = 5,
}

/**
 * Defines an operand to a comparison expression.
 *
 * @generated from message flyteidl.core.Operand
 */
export declare class Operand extends Message<Operand> {
  /**
   * @generated from oneof flyteidl.core.Operand.val
   */
  val: {
    /**
     * Can be a constant
     *
     * @generated from field: flyteidl.core.Primitive primitive = 1 [deprecated = true];
     * @deprecated
     */
    value: Primitive;
    case: "primitive";
  } | {
    /**
     * Or one of this node's input variables
     *
     * @generated from field: string var = 2;
     */
    value: string;
    case: "var";
  } | {
    /**
     * Replace the primitive field
     *
     * @generated from field: flyteidl.core.Scalar scalar = 3;
     */
    value: Scalar;
    case: "scalar";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Operand>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Operand";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operand;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operand;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operand;

  static equals(a: Operand | PlainMessage<Operand> | undefined, b: Operand | PlainMessage<Operand> | undefined): boolean;
}

/**
 * Defines a boolean expression tree. It can be a simple or a conjunction expression.
 * Multiple expressions can be combined using a conjunction or a disjunction to result in a final boolean result.
 *
 * @generated from message flyteidl.core.BooleanExpression
 */
export declare class BooleanExpression extends Message<BooleanExpression> {
  /**
   * @generated from oneof flyteidl.core.BooleanExpression.expr
   */
  expr: {
    /**
     * @generated from field: flyteidl.core.ConjunctionExpression conjunction = 1;
     */
    value: ConjunctionExpression;
    case: "conjunction";
  } | {
    /**
     * @generated from field: flyteidl.core.ComparisonExpression comparison = 2;
     */
    value: ComparisonExpression;
    case: "comparison";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<BooleanExpression>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.BooleanExpression";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BooleanExpression;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BooleanExpression;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BooleanExpression;

  static equals(a: BooleanExpression | PlainMessage<BooleanExpression> | undefined, b: BooleanExpression | PlainMessage<BooleanExpression> | undefined): boolean;
}

/**
 * Defines a conjunction expression of two boolean expressions.
 *
 * @generated from message flyteidl.core.ConjunctionExpression
 */
export declare class ConjunctionExpression extends Message<ConjunctionExpression> {
  /**
   * @generated from field: flyteidl.core.ConjunctionExpression.LogicalOperator operator = 1;
   */
  operator: ConjunctionExpression_LogicalOperator;

  /**
   * @generated from field: flyteidl.core.BooleanExpression left_expression = 2;
   */
  leftExpression?: BooleanExpression;

  /**
   * @generated from field: flyteidl.core.BooleanExpression right_expression = 3;
   */
  rightExpression?: BooleanExpression;

  constructor(data?: PartialMessage<ConjunctionExpression>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.ConjunctionExpression";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConjunctionExpression;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConjunctionExpression;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConjunctionExpression;

  static equals(a: ConjunctionExpression | PlainMessage<ConjunctionExpression> | undefined, b: ConjunctionExpression | PlainMessage<ConjunctionExpression> | undefined): boolean;
}

/**
 * Nested conditions. They can be conjoined using AND / OR
 * Order of evaluation is not important as the operators are Commutative
 *
 * @generated from enum flyteidl.core.ConjunctionExpression.LogicalOperator
 */
export declare enum ConjunctionExpression_LogicalOperator {
  /**
   * Conjunction
   *
   * @generated from enum value: AND = 0;
   */
  AND = 0,

  /**
   * @generated from enum value: OR = 1;
   */
  OR = 1,
}

