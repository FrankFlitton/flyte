// @generated by protoc-gen-es v1.4.2 with parameter "target=js+dts+ts,keep_empty_files=false"
// @generated from file flyteidl/core/tasks.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Duration, proto3, Struct } from "@bufbuild/protobuf";
import { KeyValuePair, RetryStrategy } from "./literals_pb.js";
import { Identifier } from "./identifier_pb.js";
import { TypedInterface } from "./interface_pb.js";
import { SecurityContext } from "./security_pb.js";

/**
 * A customizable interface to convey resources requested for a container. This can be interpreted differently for different
 * container engines.
 *
 * @generated from message flyteidl.core.Resources
 */
export const Resources = proto3.makeMessageType(
  "flyteidl.core.Resources",
  () => [
    { no: 1, name: "requests", kind: "message", T: Resources_ResourceEntry, repeated: true },
    { no: 2, name: "limits", kind: "message", T: Resources_ResourceEntry, repeated: true },
  ],
);

/**
 * Known resource names.
 *
 * @generated from enum flyteidl.core.Resources.ResourceName
 */
export const Resources_ResourceName = proto3.makeEnum(
  "flyteidl.core.Resources.ResourceName",
  [
    {no: 0, name: "UNKNOWN"},
    {no: 1, name: "CPU"},
    {no: 2, name: "GPU"},
    {no: 3, name: "MEMORY"},
    {no: 4, name: "STORAGE"},
    {no: 5, name: "EPHEMERAL_STORAGE"},
  ],
);

/**
 * Encapsulates a resource name and value.
 *
 * @generated from message flyteidl.core.Resources.ResourceEntry
 */
export const Resources_ResourceEntry = proto3.makeMessageType(
  "flyteidl.core.Resources.ResourceEntry",
  () => [
    { no: 1, name: "name", kind: "enum", T: proto3.getEnumType(Resources_ResourceName) },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "Resources_ResourceEntry"},
);

/**
 * Metadata associated with the GPU accelerator to allocate to a task. Contains
 * information about device type, and for multi-instance GPUs, the partition size to
 * use.
 *
 * @generated from message flyteidl.core.GPUAccelerator
 */
export const GPUAccelerator = proto3.makeMessageType(
  "flyteidl.core.GPUAccelerator",
  () => [
    { no: 1, name: "device", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "unpartitioned", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "partition_size_value" },
    { no: 3, name: "partition_size", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "partition_size_value" },
  ],
);

/**
 * Encapsulates all non-standard resources, not captured by v1.ResourceRequirements, to
 * allocate to a task.
 *
 * @generated from message flyteidl.core.ExtendedResources
 */
export const ExtendedResources = proto3.makeMessageType(
  "flyteidl.core.ExtendedResources",
  () => [
    { no: 1, name: "gpu_accelerator", kind: "message", T: GPUAccelerator },
  ],
);

/**
 * Runtime information. This is loosely defined to allow for extensibility.
 *
 * @generated from message flyteidl.core.RuntimeMetadata
 */
export const RuntimeMetadata = proto3.makeMessageType(
  "flyteidl.core.RuntimeMetadata",
  () => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(RuntimeMetadata_RuntimeType) },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "flavor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * @generated from enum flyteidl.core.RuntimeMetadata.RuntimeType
 */
export const RuntimeMetadata_RuntimeType = proto3.makeEnum(
  "flyteidl.core.RuntimeMetadata.RuntimeType",
  [
    {no: 0, name: "OTHER"},
    {no: 1, name: "FLYTE_SDK"},
  ],
);

/**
 * Task Metadata
 *
 * @generated from message flyteidl.core.TaskMetadata
 */
export const TaskMetadata = proto3.makeMessageType(
  "flyteidl.core.TaskMetadata",
  () => [
    { no: 1, name: "discoverable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "runtime", kind: "message", T: RuntimeMetadata },
    { no: 4, name: "timeout", kind: "message", T: Duration },
    { no: 5, name: "retries", kind: "message", T: RetryStrategy },
    { no: 6, name: "discovery_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "deprecated_error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "interruptible", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "interruptible_value" },
    { no: 9, name: "cache_serializable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "generates_deck", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "tags", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 12, name: "pod_template_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * A Task structure that uniquely identifies a task in the system
 * Tasks are registered as a first step in the system.
 *
 * @generated from message flyteidl.core.TaskTemplate
 */
export const TaskTemplate = proto3.makeMessageType(
  "flyteidl.core.TaskTemplate",
  () => [
    { no: 1, name: "id", kind: "message", T: Identifier },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "message", T: TaskMetadata },
    { no: 4, name: "interface", kind: "message", T: TypedInterface },
    { no: 5, name: "custom", kind: "message", T: Struct },
    { no: 6, name: "container", kind: "message", T: Container, oneof: "target" },
    { no: 17, name: "k8s_pod", kind: "message", T: K8sPod, oneof: "target" },
    { no: 18, name: "sql", kind: "message", T: Sql, oneof: "target" },
    { no: 7, name: "task_type_version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "security_context", kind: "message", T: SecurityContext },
    { no: 9, name: "extended_resources", kind: "message", T: ExtendedResources },
    { no: 16, name: "config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ],
);

/**
 * Defines port properties for a container.
 *
 * @generated from message flyteidl.core.ContainerPort
 */
export const ContainerPort = proto3.makeMessageType(
  "flyteidl.core.ContainerPort",
  () => [
    { no: 1, name: "container_port", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ],
);

/**
 * @generated from message flyteidl.core.Container
 */
export const Container = proto3.makeMessageType(
  "flyteidl.core.Container",
  () => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "command", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "args", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "resources", kind: "message", T: Resources },
    { no: 5, name: "env", kind: "message", T: KeyValuePair, repeated: true },
    { no: 6, name: "config", kind: "message", T: KeyValuePair, repeated: true },
    { no: 7, name: "ports", kind: "message", T: ContainerPort, repeated: true },
    { no: 9, name: "data_config", kind: "message", T: DataLoadingConfig },
    { no: 10, name: "architecture", kind: "enum", T: proto3.getEnumType(Container_Architecture) },
  ],
);

/**
 * Architecture-type the container image supports.
 *
 * @generated from enum flyteidl.core.Container.Architecture
 */
export const Container_Architecture = proto3.makeEnum(
  "flyteidl.core.Container.Architecture",
  [
    {no: 0, name: "UNKNOWN"},
    {no: 1, name: "AMD64"},
    {no: 2, name: "ARM64"},
    {no: 3, name: "ARM_V6"},
    {no: 4, name: "ARM_V7"},
  ],
);

/**
 * Strategy to use when dealing with Blob, Schema, or multipart blob data (large datasets)
 *
 * @generated from message flyteidl.core.IOStrategy
 */
export const IOStrategy = proto3.makeMessageType(
  "flyteidl.core.IOStrategy",
  () => [
    { no: 1, name: "download_mode", kind: "enum", T: proto3.getEnumType(IOStrategy_DownloadMode) },
    { no: 2, name: "upload_mode", kind: "enum", T: proto3.getEnumType(IOStrategy_UploadMode) },
  ],
);

/**
 * Mode to use for downloading
 *
 * @generated from enum flyteidl.core.IOStrategy.DownloadMode
 */
export const IOStrategy_DownloadMode = proto3.makeEnum(
  "flyteidl.core.IOStrategy.DownloadMode",
  [
    {no: 0, name: "DOWNLOAD_EAGER"},
    {no: 1, name: "DOWNLOAD_STREAM"},
    {no: 2, name: "DO_NOT_DOWNLOAD"},
  ],
);

/**
 * Mode to use for uploading
 *
 * @generated from enum flyteidl.core.IOStrategy.UploadMode
 */
export const IOStrategy_UploadMode = proto3.makeEnum(
  "flyteidl.core.IOStrategy.UploadMode",
  [
    {no: 0, name: "UPLOAD_ON_EXIT"},
    {no: 1, name: "UPLOAD_EAGER"},
    {no: 2, name: "DO_NOT_UPLOAD"},
  ],
);

/**
 * This configuration allows executing raw containers in Flyte using the Flyte CoPilot system.
 * Flyte CoPilot, eliminates the needs of flytekit or sdk inside the container. Any inputs required by the users container are side-loaded in the input_path
 * Any outputs generated by the user container - within output_path are automatically uploaded.
 *
 * @generated from message flyteidl.core.DataLoadingConfig
 */
export const DataLoadingConfig = proto3.makeMessageType(
  "flyteidl.core.DataLoadingConfig",
  () => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "input_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "output_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "format", kind: "enum", T: proto3.getEnumType(DataLoadingConfig_LiteralMapFormat) },
    { no: 5, name: "io_strategy", kind: "message", T: IOStrategy },
  ],
);

/**
 * LiteralMapFormat decides the encoding format in which the input metadata should be made available to the containers.
 * If the user has access to the protocol buffer definitions, it is recommended to use the PROTO format.
 * JSON and YAML do not need any protobuf definitions to read it
 * All remote references in core.LiteralMap are replaced with local filesystem references (the data is downloaded to local filesystem)
 *
 * @generated from enum flyteidl.core.DataLoadingConfig.LiteralMapFormat
 */
export const DataLoadingConfig_LiteralMapFormat = proto3.makeEnum(
  "flyteidl.core.DataLoadingConfig.LiteralMapFormat",
  [
    {no: 0, name: "JSON"},
    {no: 1, name: "YAML"},
    {no: 2, name: "PROTO"},
  ],
);

/**
 * Defines a pod spec and additional pod metadata that is created when a task is executed.
 *
 * @generated from message flyteidl.core.K8sPod
 */
export const K8sPod = proto3.makeMessageType(
  "flyteidl.core.K8sPod",
  () => [
    { no: 1, name: "metadata", kind: "message", T: K8sObjectMetadata },
    { no: 2, name: "pod_spec", kind: "message", T: Struct },
    { no: 3, name: "data_config", kind: "message", T: DataLoadingConfig },
  ],
);

/**
 * Metadata for building a kubernetes object when a task is executed.
 *
 * @generated from message flyteidl.core.K8sObjectMetadata
 */
export const K8sObjectMetadata = proto3.makeMessageType(
  "flyteidl.core.K8sObjectMetadata",
  () => [
    { no: 1, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ],
);

/**
 * Sql represents a generic sql workload with a statement and dialect.
 *
 * @generated from message flyteidl.core.Sql
 */
export const Sql = proto3.makeMessageType(
  "flyteidl.core.Sql",
  () => [
    { no: 1, name: "statement", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dialect", kind: "enum", T: proto3.getEnumType(Sql_Dialect) },
  ],
);

/**
 * The dialect of the SQL statement. This is used to validate and parse SQL statements at compilation time to avoid
 * expensive runtime operations. If set to an unsupported dialect, no validation will be done on the statement.
 * We support the following dialect: ansi, hive.
 *
 * @generated from enum flyteidl.core.Sql.Dialect
 */
export const Sql_Dialect = proto3.makeEnum(
  "flyteidl.core.Sql.Dialect",
  [
    {no: 0, name: "UNDEFINED"},
    {no: 1, name: "ANSI"},
    {no: 2, name: "HIVE"},
    {no: 3, name: "OTHER"},
  ],
);

