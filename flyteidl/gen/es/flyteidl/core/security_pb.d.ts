// @generated by protoc-gen-es v1.4.2 with parameter "target=js+dts+ts,keep_empty_files=false"
// @generated from file flyteidl/core/security.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Secret encapsulates information about the secret a task needs to proceed. An environment variable
 * FLYTE_SECRETS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if
 * secrets are passed through environment variables.
 * FLYTE_SECRETS_DEFAULT_DIR will be passed to indicate the prefix of the path where secrets will be mounted if secrets
 * are passed through file mounts.
 *
 * @generated from message flyteidl.core.Secret
 */
export declare class Secret extends Message<Secret> {
  /**
   * The name of the secret group where to find the key referenced below. For K8s secrets, this should be the name of
   * the v1/secret object. For Confidant, this should be the Credential name. For Vault, this should be the secret name.
   * For AWS Secret Manager, this should be the name of the secret.
   * +required
   *
   * @generated from field: string group = 1;
   */
  group: string;

  /**
   * The group version to fetch. This is not supported in all secret management systems. It'll be ignored for the ones
   * that do not support it.
   * +optional
   *
   * @generated from field: string group_version = 2;
   */
  groupVersion: string;

  /**
   * The name of the secret to mount. This has to match an existing secret in the system. It's up to the implementation
   * of the secret management system to require case sensitivity. For K8s secrets, Confidant and Vault, this should
   * match one of the keys inside the secret. For AWS Secret Manager, it's ignored.
   * +optional
   *
   * @generated from field: string key = 3;
   */
  key: string;

  /**
   * mount_requirement is optional. Indicates where the secret has to be mounted. If provided, the execution will fail
   * if the underlying key management system cannot satisfy that requirement. If not provided, the default location
   * will depend on the key management system.
   * +optional
   *
   * @generated from field: flyteidl.core.Secret.MountType mount_requirement = 4;
   */
  mountRequirement: Secret_MountType;

  constructor(data?: PartialMessage<Secret>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Secret";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Secret;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Secret;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Secret;

  static equals(a: Secret | PlainMessage<Secret> | undefined, b: Secret | PlainMessage<Secret> | undefined): boolean;
}

/**
 * @generated from enum flyteidl.core.Secret.MountType
 */
export declare enum Secret_MountType {
  /**
   * Default case, indicates the client can tolerate either mounting options.
   *
   * @generated from enum value: ANY = 0;
   */
  ANY = 0,

  /**
   * ENV_VAR indicates the secret needs to be mounted as an environment variable.
   *
   * @generated from enum value: ENV_VAR = 1;
   */
  ENV_VAR = 1,

  /**
   * FILE indicates the secret needs to be mounted as a file.
   *
   * @generated from enum value: FILE = 2;
   */
  FILE = 2,
}

/**
 * OAuth2Client encapsulates OAuth2 Client Credentials to be used when making calls on behalf of that task.
 *
 * @generated from message flyteidl.core.OAuth2Client
 */
export declare class OAuth2Client extends Message<OAuth2Client> {
  /**
   * client_id is the public id for the client to use. The system will not perform any pre-auth validation that the
   * secret requested matches the client_id indicated here.
   * +required
   *
   * @generated from field: string client_id = 1;
   */
  clientId: string;

  /**
   * client_secret is a reference to the secret used to authenticate the OAuth2 client.
   * +required
   *
   * @generated from field: flyteidl.core.Secret client_secret = 2;
   */
  clientSecret?: Secret;

  constructor(data?: PartialMessage<OAuth2Client>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.OAuth2Client";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OAuth2Client;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OAuth2Client;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OAuth2Client;

  static equals(a: OAuth2Client | PlainMessage<OAuth2Client> | undefined, b: OAuth2Client | PlainMessage<OAuth2Client> | undefined): boolean;
}

/**
 * Identity encapsulates the various security identities a task can run as. It's up to the underlying plugin to pick the
 * right identity for the execution environment.
 *
 * @generated from message flyteidl.core.Identity
 */
export declare class Identity extends Message<Identity> {
  /**
   * iam_role references the fully qualified name of Identity & Access Management role to impersonate.
   *
   * @generated from field: string iam_role = 1;
   */
  iamRole: string;

  /**
   * k8s_service_account references a kubernetes service account to impersonate.
   *
   * @generated from field: string k8s_service_account = 2;
   */
  k8sServiceAccount: string;

  /**
   * oauth2_client references an oauth2 client. Backend plugins can use this information to impersonate the client when
   * making external calls.
   *
   * @generated from field: flyteidl.core.OAuth2Client oauth2_client = 3;
   */
  oauth2Client?: OAuth2Client;

  /**
   * execution_identity references the subject who makes the execution
   *
   * @generated from field: string execution_identity = 4;
   */
  executionIdentity: string;

  constructor(data?: PartialMessage<Identity>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Identity";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identity;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identity;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identity;

  static equals(a: Identity | PlainMessage<Identity> | undefined, b: Identity | PlainMessage<Identity> | undefined): boolean;
}

/**
 * OAuth2TokenRequest encapsulates information needed to request an OAuth2 token.
 * FLYTE_TOKENS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if
 * tokens are passed through environment variables.
 * FLYTE_TOKENS_PATH_PREFIX will be passed to indicate the prefix of the path where secrets will be mounted if tokens
 * are passed through file mounts.
 *
 * @generated from message flyteidl.core.OAuth2TokenRequest
 */
export declare class OAuth2TokenRequest extends Message<OAuth2TokenRequest> {
  /**
   * name indicates a unique id for the token request within this task token requests. It'll be used as a suffix for
   * environment variables and as a filename for mounting tokens as files.
   * +required
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * type indicates the type of the request to make. Defaults to CLIENT_CREDENTIALS.
   * +required
   *
   * @generated from field: flyteidl.core.OAuth2TokenRequest.Type type = 2;
   */
  type: OAuth2TokenRequest_Type;

  /**
   * client references the client_id/secret to use to request the OAuth2 token.
   * +required
   *
   * @generated from field: flyteidl.core.OAuth2Client client = 3;
   */
  client?: OAuth2Client;

  /**
   * idp_discovery_endpoint references the discovery endpoint used to retrieve token endpoint and other related
   * information.
   * +optional
   *
   * @generated from field: string idp_discovery_endpoint = 4;
   */
  idpDiscoveryEndpoint: string;

  /**
   * token_endpoint references the token issuance endpoint. If idp_discovery_endpoint is not provided, this parameter is
   * mandatory.
   * +optional
   *
   * @generated from field: string token_endpoint = 5;
   */
  tokenEndpoint: string;

  constructor(data?: PartialMessage<OAuth2TokenRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.OAuth2TokenRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OAuth2TokenRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OAuth2TokenRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OAuth2TokenRequest;

  static equals(a: OAuth2TokenRequest | PlainMessage<OAuth2TokenRequest> | undefined, b: OAuth2TokenRequest | PlainMessage<OAuth2TokenRequest> | undefined): boolean;
}

/**
 * Type of the token requested.
 *
 * @generated from enum flyteidl.core.OAuth2TokenRequest.Type
 */
export declare enum OAuth2TokenRequest_Type {
  /**
   * CLIENT_CREDENTIALS indicates a 2-legged OAuth token requested using client credentials.
   *
   * @generated from enum value: CLIENT_CREDENTIALS = 0;
   */
  CLIENT_CREDENTIALS = 0,
}

/**
 * SecurityContext holds security attributes that apply to tasks.
 *
 * @generated from message flyteidl.core.SecurityContext
 */
export declare class SecurityContext extends Message<SecurityContext> {
  /**
   * run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the
   * backend plugin to choose the appropriate identity for the execution engine the task will run on.
   *
   * @generated from field: flyteidl.core.Identity run_as = 1;
   */
  runAs?: Identity;

  /**
   * secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   *
   * @generated from field: repeated flyteidl.core.Secret secrets = 2;
   */
  secrets: Secret[];

  /**
   * tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the
   * pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS
   * Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access
   * to the secret) and to pass it to the remote execution engine.
   *
   * @generated from field: repeated flyteidl.core.OAuth2TokenRequest tokens = 3;
   */
  tokens: OAuth2TokenRequest[];

  constructor(data?: PartialMessage<SecurityContext>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.SecurityContext";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityContext;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityContext;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityContext;

  static equals(a: SecurityContext | PlainMessage<SecurityContext> | undefined, b: SecurityContext | PlainMessage<SecurityContext> | undefined): boolean;
}

