// @generated by protoc-gen-es v1.4.2 with parameter "target=js+dts+ts,keep_empty_files=false"
// @generated from file flyteidl/core/condition.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3 } from "@bufbuild/protobuf";
import { Primitive, Scalar } from "./literals_pb.js";

/**
 * Defines a 2-level tree where the root is a comparison operator and Operands are primitives or known variables.
 * Each expression results in a boolean result.
 *
 * @generated from message flyteidl.core.ComparisonExpression
 */
export const ComparisonExpression = proto3.makeMessageType(
  "flyteidl.core.ComparisonExpression",
  () => [
    { no: 1, name: "operator", kind: "enum", T: proto3.getEnumType(ComparisonExpression_Operator) },
    { no: 2, name: "left_value", kind: "message", T: Operand },
    { no: 3, name: "right_value", kind: "message", T: Operand },
  ],
);

/**
 * Binary Operator for each expression
 *
 * @generated from enum flyteidl.core.ComparisonExpression.Operator
 */
export const ComparisonExpression_Operator = proto3.makeEnum(
  "flyteidl.core.ComparisonExpression.Operator",
  [
    {no: 0, name: "EQ"},
    {no: 1, name: "NEQ"},
    {no: 2, name: "GT"},
    {no: 3, name: "GTE"},
    {no: 4, name: "LT"},
    {no: 5, name: "LTE"},
  ],
);

/**
 * Defines an operand to a comparison expression.
 *
 * @generated from message flyteidl.core.Operand
 */
export const Operand = proto3.makeMessageType(
  "flyteidl.core.Operand",
  () => [
    { no: 1, name: "primitive", kind: "message", T: Primitive, oneof: "val" },
    { no: 2, name: "var", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "val" },
    { no: 3, name: "scalar", kind: "message", T: Scalar, oneof: "val" },
  ],
);

/**
 * Defines a boolean expression tree. It can be a simple or a conjunction expression.
 * Multiple expressions can be combined using a conjunction or a disjunction to result in a final boolean result.
 *
 * @generated from message flyteidl.core.BooleanExpression
 */
export const BooleanExpression = proto3.makeMessageType(
  "flyteidl.core.BooleanExpression",
  () => [
    { no: 1, name: "conjunction", kind: "message", T: ConjunctionExpression, oneof: "expr" },
    { no: 2, name: "comparison", kind: "message", T: ComparisonExpression, oneof: "expr" },
  ],
);

/**
 * Defines a conjunction expression of two boolean expressions.
 *
 * @generated from message flyteidl.core.ConjunctionExpression
 */
export const ConjunctionExpression = proto3.makeMessageType(
  "flyteidl.core.ConjunctionExpression",
  () => [
    { no: 1, name: "operator", kind: "enum", T: proto3.getEnumType(ConjunctionExpression_LogicalOperator) },
    { no: 2, name: "left_expression", kind: "message", T: BooleanExpression },
    { no: 3, name: "right_expression", kind: "message", T: BooleanExpression },
  ],
);

/**
 * Nested conditions. They can be conjoined using AND / OR
 * Order of evaluation is not important as the operators are Commutative
 *
 * @generated from enum flyteidl.core.ConjunctionExpression.LogicalOperator
 */
export const ConjunctionExpression_LogicalOperator = proto3.makeEnum(
  "flyteidl.core.ConjunctionExpression.LogicalOperator",
  [
    {no: 0, name: "AND"},
    {no: 1, name: "OR"},
  ],
);

