// @generated by protoc-gen-es v1.4.2 with parameter "target=js+dts+ts,keep_empty_files=false"
// @generated from file flyteidl/core/literals.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Struct, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { BlobType, Error, LiteralType, OutputReference, SchemaType, StructuredDatasetType } from "./types_pb.js";

/**
 * Primitive Types
 *
 * @generated from message flyteidl.core.Primitive
 */
export declare class Primitive extends Message<Primitive> {
  /**
   * Defines one of simple primitive types. These types will get translated into different programming languages as
   * described in https://developers.google.com/protocol-buffers/docs/proto#scalar.
   *
   * @generated from oneof flyteidl.core.Primitive.value
   */
  value: {
    /**
     * @generated from field: int64 integer = 1;
     */
    value: bigint;
    case: "integer";
  } | {
    /**
     * @generated from field: double float_value = 2;
     */
    value: number;
    case: "floatValue";
  } | {
    /**
     * @generated from field: string string_value = 3;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * @generated from field: bool boolean = 4;
     */
    value: boolean;
    case: "boolean";
  } | {
    /**
     * @generated from field: google.protobuf.Timestamp datetime = 5;
     */
    value: Timestamp;
    case: "datetime";
  } | {
    /**
     * @generated from field: google.protobuf.Duration duration = 6;
     */
    value: Duration;
    case: "duration";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Primitive>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Primitive";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Primitive;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Primitive;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Primitive;

  static equals(a: Primitive | PlainMessage<Primitive> | undefined, b: Primitive | PlainMessage<Primitive> | undefined): boolean;
}

/**
 * Used to denote a nil/null/None assignment to a scalar value. The underlying LiteralType for Void is intentionally
 * undefined since it can be assigned to a scalar of any LiteralType.
 *
 * @generated from message flyteidl.core.Void
 */
export declare class Void extends Message<Void> {
  constructor(data?: PartialMessage<Void>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Void";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Void;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Void;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Void;

  static equals(a: Void | PlainMessage<Void> | undefined, b: Void | PlainMessage<Void> | undefined): boolean;
}

/**
 * Refers to an offloaded set of files. It encapsulates the type of the store and a unique uri for where the data is.
 * There are no restrictions on how the uri is formatted since it will depend on how to interact with the store.
 *
 * @generated from message flyteidl.core.Blob
 */
export declare class Blob extends Message<Blob> {
  /**
   * @generated from field: flyteidl.core.BlobMetadata metadata = 1;
   */
  metadata?: BlobMetadata;

  /**
   * @generated from field: string uri = 3;
   */
  uri: string;

  constructor(data?: PartialMessage<Blob>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Blob";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Blob;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Blob;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Blob;

  static equals(a: Blob | PlainMessage<Blob> | undefined, b: Blob | PlainMessage<Blob> | undefined): boolean;
}

/**
 * @generated from message flyteidl.core.BlobMetadata
 */
export declare class BlobMetadata extends Message<BlobMetadata> {
  /**
   * @generated from field: flyteidl.core.BlobType type = 1;
   */
  type?: BlobType;

  constructor(data?: PartialMessage<BlobMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.BlobMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlobMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlobMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlobMetadata;

  static equals(a: BlobMetadata | PlainMessage<BlobMetadata> | undefined, b: BlobMetadata | PlainMessage<BlobMetadata> | undefined): boolean;
}

/**
 * A simple byte array with a tag to help different parts of the system communicate about what is in the byte array.
 * It's strongly advisable that consumers of this type define a unique tag and validate the tag before parsing the data.
 *
 * @generated from message flyteidl.core.Binary
 */
export declare class Binary extends Message<Binary> {
  /**
   * @generated from field: bytes value = 1;
   */
  value: Uint8Array;

  /**
   * @generated from field: string tag = 2;
   */
  tag: string;

  constructor(data?: PartialMessage<Binary>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Binary";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Binary;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Binary;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Binary;

  static equals(a: Binary | PlainMessage<Binary> | undefined, b: Binary | PlainMessage<Binary> | undefined): boolean;
}

/**
 * A strongly typed schema that defines the interface of data retrieved from the underlying storage medium.
 *
 * @generated from message flyteidl.core.Schema
 */
export declare class Schema extends Message<Schema> {
  /**
   * @generated from field: string uri = 1;
   */
  uri: string;

  /**
   * @generated from field: flyteidl.core.SchemaType type = 3;
   */
  type?: SchemaType;

  constructor(data?: PartialMessage<Schema>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Schema";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Schema;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Schema;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Schema;

  static equals(a: Schema | PlainMessage<Schema> | undefined, b: Schema | PlainMessage<Schema> | undefined): boolean;
}

/**
 * The runtime representation of a tagged union value. See `UnionType` for more details.
 *
 * @generated from message flyteidl.core.Union
 */
export declare class Union extends Message<Union> {
  /**
   * @generated from field: flyteidl.core.Literal value = 1;
   */
  value?: Literal;

  /**
   * @generated from field: flyteidl.core.LiteralType type = 2;
   */
  type?: LiteralType;

  constructor(data?: PartialMessage<Union>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Union";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Union;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Union;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Union;

  static equals(a: Union | PlainMessage<Union> | undefined, b: Union | PlainMessage<Union> | undefined): boolean;
}

/**
 * @generated from message flyteidl.core.StructuredDatasetMetadata
 */
export declare class StructuredDatasetMetadata extends Message<StructuredDatasetMetadata> {
  /**
   * Bundle the type information along with the literal.
   * This is here because StructuredDatasets can often be more defined at run time than at compile time.
   * That is, at compile time you might only declare a task to return a pandas dataframe or a StructuredDataset,
   * without any column information, but at run time, you might have that column information.
   * flytekit python will copy this type information into the literal, from the type information, if not provided by
   * the various plugins (encoders).
   * Since this field is run time generated, it's not used for any type checking.
   *
   * @generated from field: flyteidl.core.StructuredDatasetType structured_dataset_type = 1;
   */
  structuredDatasetType?: StructuredDatasetType;

  constructor(data?: PartialMessage<StructuredDatasetMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.StructuredDatasetMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StructuredDatasetMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StructuredDatasetMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StructuredDatasetMetadata;

  static equals(a: StructuredDatasetMetadata | PlainMessage<StructuredDatasetMetadata> | undefined, b: StructuredDatasetMetadata | PlainMessage<StructuredDatasetMetadata> | undefined): boolean;
}

/**
 * @generated from message flyteidl.core.StructuredDataset
 */
export declare class StructuredDataset extends Message<StructuredDataset> {
  /**
   * String location uniquely identifying where the data is.
   * Should start with the storage location (e.g. s3://, gs://, bq://, etc.)
   *
   * @generated from field: string uri = 1;
   */
  uri: string;

  /**
   * @generated from field: flyteidl.core.StructuredDatasetMetadata metadata = 2;
   */
  metadata?: StructuredDatasetMetadata;

  constructor(data?: PartialMessage<StructuredDataset>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.StructuredDataset";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StructuredDataset;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StructuredDataset;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StructuredDataset;

  static equals(a: StructuredDataset | PlainMessage<StructuredDataset> | undefined, b: StructuredDataset | PlainMessage<StructuredDataset> | undefined): boolean;
}

/**
 * @generated from message flyteidl.core.Scalar
 */
export declare class Scalar extends Message<Scalar> {
  /**
   * @generated from oneof flyteidl.core.Scalar.value
   */
  value: {
    /**
     * @generated from field: flyteidl.core.Primitive primitive = 1;
     */
    value: Primitive;
    case: "primitive";
  } | {
    /**
     * @generated from field: flyteidl.core.Blob blob = 2;
     */
    value: Blob;
    case: "blob";
  } | {
    /**
     * @generated from field: flyteidl.core.Binary binary = 3;
     */
    value: Binary;
    case: "binary";
  } | {
    /**
     * @generated from field: flyteidl.core.Schema schema = 4;
     */
    value: Schema;
    case: "schema";
  } | {
    /**
     * @generated from field: flyteidl.core.Void none_type = 5;
     */
    value: Void;
    case: "noneType";
  } | {
    /**
     * @generated from field: flyteidl.core.Error error = 6;
     */
    value: Error;
    case: "error";
  } | {
    /**
     * @generated from field: google.protobuf.Struct generic = 7;
     */
    value: Struct;
    case: "generic";
  } | {
    /**
     * @generated from field: flyteidl.core.StructuredDataset structured_dataset = 8;
     */
    value: StructuredDataset;
    case: "structuredDataset";
  } | {
    /**
     * @generated from field: flyteidl.core.Union union = 9;
     */
    value: Union;
    case: "union";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Scalar>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Scalar";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Scalar;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Scalar;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Scalar;

  static equals(a: Scalar | PlainMessage<Scalar> | undefined, b: Scalar | PlainMessage<Scalar> | undefined): boolean;
}

/**
 * A simple value. This supports any level of nesting (e.g. array of array of array of Blobs) as well as simple primitives.
 *
 * @generated from message flyteidl.core.Literal
 */
export declare class Literal extends Message<Literal> {
  /**
   * @generated from oneof flyteidl.core.Literal.value
   */
  value: {
    /**
     * A simple value.
     *
     * @generated from field: flyteidl.core.Scalar scalar = 1;
     */
    value: Scalar;
    case: "scalar";
  } | {
    /**
     * A collection of literals to allow nesting.
     *
     * @generated from field: flyteidl.core.LiteralCollection collection = 2;
     */
    value: LiteralCollection;
    case: "collection";
  } | {
    /**
     * A map of strings to literals.
     *
     * @generated from field: flyteidl.core.LiteralMap map = 3;
     */
    value: LiteralMap;
    case: "map";
  } | { case: undefined; value?: undefined };

  /**
   * A hash representing this literal.
   * This is used for caching purposes. For more details refer to RFC 1893
   * (https://github.com/flyteorg/flyte/blob/master/rfc/system/1893-caching-of-offloaded-objects.md)
   *
   * @generated from field: string hash = 4;
   */
  hash: string;

  constructor(data?: PartialMessage<Literal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Literal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Literal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Literal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Literal;

  static equals(a: Literal | PlainMessage<Literal> | undefined, b: Literal | PlainMessage<Literal> | undefined): boolean;
}

/**
 * A collection of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
 *
 * @generated from message flyteidl.core.LiteralCollection
 */
export declare class LiteralCollection extends Message<LiteralCollection> {
  /**
   * @generated from field: repeated flyteidl.core.Literal literals = 1;
   */
  literals: Literal[];

  constructor(data?: PartialMessage<LiteralCollection>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.LiteralCollection";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LiteralCollection;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LiteralCollection;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LiteralCollection;

  static equals(a: LiteralCollection | PlainMessage<LiteralCollection> | undefined, b: LiteralCollection | PlainMessage<LiteralCollection> | undefined): boolean;
}

/**
 * A map of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
 *
 * @generated from message flyteidl.core.LiteralMap
 */
export declare class LiteralMap extends Message<LiteralMap> {
  /**
   * @generated from field: map<string, flyteidl.core.Literal> literals = 1;
   */
  literals: { [key: string]: Literal };

  constructor(data?: PartialMessage<LiteralMap>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.LiteralMap";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LiteralMap;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LiteralMap;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LiteralMap;

  static equals(a: LiteralMap | PlainMessage<LiteralMap> | undefined, b: LiteralMap | PlainMessage<LiteralMap> | undefined): boolean;
}

/**
 * A collection of BindingData items.
 *
 * @generated from message flyteidl.core.BindingDataCollection
 */
export declare class BindingDataCollection extends Message<BindingDataCollection> {
  /**
   * @generated from field: repeated flyteidl.core.BindingData bindings = 1;
   */
  bindings: BindingData[];

  constructor(data?: PartialMessage<BindingDataCollection>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.BindingDataCollection";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BindingDataCollection;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BindingDataCollection;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BindingDataCollection;

  static equals(a: BindingDataCollection | PlainMessage<BindingDataCollection> | undefined, b: BindingDataCollection | PlainMessage<BindingDataCollection> | undefined): boolean;
}

/**
 * A map of BindingData items.
 *
 * @generated from message flyteidl.core.BindingDataMap
 */
export declare class BindingDataMap extends Message<BindingDataMap> {
  /**
   * @generated from field: map<string, flyteidl.core.BindingData> bindings = 1;
   */
  bindings: { [key: string]: BindingData };

  constructor(data?: PartialMessage<BindingDataMap>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.BindingDataMap";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BindingDataMap;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BindingDataMap;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BindingDataMap;

  static equals(a: BindingDataMap | PlainMessage<BindingDataMap> | undefined, b: BindingDataMap | PlainMessage<BindingDataMap> | undefined): boolean;
}

/**
 * @generated from message flyteidl.core.UnionInfo
 */
export declare class UnionInfo extends Message<UnionInfo> {
  /**
   * @generated from field: flyteidl.core.LiteralType targetType = 1;
   */
  targetType?: LiteralType;

  constructor(data?: PartialMessage<UnionInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.UnionInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnionInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnionInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnionInfo;

  static equals(a: UnionInfo | PlainMessage<UnionInfo> | undefined, b: UnionInfo | PlainMessage<UnionInfo> | undefined): boolean;
}

/**
 * Specifies either a simple value or a reference to another output.
 *
 * @generated from message flyteidl.core.BindingData
 */
export declare class BindingData extends Message<BindingData> {
  /**
   * @generated from oneof flyteidl.core.BindingData.value
   */
  value: {
    /**
     * A simple scalar value.
     *
     * @generated from field: flyteidl.core.Scalar scalar = 1;
     */
    value: Scalar;
    case: "scalar";
  } | {
    /**
     * A collection of binding data. This allows nesting of binding data to any number
     * of levels.
     *
     * @generated from field: flyteidl.core.BindingDataCollection collection = 2;
     */
    value: BindingDataCollection;
    case: "collection";
  } | {
    /**
     * References an output promised by another node.
     *
     * @generated from field: flyteidl.core.OutputReference promise = 3;
     */
    value: OutputReference;
    case: "promise";
  } | {
    /**
     * A map of bindings. The key is always a string.
     *
     * @generated from field: flyteidl.core.BindingDataMap map = 4;
     */
    value: BindingDataMap;
    case: "map";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: flyteidl.core.UnionInfo union = 5;
   */
  union?: UnionInfo;

  constructor(data?: PartialMessage<BindingData>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.BindingData";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BindingData;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BindingData;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BindingData;

  static equals(a: BindingData | PlainMessage<BindingData> | undefined, b: BindingData | PlainMessage<BindingData> | undefined): boolean;
}

/**
 * An input/output binding of a variable to either static value or a node output.
 *
 * @generated from message flyteidl.core.Binding
 */
export declare class Binding extends Message<Binding> {
  /**
   * Variable name must match an input/output variable of the node.
   *
   * @generated from field: string var = 1;
   */
  var: string;

  /**
   * Data to use to bind this variable.
   *
   * @generated from field: flyteidl.core.BindingData binding = 2;
   */
  binding?: BindingData;

  constructor(data?: PartialMessage<Binding>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Binding";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Binding;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Binding;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Binding;

  static equals(a: Binding | PlainMessage<Binding> | undefined, b: Binding | PlainMessage<Binding> | undefined): boolean;
}

/**
 * A generic key value pair.
 *
 * @generated from message flyteidl.core.KeyValuePair
 */
export declare class KeyValuePair extends Message<KeyValuePair> {
  /**
   * required.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * +optional.
   *
   * @generated from field: string value = 2;
   */
  value: string;

  constructor(data?: PartialMessage<KeyValuePair>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.KeyValuePair";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyValuePair;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyValuePair;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyValuePair;

  static equals(a: KeyValuePair | PlainMessage<KeyValuePair> | undefined, b: KeyValuePair | PlainMessage<KeyValuePair> | undefined): boolean;
}

/**
 * Retry strategy associated with an executable unit.
 *
 * @generated from message flyteidl.core.RetryStrategy
 */
export declare class RetryStrategy extends Message<RetryStrategy> {
  /**
   * Number of retries. Retries will be consumed when the job fails with a recoverable error.
   * The number of retries must be less than or equals to 10.
   *
   * @generated from field: uint32 retries = 5;
   */
  retries: number;

  constructor(data?: PartialMessage<RetryStrategy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.RetryStrategy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RetryStrategy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RetryStrategy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RetryStrategy;

  static equals(a: RetryStrategy | PlainMessage<RetryStrategy> | undefined, b: RetryStrategy | PlainMessage<RetryStrategy> | undefined): boolean;
}

