// @generated by protoc-gen-es v1.4.2 with parameter "target=js+dts+ts,keep_empty_files=false"
// @generated from file flyteidl/core/workflow.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { BooleanExpression } from "./condition_pb.js";
import type { Error, LiteralType } from "./types_pb.js";
import type { Identifier } from "./identifier_pb.js";
import type { Binding, RetryStrategy } from "./literals_pb.js";
import type { QualityOfService } from "./execution_pb.js";
import type { TypedInterface } from "./interface_pb.js";
import type { ExtendedResources, Resources } from "./tasks_pb.js";

/**
 * Defines a condition and the execution unit that should be executed if the condition is satisfied.
 *
 * @generated from message flyteidl.core.IfBlock
 */
export declare class IfBlock extends Message<IfBlock> {
  /**
   * @generated from field: flyteidl.core.BooleanExpression condition = 1;
   */
  condition?: BooleanExpression;

  /**
   * @generated from field: flyteidl.core.Node then_node = 2;
   */
  thenNode?: Node;

  constructor(data?: PartialMessage<IfBlock>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.IfBlock";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IfBlock;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IfBlock;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IfBlock;

  static equals(a: IfBlock | PlainMessage<IfBlock> | undefined, b: IfBlock | PlainMessage<IfBlock> | undefined): boolean;
}

/**
 * Defines a series of if/else blocks. The first branch whose condition evaluates to true is the one to execute.
 * If no conditions were satisfied, the else_node or the error will execute.
 *
 * @generated from message flyteidl.core.IfElseBlock
 */
export declare class IfElseBlock extends Message<IfElseBlock> {
  /**
   * +required. First condition to evaluate.
   *
   * @generated from field: flyteidl.core.IfBlock case = 1;
   */
  case?: IfBlock;

  /**
   * +optional. Additional branches to evaluate.
   *
   * @generated from field: repeated flyteidl.core.IfBlock other = 2;
   */
  other: IfBlock[];

  /**
   * +required.
   *
   * @generated from oneof flyteidl.core.IfElseBlock.default
   */
  default: {
    /**
     * The node to execute in case none of the branches were taken.
     *
     * @generated from field: flyteidl.core.Node else_node = 3;
     */
    value: Node;
    case: "elseNode";
  } | {
    /**
     * An error to throw in case none of the branches were taken.
     *
     * @generated from field: flyteidl.core.Error error = 4;
     */
    value: Error;
    case: "error";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<IfElseBlock>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.IfElseBlock";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IfElseBlock;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IfElseBlock;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IfElseBlock;

  static equals(a: IfElseBlock | PlainMessage<IfElseBlock> | undefined, b: IfElseBlock | PlainMessage<IfElseBlock> | undefined): boolean;
}

/**
 * BranchNode is a special node that alter the flow of the workflow graph. It allows the control flow to branch at
 * runtime based on a series of conditions that get evaluated on various parameters (e.g. inputs, primitives).
 *
 * @generated from message flyteidl.core.BranchNode
 */
export declare class BranchNode extends Message<BranchNode> {
  /**
   * +required
   *
   * @generated from field: flyteidl.core.IfElseBlock if_else = 1;
   */
  ifElse?: IfElseBlock;

  constructor(data?: PartialMessage<BranchNode>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.BranchNode";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BranchNode;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BranchNode;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BranchNode;

  static equals(a: BranchNode | PlainMessage<BranchNode> | undefined, b: BranchNode | PlainMessage<BranchNode> | undefined): boolean;
}

/**
 * Refers to the task that the Node is to execute.
 *
 * @generated from message flyteidl.core.TaskNode
 */
export declare class TaskNode extends Message<TaskNode> {
  /**
   * @generated from oneof flyteidl.core.TaskNode.reference
   */
  reference: {
    /**
     * A globally unique identifier for the task.
     *
     * @generated from field: flyteidl.core.Identifier reference_id = 1;
     */
    value: Identifier;
    case: "referenceId";
  } | { case: undefined; value?: undefined };

  /**
   * Optional overrides applied at task execution time.
   *
   * @generated from field: flyteidl.core.TaskNodeOverrides overrides = 2;
   */
  overrides?: TaskNodeOverrides;

  constructor(data?: PartialMessage<TaskNode>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.TaskNode";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskNode;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskNode;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskNode;

  static equals(a: TaskNode | PlainMessage<TaskNode> | undefined, b: TaskNode | PlainMessage<TaskNode> | undefined): boolean;
}

/**
 * Refers to a the workflow the node is to execute.
 *
 * @generated from message flyteidl.core.WorkflowNode
 */
export declare class WorkflowNode extends Message<WorkflowNode> {
  /**
   * @generated from oneof flyteidl.core.WorkflowNode.reference
   */
  reference: {
    /**
     * A globally unique identifier for the launch plan.
     *
     * @generated from field: flyteidl.core.Identifier launchplan_ref = 1;
     */
    value: Identifier;
    case: "launchplanRef";
  } | {
    /**
     * Reference to a subworkflow, that should be defined with the compiler context
     *
     * @generated from field: flyteidl.core.Identifier sub_workflow_ref = 2;
     */
    value: Identifier;
    case: "subWorkflowRef";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<WorkflowNode>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.WorkflowNode";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowNode;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowNode;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowNode;

  static equals(a: WorkflowNode | PlainMessage<WorkflowNode> | undefined, b: WorkflowNode | PlainMessage<WorkflowNode> | undefined): boolean;
}

/**
 * ApproveCondition represents a dependency on an external approval. During execution, this will manifest as a boolean
 * signal with the provided signal_id.
 *
 * @generated from message flyteidl.core.ApproveCondition
 */
export declare class ApproveCondition extends Message<ApproveCondition> {
  /**
   * A unique identifier for the requested boolean signal.
   *
   * @generated from field: string signal_id = 1;
   */
  signalId: string;

  constructor(data?: PartialMessage<ApproveCondition>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.ApproveCondition";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApproveCondition;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApproveCondition;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApproveCondition;

  static equals(a: ApproveCondition | PlainMessage<ApproveCondition> | undefined, b: ApproveCondition | PlainMessage<ApproveCondition> | undefined): boolean;
}

/**
 * SignalCondition represents a dependency on an signal.
 *
 * @generated from message flyteidl.core.SignalCondition
 */
export declare class SignalCondition extends Message<SignalCondition> {
  /**
   * A unique identifier for the requested signal.
   *
   * @generated from field: string signal_id = 1;
   */
  signalId: string;

  /**
   * A type denoting the required value type for this signal.
   *
   * @generated from field: flyteidl.core.LiteralType type = 2;
   */
  type?: LiteralType;

  /**
   * The variable name for the signal value in this nodes outputs.
   *
   * @generated from field: string output_variable_name = 3;
   */
  outputVariableName: string;

  constructor(data?: PartialMessage<SignalCondition>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.SignalCondition";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalCondition;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalCondition;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalCondition;

  static equals(a: SignalCondition | PlainMessage<SignalCondition> | undefined, b: SignalCondition | PlainMessage<SignalCondition> | undefined): boolean;
}

/**
 * SleepCondition represents a dependency on waiting for the specified duration.
 *
 * @generated from message flyteidl.core.SleepCondition
 */
export declare class SleepCondition extends Message<SleepCondition> {
  /**
   * The overall duration for this sleep.
   *
   * @generated from field: google.protobuf.Duration duration = 1;
   */
  duration?: Duration;

  constructor(data?: PartialMessage<SleepCondition>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.SleepCondition";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SleepCondition;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SleepCondition;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SleepCondition;

  static equals(a: SleepCondition | PlainMessage<SleepCondition> | undefined, b: SleepCondition | PlainMessage<SleepCondition> | undefined): boolean;
}

/**
 * GateNode refers to the condition that is required for the gate to successfully complete.
 *
 * @generated from message flyteidl.core.GateNode
 */
export declare class GateNode extends Message<GateNode> {
  /**
   * @generated from oneof flyteidl.core.GateNode.condition
   */
  condition: {
    /**
     * ApproveCondition represents a dependency on an external approval provided by a boolean signal.
     *
     * @generated from field: flyteidl.core.ApproveCondition approve = 1;
     */
    value: ApproveCondition;
    case: "approve";
  } | {
    /**
     * SignalCondition represents a dependency on an signal.
     *
     * @generated from field: flyteidl.core.SignalCondition signal = 2;
     */
    value: SignalCondition;
    case: "signal";
  } | {
    /**
     * SleepCondition represents a dependency on waiting for the specified duration.
     *
     * @generated from field: flyteidl.core.SleepCondition sleep = 3;
     */
    value: SleepCondition;
    case: "sleep";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<GateNode>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.GateNode";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GateNode;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GateNode;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GateNode;

  static equals(a: GateNode | PlainMessage<GateNode> | undefined, b: GateNode | PlainMessage<GateNode> | undefined): boolean;
}

/**
 * ArrayNode is a Flyte node type that simplifies the execution of a sub-node over a list of input
 * values. An ArrayNode can be executed with configurable parallelism (separate from the parent
 * workflow) and can be configured to succeed when a certain number of sub-nodes succeed.
 *
 * @generated from message flyteidl.core.ArrayNode
 */
export declare class ArrayNode extends Message<ArrayNode> {
  /**
   * node is the sub-node that will be executed for each element in the array.
   *
   * @generated from field: flyteidl.core.Node node = 1;
   */
  node?: Node;

  /**
   * parallelism defines the minimum number of instances to bring up concurrently at any given
   * point. Note that this is an optimistic restriction and that, due to network partitioning or
   * other failures, the actual number of currently running instances might be more. This has to
   * be a positive number if assigned. Default value is size.
   *
   * @generated from field: uint32 parallelism = 2;
   */
  parallelism: number;

  /**
   * @generated from oneof flyteidl.core.ArrayNode.success_criteria
   */
  successCriteria: {
    /**
     * min_successes is an absolute number of the minimum number of successful completions of
     * sub-nodes. As soon as this criteria is met, the ArrayNode will be marked as successful
     * and outputs will be computed. This has to be a non-negative number if assigned. Default
     * value is size (if specified).
     *
     * @generated from field: uint32 min_successes = 3;
     */
    value: number;
    case: "minSuccesses";
  } | {
    /**
     * If the array job size is not known beforehand, the min_success_ratio can instead be used
     * to determine when an ArrayNode can be marked successful.
     *
     * @generated from field: float min_success_ratio = 4;
     */
    value: number;
    case: "minSuccessRatio";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ArrayNode>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.ArrayNode";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArrayNode;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArrayNode;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArrayNode;

  static equals(a: ArrayNode | PlainMessage<ArrayNode> | undefined, b: ArrayNode | PlainMessage<ArrayNode> | undefined): boolean;
}

/**
 * Defines extra information about the Node.
 *
 * @generated from message flyteidl.core.NodeMetadata
 */
export declare class NodeMetadata extends Message<NodeMetadata> {
  /**
   * A friendly name for the Node
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The overall timeout of a task.
   *
   * @generated from field: google.protobuf.Duration timeout = 4;
   */
  timeout?: Duration;

  /**
   * Number of retries per task.
   *
   * @generated from field: flyteidl.core.RetryStrategy retries = 5;
   */
  retries?: RetryStrategy;

  /**
   * Identify whether node is interruptible
   *
   * @generated from oneof flyteidl.core.NodeMetadata.interruptible_value
   */
  interruptibleValue: {
    /**
     * @generated from field: bool interruptible = 6;
     */
    value: boolean;
    case: "interruptible";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<NodeMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.NodeMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeMetadata;

  static equals(a: NodeMetadata | PlainMessage<NodeMetadata> | undefined, b: NodeMetadata | PlainMessage<NodeMetadata> | undefined): boolean;
}

/**
 * Links a variable to an alias.
 *
 * @generated from message flyteidl.core.Alias
 */
export declare class Alias extends Message<Alias> {
  /**
   * Must match one of the output variable names on a node.
   *
   * @generated from field: string var = 1;
   */
  var: string;

  /**
   * A workflow-level unique alias that downstream nodes can refer to in their input.
   *
   * @generated from field: string alias = 2;
   */
  alias: string;

  constructor(data?: PartialMessage<Alias>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Alias";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Alias;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Alias;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Alias;

  static equals(a: Alias | PlainMessage<Alias> | undefined, b: Alias | PlainMessage<Alias> | undefined): boolean;
}

/**
 * A Workflow graph Node. One unit of execution in the graph. Each node can be linked to a Task, a Workflow or a branch
 * node.
 *
 * @generated from message flyteidl.core.Node
 */
export declare class Node extends Message<Node> {
  /**
   * A workflow-level unique identifier that identifies this node in the workflow. 'inputs' and 'outputs' are reserved
   * node ids that cannot be used by other nodes.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Extra metadata about the node.
   *
   * @generated from field: flyteidl.core.NodeMetadata metadata = 2;
   */
  metadata?: NodeMetadata;

  /**
   * Specifies how to bind the underlying interface's inputs. All required inputs specified in the underlying interface
   * must be fulfilled.
   *
   * @generated from field: repeated flyteidl.core.Binding inputs = 3;
   */
  inputs: Binding[];

  /**
   * +optional Specifies execution dependency for this node ensuring it will only get scheduled to run after all its
   * upstream nodes have completed. This node will have an implicit dependency on any node that appears in inputs
   * field.
   *
   * @generated from field: repeated string upstream_node_ids = 4;
   */
  upstreamNodeIds: string[];

  /**
   * +optional. A node can define aliases for a subset of its outputs. This is particularly useful if different nodes
   * need to conform to the same interface (e.g. all branches in a branch node). Downstream nodes must refer to this
   * nodes outputs using the alias if one's specified.
   *
   * @generated from field: repeated flyteidl.core.Alias output_aliases = 5;
   */
  outputAliases: Alias[];

  /**
   * Information about the target to execute in this node.
   *
   * @generated from oneof flyteidl.core.Node.target
   */
  target: {
    /**
     * Information about the Task to execute in this node.
     *
     * @generated from field: flyteidl.core.TaskNode task_node = 6;
     */
    value: TaskNode;
    case: "taskNode";
  } | {
    /**
     * Information about the Workflow to execute in this mode.
     *
     * @generated from field: flyteidl.core.WorkflowNode workflow_node = 7;
     */
    value: WorkflowNode;
    case: "workflowNode";
  } | {
    /**
     * Information about the branch node to evaluate in this node.
     *
     * @generated from field: flyteidl.core.BranchNode branch_node = 8;
     */
    value: BranchNode;
    case: "branchNode";
  } | {
    /**
     * Information about the condition to evaluate in this node.
     *
     * @generated from field: flyteidl.core.GateNode gate_node = 9;
     */
    value: GateNode;
    case: "gateNode";
  } | {
    /**
     * Information about the sub-node executions for each value in the list of this nodes
     * inputs values.
     *
     * @generated from field: flyteidl.core.ArrayNode array_node = 10;
     */
    value: ArrayNode;
    case: "arrayNode";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Node>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.Node";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Node;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Node;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Node;

  static equals(a: Node | PlainMessage<Node> | undefined, b: Node | PlainMessage<Node> | undefined): boolean;
}

/**
 * This is workflow layer metadata. These settings are only applicable to the workflow as a whole, and do not
 * percolate down to child entities (like tasks) launched by the workflow.
 *
 * @generated from message flyteidl.core.WorkflowMetadata
 */
export declare class WorkflowMetadata extends Message<WorkflowMetadata> {
  /**
   * Indicates the runtime priority of workflow executions. 
   *
   * @generated from field: flyteidl.core.QualityOfService quality_of_service = 1;
   */
  qualityOfService?: QualityOfService;

  /**
   * Defines how the system should behave when a failure is detected in the workflow execution.
   *
   * @generated from field: flyteidl.core.WorkflowMetadata.OnFailurePolicy on_failure = 2;
   */
  onFailure: WorkflowMetadata_OnFailurePolicy;

  /**
   * Arbitrary tags that allow users and the platform to store small but arbitrary labels
   *
   * @generated from field: map<string, string> tags = 3;
   */
  tags: { [key: string]: string };

  constructor(data?: PartialMessage<WorkflowMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.WorkflowMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowMetadata;

  static equals(a: WorkflowMetadata | PlainMessage<WorkflowMetadata> | undefined, b: WorkflowMetadata | PlainMessage<WorkflowMetadata> | undefined): boolean;
}

/**
 * Failure Handling Strategy
 *
 * @generated from enum flyteidl.core.WorkflowMetadata.OnFailurePolicy
 */
export declare enum WorkflowMetadata_OnFailurePolicy {
  /**
   * FAIL_IMMEDIATELY instructs the system to fail as soon as a node fails in the workflow. It'll automatically
   * abort all currently running nodes and clean up resources before finally marking the workflow executions as
   * failed.
   *
   * @generated from enum value: FAIL_IMMEDIATELY = 0;
   */
  FAIL_IMMEDIATELY = 0,

  /**
   * FAIL_AFTER_EXECUTABLE_NODES_COMPLETE instructs the system to make as much progress as it can. The system will
   * not alter the dependencies of the execution graph so any node that depend on the failed node will not be run.
   * Other nodes that will be executed to completion before cleaning up resources and marking the workflow
   * execution as failed.
   *
   * @generated from enum value: FAIL_AFTER_EXECUTABLE_NODES_COMPLETE = 1;
   */
  FAIL_AFTER_EXECUTABLE_NODES_COMPLETE = 1,
}

/**
 * The difference between these settings and the WorkflowMetadata ones is that these are meant to be passed down to
 * a workflow's underlying entities (like tasks). For instance, 'interruptible' has no meaning at the workflow layer, it
 * is only relevant when a task executes. The settings here are the defaults that are passed to all nodes
 * unless explicitly overridden at the node layer.
 * If you are adding a setting that applies to both the Workflow itself, and everything underneath it, it should be
 * added to both this object and the WorkflowMetadata object above.
 *
 * @generated from message flyteidl.core.WorkflowMetadataDefaults
 */
export declare class WorkflowMetadataDefaults extends Message<WorkflowMetadataDefaults> {
  /**
   * Whether child nodes of the workflow are interruptible.
   *
   * @generated from field: bool interruptible = 1;
   */
  interruptible: boolean;

  constructor(data?: PartialMessage<WorkflowMetadataDefaults>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.WorkflowMetadataDefaults";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowMetadataDefaults;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowMetadataDefaults;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowMetadataDefaults;

  static equals(a: WorkflowMetadataDefaults | PlainMessage<WorkflowMetadataDefaults> | undefined, b: WorkflowMetadataDefaults | PlainMessage<WorkflowMetadataDefaults> | undefined): boolean;
}

/**
 * Flyte Workflow Structure that encapsulates task, branch and subworkflow nodes to form a statically analyzable,
 * directed acyclic graph.
 *
 * @generated from message flyteidl.core.WorkflowTemplate
 */
export declare class WorkflowTemplate extends Message<WorkflowTemplate> {
  /**
   * A globally unique identifier for the workflow.
   *
   * @generated from field: flyteidl.core.Identifier id = 1;
   */
  id?: Identifier;

  /**
   * Extra metadata about the workflow.
   *
   * @generated from field: flyteidl.core.WorkflowMetadata metadata = 2;
   */
  metadata?: WorkflowMetadata;

  /**
   * Defines a strongly typed interface for the Workflow. This can include some optional parameters.
   *
   * @generated from field: flyteidl.core.TypedInterface interface = 3;
   */
  interface?: TypedInterface;

  /**
   * A list of nodes. In addition, 'globals' is a special reserved node id that can be used to consume workflow inputs.
   *
   * @generated from field: repeated flyteidl.core.Node nodes = 4;
   */
  nodes: Node[];

  /**
   * A list of output bindings that specify how to construct workflow outputs. Bindings can pull node outputs or
   * specify literals. All workflow outputs specified in the interface field must be bound in order for the workflow
   * to be validated. A workflow has an implicit dependency on all of its nodes to execute successfully in order to
   * bind final outputs.
   * Most of these outputs will be Binding's with a BindingData of type OutputReference.  That is, your workflow can
   * just have an output of some constant (`Output(5)`), but usually, the workflow will be pulling
   * outputs from the output of a task.
   *
   * @generated from field: repeated flyteidl.core.Binding outputs = 5;
   */
  outputs: Binding[];

  /**
   * +optional A catch-all node. This node is executed whenever the execution engine determines the workflow has failed.
   * The interface of this node must match the Workflow interface with an additional input named 'error' of type
   * pb.lyft.flyte.core.Error.
   *
   * @generated from field: flyteidl.core.Node failure_node = 6;
   */
  failureNode?: Node;

  /**
   * workflow defaults
   *
   * @generated from field: flyteidl.core.WorkflowMetadataDefaults metadata_defaults = 7;
   */
  metadataDefaults?: WorkflowMetadataDefaults;

  constructor(data?: PartialMessage<WorkflowTemplate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.WorkflowTemplate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowTemplate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowTemplate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowTemplate;

  static equals(a: WorkflowTemplate | PlainMessage<WorkflowTemplate> | undefined, b: WorkflowTemplate | PlainMessage<WorkflowTemplate> | undefined): boolean;
}

/**
 * Optional task node overrides that will be applied at task execution time.
 *
 * @generated from message flyteidl.core.TaskNodeOverrides
 */
export declare class TaskNodeOverrides extends Message<TaskNodeOverrides> {
  /**
   * A customizable interface to convey resources requested for a task container. 
   *
   * @generated from field: flyteidl.core.Resources resources = 1;
   */
  resources?: Resources;

  /**
   * Overrides for all non-standard resources, not captured by
   * v1.ResourceRequirements, to allocate to a task.
   *
   * @generated from field: flyteidl.core.ExtendedResources extended_resources = 2;
   */
  extendedResources?: ExtendedResources;

  constructor(data?: PartialMessage<TaskNodeOverrides>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.core.TaskNodeOverrides";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskNodeOverrides;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskNodeOverrides;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskNodeOverrides;

  static equals(a: TaskNodeOverrides | PlainMessage<TaskNodeOverrides> | undefined, b: TaskNodeOverrides | PlainMessage<TaskNodeOverrides> | undefined): boolean;
}

