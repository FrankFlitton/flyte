// @generated by protoc-gen-es v1.4.2 with parameter "target=js+dts+ts,keep_empty_files=false"
// @generated from file flyteidl/core/workflow.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Duration, proto3 } from "@bufbuild/protobuf";
import { BooleanExpression } from "./condition_pb.js";
import { Error, LiteralType } from "./types_pb.js";
import { Identifier } from "./identifier_pb.js";
import { Binding, RetryStrategy } from "./literals_pb.js";
import { QualityOfService } from "./execution_pb.js";
import { TypedInterface } from "./interface_pb.js";
import { ExtendedResources, Resources } from "./tasks_pb.js";

/**
 * Defines a condition and the execution unit that should be executed if the condition is satisfied.
 *
 * @generated from message flyteidl.core.IfBlock
 */
export const IfBlock = proto3.makeMessageType(
  "flyteidl.core.IfBlock",
  () => [
    { no: 1, name: "condition", kind: "message", T: BooleanExpression },
    { no: 2, name: "then_node", kind: "message", T: Node },
  ],
);

/**
 * Defines a series of if/else blocks. The first branch whose condition evaluates to true is the one to execute.
 * If no conditions were satisfied, the else_node or the error will execute.
 *
 * @generated from message flyteidl.core.IfElseBlock
 */
export const IfElseBlock = proto3.makeMessageType(
  "flyteidl.core.IfElseBlock",
  () => [
    { no: 1, name: "case", kind: "message", T: IfBlock },
    { no: 2, name: "other", kind: "message", T: IfBlock, repeated: true },
    { no: 3, name: "else_node", kind: "message", T: Node, oneof: "default" },
    { no: 4, name: "error", kind: "message", T: Error, oneof: "default" },
  ],
);

/**
 * BranchNode is a special node that alter the flow of the workflow graph. It allows the control flow to branch at
 * runtime based on a series of conditions that get evaluated on various parameters (e.g. inputs, primitives).
 *
 * @generated from message flyteidl.core.BranchNode
 */
export const BranchNode = proto3.makeMessageType(
  "flyteidl.core.BranchNode",
  () => [
    { no: 1, name: "if_else", kind: "message", T: IfElseBlock },
  ],
);

/**
 * Refers to the task that the Node is to execute.
 *
 * @generated from message flyteidl.core.TaskNode
 */
export const TaskNode = proto3.makeMessageType(
  "flyteidl.core.TaskNode",
  () => [
    { no: 1, name: "reference_id", kind: "message", T: Identifier, oneof: "reference" },
    { no: 2, name: "overrides", kind: "message", T: TaskNodeOverrides },
  ],
);

/**
 * Refers to a the workflow the node is to execute.
 *
 * @generated from message flyteidl.core.WorkflowNode
 */
export const WorkflowNode = proto3.makeMessageType(
  "flyteidl.core.WorkflowNode",
  () => [
    { no: 1, name: "launchplan_ref", kind: "message", T: Identifier, oneof: "reference" },
    { no: 2, name: "sub_workflow_ref", kind: "message", T: Identifier, oneof: "reference" },
  ],
);

/**
 * ApproveCondition represents a dependency on an external approval. During execution, this will manifest as a boolean
 * signal with the provided signal_id.
 *
 * @generated from message flyteidl.core.ApproveCondition
 */
export const ApproveCondition = proto3.makeMessageType(
  "flyteidl.core.ApproveCondition",
  () => [
    { no: 1, name: "signal_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * SignalCondition represents a dependency on an signal.
 *
 * @generated from message flyteidl.core.SignalCondition
 */
export const SignalCondition = proto3.makeMessageType(
  "flyteidl.core.SignalCondition",
  () => [
    { no: 1, name: "signal_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "message", T: LiteralType },
    { no: 3, name: "output_variable_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * SleepCondition represents a dependency on waiting for the specified duration.
 *
 * @generated from message flyteidl.core.SleepCondition
 */
export const SleepCondition = proto3.makeMessageType(
  "flyteidl.core.SleepCondition",
  () => [
    { no: 1, name: "duration", kind: "message", T: Duration },
  ],
);

/**
 * GateNode refers to the condition that is required for the gate to successfully complete.
 *
 * @generated from message flyteidl.core.GateNode
 */
export const GateNode = proto3.makeMessageType(
  "flyteidl.core.GateNode",
  () => [
    { no: 1, name: "approve", kind: "message", T: ApproveCondition, oneof: "condition" },
    { no: 2, name: "signal", kind: "message", T: SignalCondition, oneof: "condition" },
    { no: 3, name: "sleep", kind: "message", T: SleepCondition, oneof: "condition" },
  ],
);

/**
 * ArrayNode is a Flyte node type that simplifies the execution of a sub-node over a list of input
 * values. An ArrayNode can be executed with configurable parallelism (separate from the parent
 * workflow) and can be configured to succeed when a certain number of sub-nodes succeed.
 *
 * @generated from message flyteidl.core.ArrayNode
 */
export const ArrayNode = proto3.makeMessageType(
  "flyteidl.core.ArrayNode",
  () => [
    { no: 1, name: "node", kind: "message", T: Node },
    { no: 2, name: "parallelism", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "min_successes", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "success_criteria" },
    { no: 4, name: "min_success_ratio", kind: "scalar", T: 2 /* ScalarType.FLOAT */, oneof: "success_criteria" },
  ],
);

/**
 * Defines extra information about the Node.
 *
 * @generated from message flyteidl.core.NodeMetadata
 */
export const NodeMetadata = proto3.makeMessageType(
  "flyteidl.core.NodeMetadata",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "timeout", kind: "message", T: Duration },
    { no: 5, name: "retries", kind: "message", T: RetryStrategy },
    { no: 6, name: "interruptible", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "interruptible_value" },
  ],
);

/**
 * Links a variable to an alias.
 *
 * @generated from message flyteidl.core.Alias
 */
export const Alias = proto3.makeMessageType(
  "flyteidl.core.Alias",
  () => [
    { no: 1, name: "var", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "alias", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * A Workflow graph Node. One unit of execution in the graph. Each node can be linked to a Task, a Workflow or a branch
 * node.
 *
 * @generated from message flyteidl.core.Node
 */
export const Node = proto3.makeMessageType(
  "flyteidl.core.Node",
  () => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: NodeMetadata },
    { no: 3, name: "inputs", kind: "message", T: Binding, repeated: true },
    { no: 4, name: "upstream_node_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "output_aliases", kind: "message", T: Alias, repeated: true },
    { no: 6, name: "task_node", kind: "message", T: TaskNode, oneof: "target" },
    { no: 7, name: "workflow_node", kind: "message", T: WorkflowNode, oneof: "target" },
    { no: 8, name: "branch_node", kind: "message", T: BranchNode, oneof: "target" },
    { no: 9, name: "gate_node", kind: "message", T: GateNode, oneof: "target" },
    { no: 10, name: "array_node", kind: "message", T: ArrayNode, oneof: "target" },
  ],
);

/**
 * This is workflow layer metadata. These settings are only applicable to the workflow as a whole, and do not
 * percolate down to child entities (like tasks) launched by the workflow.
 *
 * @generated from message flyteidl.core.WorkflowMetadata
 */
export const WorkflowMetadata = proto3.makeMessageType(
  "flyteidl.core.WorkflowMetadata",
  () => [
    { no: 1, name: "quality_of_service", kind: "message", T: QualityOfService },
    { no: 2, name: "on_failure", kind: "enum", T: proto3.getEnumType(WorkflowMetadata_OnFailurePolicy) },
    { no: 3, name: "tags", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ],
);

/**
 * Failure Handling Strategy
 *
 * @generated from enum flyteidl.core.WorkflowMetadata.OnFailurePolicy
 */
export const WorkflowMetadata_OnFailurePolicy = proto3.makeEnum(
  "flyteidl.core.WorkflowMetadata.OnFailurePolicy",
  [
    {no: 0, name: "FAIL_IMMEDIATELY"},
    {no: 1, name: "FAIL_AFTER_EXECUTABLE_NODES_COMPLETE"},
  ],
);

/**
 * The difference between these settings and the WorkflowMetadata ones is that these are meant to be passed down to
 * a workflow's underlying entities (like tasks). For instance, 'interruptible' has no meaning at the workflow layer, it
 * is only relevant when a task executes. The settings here are the defaults that are passed to all nodes
 * unless explicitly overridden at the node layer.
 * If you are adding a setting that applies to both the Workflow itself, and everything underneath it, it should be
 * added to both this object and the WorkflowMetadata object above.
 *
 * @generated from message flyteidl.core.WorkflowMetadataDefaults
 */
export const WorkflowMetadataDefaults = proto3.makeMessageType(
  "flyteidl.core.WorkflowMetadataDefaults",
  () => [
    { no: 1, name: "interruptible", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * Flyte Workflow Structure that encapsulates task, branch and subworkflow nodes to form a statically analyzable,
 * directed acyclic graph.
 *
 * @generated from message flyteidl.core.WorkflowTemplate
 */
export const WorkflowTemplate = proto3.makeMessageType(
  "flyteidl.core.WorkflowTemplate",
  () => [
    { no: 1, name: "id", kind: "message", T: Identifier },
    { no: 2, name: "metadata", kind: "message", T: WorkflowMetadata },
    { no: 3, name: "interface", kind: "message", T: TypedInterface },
    { no: 4, name: "nodes", kind: "message", T: Node, repeated: true },
    { no: 5, name: "outputs", kind: "message", T: Binding, repeated: true },
    { no: 6, name: "failure_node", kind: "message", T: Node },
    { no: 7, name: "metadata_defaults", kind: "message", T: WorkflowMetadataDefaults },
  ],
);

/**
 * Optional task node overrides that will be applied at task execution time.
 *
 * @generated from message flyteidl.core.TaskNodeOverrides
 */
export const TaskNodeOverrides = proto3.makeMessageType(
  "flyteidl.core.TaskNodeOverrides",
  () => [
    { no: 1, name: "resources", kind: "message", T: Resources },
    { no: 2, name: "extended_resources", kind: "message", T: ExtendedResources },
  ],
);

