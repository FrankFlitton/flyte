// @generated by protoc-gen-es v1.4.2 with parameter "target=js+dts+ts,keep_empty_files=false"
// @generated from file flyteidl/admin/signal.proto (package flyteidl.admin, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { SignalIdentifier, WorkflowExecutionIdentifier } from "../core/identifier_pb.js";
import type { LiteralType } from "../core/types_pb.js";
import type { Sort } from "./common_pb.js";
import type { Literal } from "../core/literals_pb.js";

/**
 * SignalGetOrCreateRequest represents a request structure to retrieve or create a signal.
 * See :ref:`ref_flyteidl.admin.Signal` for more details
 *
 * @generated from message flyteidl.admin.SignalGetOrCreateRequest
 */
export declare class SignalGetOrCreateRequest extends Message<SignalGetOrCreateRequest> {
  /**
   * A unique identifier for the requested signal.
   *
   * @generated from field: flyteidl.core.SignalIdentifier id = 1;
   */
  id?: SignalIdentifier;

  /**
   * A type denoting the required value type for this signal.
   *
   * @generated from field: flyteidl.core.LiteralType type = 2;
   */
  type?: LiteralType;

  constructor(data?: PartialMessage<SignalGetOrCreateRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.SignalGetOrCreateRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalGetOrCreateRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalGetOrCreateRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalGetOrCreateRequest;

  static equals(a: SignalGetOrCreateRequest | PlainMessage<SignalGetOrCreateRequest> | undefined, b: SignalGetOrCreateRequest | PlainMessage<SignalGetOrCreateRequest> | undefined): boolean;
}

/**
 * SignalListRequest represents a request structure to retrieve a collection of signals.
 * See :ref:`ref_flyteidl.admin.Signal` for more details
 *
 * @generated from message flyteidl.admin.SignalListRequest
 */
export declare class SignalListRequest extends Message<SignalListRequest> {
  /**
   * Indicates the workflow execution to filter by.
   * +required
   *
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier workflow_execution_id = 1;
   */
  workflowExecutionId?: WorkflowExecutionIdentifier;

  /**
   * Indicates the number of resources to be returned.
   * +required
   *
   * @generated from field: uint32 limit = 2;
   */
  limit: number;

  /**
   * In the case of multiple pages of results, the, server-provided token can be used to fetch the next page
   * in a query.
   * +optional
   *
   * @generated from field: string token = 3;
   */
  token: string;

  /**
   * Indicates a list of filters passed as string.
   * +optional
   *
   * @generated from field: string filters = 4;
   */
  filters: string;

  /**
   * Sort ordering.
   * +optional
   *
   * @generated from field: flyteidl.admin.Sort sort_by = 5;
   */
  sortBy?: Sort;

  constructor(data?: PartialMessage<SignalListRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.SignalListRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalListRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalListRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalListRequest;

  static equals(a: SignalListRequest | PlainMessage<SignalListRequest> | undefined, b: SignalListRequest | PlainMessage<SignalListRequest> | undefined): boolean;
}

/**
 * SignalList represents collection of signals along with the token of the last result.
 * See :ref:`ref_flyteidl.admin.Signal` for more details
 *
 * @generated from message flyteidl.admin.SignalList
 */
export declare class SignalList extends Message<SignalList> {
  /**
   * A list of signals matching the input filters.
   *
   * @generated from field: repeated flyteidl.admin.Signal signals = 1;
   */
  signals: Signal[];

  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page
   * in a query. If there are no more results, this value will be empty.
   *
   * @generated from field: string token = 2;
   */
  token: string;

  constructor(data?: PartialMessage<SignalList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.SignalList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalList;

  static equals(a: SignalList | PlainMessage<SignalList> | undefined, b: SignalList | PlainMessage<SignalList> | undefined): boolean;
}

/**
 * SignalSetRequest represents a request structure to set the value on a signal. Setting a signal
 * effetively satisfies the signal condition within a Flyte workflow.
 * See :ref:`ref_flyteidl.admin.Signal` for more details
 *
 * @generated from message flyteidl.admin.SignalSetRequest
 */
export declare class SignalSetRequest extends Message<SignalSetRequest> {
  /**
   * A unique identifier for the requested signal.
   *
   * @generated from field: flyteidl.core.SignalIdentifier id = 1;
   */
  id?: SignalIdentifier;

  /**
   * The value of this signal, must match the defining signal type.
   *
   * @generated from field: flyteidl.core.Literal value = 2;
   */
  value?: Literal;

  constructor(data?: PartialMessage<SignalSetRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.SignalSetRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalSetRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalSetRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalSetRequest;

  static equals(a: SignalSetRequest | PlainMessage<SignalSetRequest> | undefined, b: SignalSetRequest | PlainMessage<SignalSetRequest> | undefined): boolean;
}

/**
 * SignalSetResponse represents a response structure if signal setting succeeds.
 *
 * Purposefully empty, may be populated in the future.
 *
 * @generated from message flyteidl.admin.SignalSetResponse
 */
export declare class SignalSetResponse extends Message<SignalSetResponse> {
  constructor(data?: PartialMessage<SignalSetResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.SignalSetResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalSetResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalSetResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalSetResponse;

  static equals(a: SignalSetResponse | PlainMessage<SignalSetResponse> | undefined, b: SignalSetResponse | PlainMessage<SignalSetResponse> | undefined): boolean;
}

/**
 * Signal encapsulates a unique identifier, associated metadata, and a value for a single Flyte
 * signal. Signals may exist either without a set value (representing a signal request) or with a
 * populated value (indicating the signal has been given).
 *
 * @generated from message flyteidl.admin.Signal
 */
export declare class Signal extends Message<Signal> {
  /**
   * A unique identifier for the requested signal.
   *
   * @generated from field: flyteidl.core.SignalIdentifier id = 1;
   */
  id?: SignalIdentifier;

  /**
   * A type denoting the required value type for this signal.
   *
   * @generated from field: flyteidl.core.LiteralType type = 2;
   */
  type?: LiteralType;

  /**
   * The value of the signal. This is only available if the signal has been "set" and must match
   * the defined the type.
   *
   * @generated from field: flyteidl.core.Literal value = 3;
   */
  value?: Literal;

  constructor(data?: PartialMessage<Signal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.Signal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Signal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Signal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Signal;

  static equals(a: Signal | PlainMessage<Signal> | undefined, b: Signal | PlainMessage<Signal> | undefined): boolean;
}

