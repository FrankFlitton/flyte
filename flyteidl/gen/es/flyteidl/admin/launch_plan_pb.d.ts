// @generated by protoc-gen-es v1.4.2 with parameter "target=js+dts+ts,keep_empty_files=false"
// @generated from file flyteidl/admin/launch_plan.proto (package flyteidl.admin, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Identifier } from "../core/identifier_pb.js";
import type { ParameterMap, VariableMap } from "../core/interface_pb.js";
import type { LiteralMap } from "../core/literals_pb.js";
import type { Annotations, AuthRole, Envs, Labels, NamedEntityIdentifier, Notification, RawOutputDataConfig, Sort } from "./common_pb.js";
import type { SecurityContext } from "../core/security_pb.js";
import type { QualityOfService } from "../core/execution_pb.js";
import type { Schedule } from "./schedule_pb.js";

/**
 * By default any launch plan regardless of state can be used to launch a workflow execution.
 * However, at most one version of a launch plan
 * (e.g. a NamedEntityIdentifier set of shared project, domain and name values) can be
 * active at a time in regards to *schedules*. That is, at most one schedule in a NamedEntityIdentifier
 * group will be observed and trigger executions at a defined cadence.
 *
 * @generated from enum flyteidl.admin.LaunchPlanState
 */
export declare enum LaunchPlanState {
  /**
   * @generated from enum value: INACTIVE = 0;
   */
  INACTIVE = 0,

  /**
   * @generated from enum value: ACTIVE = 1;
   */
  ACTIVE = 1,
}

/**
 * Request to register a launch plan. The included LaunchPlanSpec may have a complete or incomplete set of inputs required
 * to launch a workflow execution. By default all launch plans are registered in state INACTIVE. If you wish to
 * set the state to ACTIVE, you must submit a LaunchPlanUpdateRequest, after you have successfully created a launch plan.
 *
 * @generated from message flyteidl.admin.LaunchPlanCreateRequest
 */
export declare class LaunchPlanCreateRequest extends Message<LaunchPlanCreateRequest> {
  /**
   * Uniquely identifies a launch plan entity.
   *
   * @generated from field: flyteidl.core.Identifier id = 1;
   */
  id?: Identifier;

  /**
   * User-provided launch plan details, including reference workflow, inputs and other metadata.
   *
   * @generated from field: flyteidl.admin.LaunchPlanSpec spec = 2;
   */
  spec?: LaunchPlanSpec;

  constructor(data?: PartialMessage<LaunchPlanCreateRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.LaunchPlanCreateRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LaunchPlanCreateRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LaunchPlanCreateRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LaunchPlanCreateRequest;

  static equals(a: LaunchPlanCreateRequest | PlainMessage<LaunchPlanCreateRequest> | undefined, b: LaunchPlanCreateRequest | PlainMessage<LaunchPlanCreateRequest> | undefined): boolean;
}

/**
 * Purposefully empty, may be populated in the future.
 *
 * @generated from message flyteidl.admin.LaunchPlanCreateResponse
 */
export declare class LaunchPlanCreateResponse extends Message<LaunchPlanCreateResponse> {
  constructor(data?: PartialMessage<LaunchPlanCreateResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.LaunchPlanCreateResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LaunchPlanCreateResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LaunchPlanCreateResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LaunchPlanCreateResponse;

  static equals(a: LaunchPlanCreateResponse | PlainMessage<LaunchPlanCreateResponse> | undefined, b: LaunchPlanCreateResponse | PlainMessage<LaunchPlanCreateResponse> | undefined): boolean;
}

/**
 * A LaunchPlan provides the capability to templatize workflow executions.
 * Launch plans simplify associating one or more schedules, inputs and notifications with your workflows.
 * Launch plans can be shared and used to trigger executions with predefined inputs even when a workflow
 * definition doesn't necessarily have a default value for said input.
 *
 * @generated from message flyteidl.admin.LaunchPlan
 */
export declare class LaunchPlan extends Message<LaunchPlan> {
  /**
   * Uniquely identifies a launch plan entity.
   *
   * @generated from field: flyteidl.core.Identifier id = 1;
   */
  id?: Identifier;

  /**
   * User-provided launch plan details, including reference workflow, inputs and other metadata.
   *
   * @generated from field: flyteidl.admin.LaunchPlanSpec spec = 2;
   */
  spec?: LaunchPlanSpec;

  /**
   * Values computed by the flyte platform after launch plan registration.
   *
   * @generated from field: flyteidl.admin.LaunchPlanClosure closure = 3;
   */
  closure?: LaunchPlanClosure;

  constructor(data?: PartialMessage<LaunchPlan>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.LaunchPlan";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LaunchPlan;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LaunchPlan;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LaunchPlan;

  static equals(a: LaunchPlan | PlainMessage<LaunchPlan> | undefined, b: LaunchPlan | PlainMessage<LaunchPlan> | undefined): boolean;
}

/**
 * Response object for list launch plan requests.
 * See :ref:`ref_flyteidl.admin.LaunchPlan` for more details
 *
 * @generated from message flyteidl.admin.LaunchPlanList
 */
export declare class LaunchPlanList extends Message<LaunchPlanList> {
  /**
   * @generated from field: repeated flyteidl.admin.LaunchPlan launch_plans = 1;
   */
  launchPlans: LaunchPlan[];

  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page
   * in a query. If there are no more results, this value will be empty.
   *
   * @generated from field: string token = 2;
   */
  token: string;

  constructor(data?: PartialMessage<LaunchPlanList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.LaunchPlanList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LaunchPlanList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LaunchPlanList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LaunchPlanList;

  static equals(a: LaunchPlanList | PlainMessage<LaunchPlanList> | undefined, b: LaunchPlanList | PlainMessage<LaunchPlanList> | undefined): boolean;
}

/**
 * Defines permissions associated with executions created by this launch plan spec.
 * Use either of these roles when they have permissions required by your workflow execution.
 * Deprecated.
 *
 * @generated from message flyteidl.admin.Auth
 * @deprecated
 */
export declare class Auth extends Message<Auth> {
  /**
   * Defines an optional iam role which will be used for tasks run in executions created with this launch plan.
   *
   * @generated from field: string assumable_iam_role = 1;
   */
  assumableIamRole: string;

  /**
   * Defines an optional kubernetes service account which will be used for tasks run in executions created with this launch plan.
   *
   * @generated from field: string kubernetes_service_account = 2;
   */
  kubernetesServiceAccount: string;

  constructor(data?: PartialMessage<Auth>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.Auth";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Auth;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Auth;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Auth;

  static equals(a: Auth | PlainMessage<Auth> | undefined, b: Auth | PlainMessage<Auth> | undefined): boolean;
}

/**
 * User-provided launch plan definition and configuration values.
 *
 * @generated from message flyteidl.admin.LaunchPlanSpec
 */
export declare class LaunchPlanSpec extends Message<LaunchPlanSpec> {
  /**
   * Reference to the Workflow template that the launch plan references
   *
   * @generated from field: flyteidl.core.Identifier workflow_id = 1;
   */
  workflowId?: Identifier;

  /**
   * Metadata for the Launch Plan
   *
   * @generated from field: flyteidl.admin.LaunchPlanMetadata entity_metadata = 2;
   */
  entityMetadata?: LaunchPlanMetadata;

  /**
   * Input values to be passed for the execution.
   * These can be overridden when an execution is created with this launch plan.
   *
   * @generated from field: flyteidl.core.ParameterMap default_inputs = 3;
   */
  defaultInputs?: ParameterMap;

  /**
   * Fixed, non-overridable inputs for the Launch Plan.
   * These can not be overridden when an execution is created with this launch plan.
   *
   * @generated from field: flyteidl.core.LiteralMap fixed_inputs = 4;
   */
  fixedInputs?: LiteralMap;

  /**
   * String to indicate the role to use to execute the workflow underneath
   *
   * @generated from field: string role = 5 [deprecated = true];
   * @deprecated
   */
  role: string;

  /**
   * Custom labels to be applied to the execution resource.
   *
   * @generated from field: flyteidl.admin.Labels labels = 6;
   */
  labels?: Labels;

  /**
   * Custom annotations to be applied to the execution resource.
   *
   * @generated from field: flyteidl.admin.Annotations annotations = 7;
   */
  annotations?: Annotations;

  /**
   * Indicates the permission associated with workflow executions triggered with this launch plan.
   *
   * @generated from field: flyteidl.admin.Auth auth = 8 [deprecated = true];
   * @deprecated
   */
  auth?: Auth;

  /**
   * @generated from field: flyteidl.admin.AuthRole auth_role = 9 [deprecated = true];
   * @deprecated
   */
  authRole?: AuthRole;

  /**
   * Indicates security context for permissions triggered with this launch plan
   *
   * @generated from field: flyteidl.core.SecurityContext security_context = 10;
   */
  securityContext?: SecurityContext;

  /**
   * Indicates the runtime priority of the execution.
   *
   * @generated from field: flyteidl.core.QualityOfService quality_of_service = 16;
   */
  qualityOfService?: QualityOfService;

  /**
   * Encapsulates user settings pertaining to offloaded data (i.e. Blobs, Schema, query data, etc.).
   *
   * @generated from field: flyteidl.admin.RawOutputDataConfig raw_output_data_config = 17;
   */
  rawOutputDataConfig?: RawOutputDataConfig;

  /**
   * Controls the maximum number of tasknodes that can be run in parallel for the entire workflow.
   * This is useful to achieve fairness. Note: MapTasks are regarded as one unit,
   * and parallelism/concurrency of MapTasks is independent from this.
   *
   * @generated from field: int32 max_parallelism = 18;
   */
  maxParallelism: number;

  /**
   * Allows for the interruptible flag of a workflow to be overwritten for a single execution.
   * Omitting this field uses the workflow's value as a default.
   * As we need to distinguish between the field not being provided and its default value false, we have to use a wrapper
   * around the bool field.
   *
   * @generated from field: google.protobuf.BoolValue interruptible = 19;
   */
  interruptible?: boolean;

  /**
   * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution.
   * If enabled, all calculations are performed even if cached results would be available, overwriting the stored
   * data once execution finishes successfully.
   *
   * @generated from field: bool overwrite_cache = 20;
   */
  overwriteCache: boolean;

  /**
   * Environment variables to be set for the execution.
   *
   * @generated from field: flyteidl.admin.Envs envs = 21;
   */
  envs?: Envs;

  constructor(data?: PartialMessage<LaunchPlanSpec>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.LaunchPlanSpec";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LaunchPlanSpec;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LaunchPlanSpec;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LaunchPlanSpec;

  static equals(a: LaunchPlanSpec | PlainMessage<LaunchPlanSpec> | undefined, b: LaunchPlanSpec | PlainMessage<LaunchPlanSpec> | undefined): boolean;
}

/**
 * Values computed by the flyte platform after launch plan registration.
 * These include expected_inputs required to be present in a CreateExecutionRequest
 * to launch the reference workflow as well timestamp values associated with the launch plan.
 *
 * @generated from message flyteidl.admin.LaunchPlanClosure
 */
export declare class LaunchPlanClosure extends Message<LaunchPlanClosure> {
  /**
   * Indicate the Launch plan state. 
   *
   * @generated from field: flyteidl.admin.LaunchPlanState state = 1;
   */
  state: LaunchPlanState;

  /**
   * Indicates the set of inputs expected when creating an execution with the Launch plan
   *
   * @generated from field: flyteidl.core.ParameterMap expected_inputs = 2;
   */
  expectedInputs?: ParameterMap;

  /**
   * Indicates the set of outputs expected to be produced by creating an execution with the Launch plan
   *
   * @generated from field: flyteidl.core.VariableMap expected_outputs = 3;
   */
  expectedOutputs?: VariableMap;

  /**
   * Time at which the launch plan was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 4;
   */
  createdAt?: Timestamp;

  /**
   * Time at which the launch plan was last updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 5;
   */
  updatedAt?: Timestamp;

  constructor(data?: PartialMessage<LaunchPlanClosure>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.LaunchPlanClosure";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LaunchPlanClosure;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LaunchPlanClosure;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LaunchPlanClosure;

  static equals(a: LaunchPlanClosure | PlainMessage<LaunchPlanClosure> | undefined, b: LaunchPlanClosure | PlainMessage<LaunchPlanClosure> | undefined): boolean;
}

/**
 * Additional launch plan attributes included in the LaunchPlanSpec not strictly required to launch
 * the reference workflow.
 *
 * @generated from message flyteidl.admin.LaunchPlanMetadata
 */
export declare class LaunchPlanMetadata extends Message<LaunchPlanMetadata> {
  /**
   * Schedule to execute the Launch Plan
   *
   * @generated from field: flyteidl.admin.Schedule schedule = 1;
   */
  schedule?: Schedule;

  /**
   * List of notifications based on Execution status transitions
   *
   * @generated from field: repeated flyteidl.admin.Notification notifications = 2;
   */
  notifications: Notification[];

  constructor(data?: PartialMessage<LaunchPlanMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.LaunchPlanMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LaunchPlanMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LaunchPlanMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LaunchPlanMetadata;

  static equals(a: LaunchPlanMetadata | PlainMessage<LaunchPlanMetadata> | undefined, b: LaunchPlanMetadata | PlainMessage<LaunchPlanMetadata> | undefined): boolean;
}

/**
 * Request to set the referenced launch plan state to the configured value.
 * See :ref:`ref_flyteidl.admin.LaunchPlan` for more details
 *
 * @generated from message flyteidl.admin.LaunchPlanUpdateRequest
 */
export declare class LaunchPlanUpdateRequest extends Message<LaunchPlanUpdateRequest> {
  /**
   * Identifier of launch plan for which to change state.
   * +required.
   *
   * @generated from field: flyteidl.core.Identifier id = 1;
   */
  id?: Identifier;

  /**
   * Desired state to apply to the launch plan.
   * +required.
   *
   * @generated from field: flyteidl.admin.LaunchPlanState state = 2;
   */
  state: LaunchPlanState;

  constructor(data?: PartialMessage<LaunchPlanUpdateRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.LaunchPlanUpdateRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LaunchPlanUpdateRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LaunchPlanUpdateRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LaunchPlanUpdateRequest;

  static equals(a: LaunchPlanUpdateRequest | PlainMessage<LaunchPlanUpdateRequest> | undefined, b: LaunchPlanUpdateRequest | PlainMessage<LaunchPlanUpdateRequest> | undefined): boolean;
}

/**
 * Purposefully empty, may be populated in the future.
 *
 * @generated from message flyteidl.admin.LaunchPlanUpdateResponse
 */
export declare class LaunchPlanUpdateResponse extends Message<LaunchPlanUpdateResponse> {
  constructor(data?: PartialMessage<LaunchPlanUpdateResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.LaunchPlanUpdateResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LaunchPlanUpdateResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LaunchPlanUpdateResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LaunchPlanUpdateResponse;

  static equals(a: LaunchPlanUpdateResponse | PlainMessage<LaunchPlanUpdateResponse> | undefined, b: LaunchPlanUpdateResponse | PlainMessage<LaunchPlanUpdateResponse> | undefined): boolean;
}

/**
 * Represents a request struct for finding an active launch plan for a given NamedEntityIdentifier
 * See :ref:`ref_flyteidl.admin.LaunchPlan` for more details
 *
 * @generated from message flyteidl.admin.ActiveLaunchPlanRequest
 */
export declare class ActiveLaunchPlanRequest extends Message<ActiveLaunchPlanRequest> {
  /**
   * +required.
   *
   * @generated from field: flyteidl.admin.NamedEntityIdentifier id = 1;
   */
  id?: NamedEntityIdentifier;

  constructor(data?: PartialMessage<ActiveLaunchPlanRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ActiveLaunchPlanRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActiveLaunchPlanRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActiveLaunchPlanRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActiveLaunchPlanRequest;

  static equals(a: ActiveLaunchPlanRequest | PlainMessage<ActiveLaunchPlanRequest> | undefined, b: ActiveLaunchPlanRequest | PlainMessage<ActiveLaunchPlanRequest> | undefined): boolean;
}

/**
 * Represents a request structure to list active launch plans within a project/domain.
 * See :ref:`ref_flyteidl.admin.LaunchPlan` for more details
 *
 * @generated from message flyteidl.admin.ActiveLaunchPlanListRequest
 */
export declare class ActiveLaunchPlanListRequest extends Message<ActiveLaunchPlanListRequest> {
  /**
   * Name of the project that contains the identifiers.
   * +required.
   *
   * @generated from field: string project = 1;
   */
  project: string;

  /**
   * Name of the domain the identifiers belongs to within the project.
   * +required.
   *
   * @generated from field: string domain = 2;
   */
  domain: string;

  /**
   * Indicates the number of resources to be returned.
   * +required.
   *
   * @generated from field: uint32 limit = 3;
   */
  limit: number;

  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page
   * in a query.
   * +optional
   *
   * @generated from field: string token = 4;
   */
  token: string;

  /**
   * Sort ordering.
   * +optional
   *
   * @generated from field: flyteidl.admin.Sort sort_by = 5;
   */
  sortBy?: Sort;

  constructor(data?: PartialMessage<ActiveLaunchPlanListRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ActiveLaunchPlanListRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActiveLaunchPlanListRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActiveLaunchPlanListRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActiveLaunchPlanListRequest;

  static equals(a: ActiveLaunchPlanListRequest | PlainMessage<ActiveLaunchPlanListRequest> | undefined, b: ActiveLaunchPlanListRequest | PlainMessage<ActiveLaunchPlanListRequest> | undefined): boolean;
}

