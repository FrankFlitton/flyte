// @generated by protoc-gen-es v1.4.2 with parameter "target=js+dts+ts,keep_empty_files=false"
// @generated from file flyteidl/admin/execution.proto (package flyteidl.admin, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { LiteralMap } from "../core/literals_pb.js";
import type { Identifier, NodeExecutionIdentifier, WorkflowExecutionIdentifier } from "../core/identifier_pb.js";
import type { ExecutionError, QualityOfService, WorkflowExecution_Phase } from "../core/execution_pb.js";
import type { Annotations, AuthRole, Envs, Labels, Notification, RawOutputDataConfig, UrlBlob } from "./common_pb.js";
import type { SecurityContext } from "../core/security_pb.js";
import type { ClusterAssignment } from "./cluster_assignment_pb.js";
import type { Span } from "../core/metrics_pb.js";

/**
 * The state of the execution is used to control its visibility in the UI/CLI.
 *
 * @generated from enum flyteidl.admin.ExecutionState
 */
export declare enum ExecutionState {
  /**
   * By default, all executions are considered active.
   *
   * @generated from enum value: EXECUTION_ACTIVE = 0;
   */
  EXECUTION_ACTIVE = 0,

  /**
   * Archived executions are no longer visible in the UI.
   *
   * @generated from enum value: EXECUTION_ARCHIVED = 1;
   */
  EXECUTION_ARCHIVED = 1,
}

/**
 * Request to launch an execution with the given project, domain and optionally-assigned name.
 *
 * @generated from message flyteidl.admin.ExecutionCreateRequest
 */
export declare class ExecutionCreateRequest extends Message<ExecutionCreateRequest> {
  /**
   * Name of the project the execution belongs to.
   * +required
   *
   * @generated from field: string project = 1;
   */
  project: string;

  /**
   * Name of the domain the execution belongs to.
   * A domain can be considered as a subset within a specific project.
   * +required
   *
   * @generated from field: string domain = 2;
   */
  domain: string;

  /**
   * User provided value for the resource.
   * If none is provided the system will generate a unique string.
   * +optional
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * Additional fields necessary to launch the execution.
   * +optional
   *
   * @generated from field: flyteidl.admin.ExecutionSpec spec = 4;
   */
  spec?: ExecutionSpec;

  /**
   * The inputs required to start the execution. All required inputs must be
   * included in this map. If not required and not provided, defaults apply.
   * +optional
   *
   * @generated from field: flyteidl.core.LiteralMap inputs = 5;
   */
  inputs?: LiteralMap;

  constructor(data?: PartialMessage<ExecutionCreateRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionCreateRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionCreateRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionCreateRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionCreateRequest;

  static equals(a: ExecutionCreateRequest | PlainMessage<ExecutionCreateRequest> | undefined, b: ExecutionCreateRequest | PlainMessage<ExecutionCreateRequest> | undefined): boolean;
}

/**
 * Request to relaunch the referenced execution.
 *
 * @generated from message flyteidl.admin.ExecutionRelaunchRequest
 */
export declare class ExecutionRelaunchRequest extends Message<ExecutionRelaunchRequest> {
  /**
   * Identifier of the workflow execution to relaunch.
   * +required
   *
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier id = 1;
   */
  id?: WorkflowExecutionIdentifier;

  /**
   * User provided value for the relaunched execution.
   * If none is provided the system will generate a unique string.
   * +optional
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution.
   * If enabled, all calculations are performed even if cached results would be available, overwriting the stored
   * data once execution finishes successfully.
   *
   * @generated from field: bool overwrite_cache = 4;
   */
  overwriteCache: boolean;

  constructor(data?: PartialMessage<ExecutionRelaunchRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionRelaunchRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionRelaunchRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionRelaunchRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionRelaunchRequest;

  static equals(a: ExecutionRelaunchRequest | PlainMessage<ExecutionRelaunchRequest> | undefined, b: ExecutionRelaunchRequest | PlainMessage<ExecutionRelaunchRequest> | undefined): boolean;
}

/**
 * Request to recover the referenced execution.
 *
 * @generated from message flyteidl.admin.ExecutionRecoverRequest
 */
export declare class ExecutionRecoverRequest extends Message<ExecutionRecoverRequest> {
  /**
   * Identifier of the workflow execution to recover.
   *
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier id = 1;
   */
  id?: WorkflowExecutionIdentifier;

  /**
   * User provided value for the recovered execution.
   * If none is provided the system will generate a unique string.
   * +optional
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Additional metadata which will be used to overwrite any metadata in the reference execution when triggering a recovery execution.
   *
   * @generated from field: flyteidl.admin.ExecutionMetadata metadata = 3;
   */
  metadata?: ExecutionMetadata;

  constructor(data?: PartialMessage<ExecutionRecoverRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionRecoverRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionRecoverRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionRecoverRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionRecoverRequest;

  static equals(a: ExecutionRecoverRequest | PlainMessage<ExecutionRecoverRequest> | undefined, b: ExecutionRecoverRequest | PlainMessage<ExecutionRecoverRequest> | undefined): boolean;
}

/**
 * The unique identifier for a successfully created execution.
 * If the name was *not* specified in the create request, this identifier will include a generated name.
 *
 * @generated from message flyteidl.admin.ExecutionCreateResponse
 */
export declare class ExecutionCreateResponse extends Message<ExecutionCreateResponse> {
  /**
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier id = 1;
   */
  id?: WorkflowExecutionIdentifier;

  constructor(data?: PartialMessage<ExecutionCreateResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionCreateResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionCreateResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionCreateResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionCreateResponse;

  static equals(a: ExecutionCreateResponse | PlainMessage<ExecutionCreateResponse> | undefined, b: ExecutionCreateResponse | PlainMessage<ExecutionCreateResponse> | undefined): boolean;
}

/**
 * A message used to fetch a single workflow execution entity.
 * See :ref:`ref_flyteidl.admin.Execution` for more details
 *
 * @generated from message flyteidl.admin.WorkflowExecutionGetRequest
 */
export declare class WorkflowExecutionGetRequest extends Message<WorkflowExecutionGetRequest> {
  /**
   * Uniquely identifies an individual workflow execution.
   *
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier id = 1;
   */
  id?: WorkflowExecutionIdentifier;

  constructor(data?: PartialMessage<WorkflowExecutionGetRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.WorkflowExecutionGetRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionGetRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionGetRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecutionGetRequest;

  static equals(a: WorkflowExecutionGetRequest | PlainMessage<WorkflowExecutionGetRequest> | undefined, b: WorkflowExecutionGetRequest | PlainMessage<WorkflowExecutionGetRequest> | undefined): boolean;
}

/**
 * A workflow execution represents an instantiated workflow, including all inputs and additional
 * metadata as well as computed results included state, outputs, and duration-based attributes.
 * Used as a response object used in Get and List execution requests.
 *
 * @generated from message flyteidl.admin.Execution
 */
export declare class Execution extends Message<Execution> {
  /**
   * Unique identifier of the workflow execution.
   *
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier id = 1;
   */
  id?: WorkflowExecutionIdentifier;

  /**
   * User-provided configuration and inputs for launching the execution.
   *
   * @generated from field: flyteidl.admin.ExecutionSpec spec = 2;
   */
  spec?: ExecutionSpec;

  /**
   * Execution results.
   *
   * @generated from field: flyteidl.admin.ExecutionClosure closure = 3;
   */
  closure?: ExecutionClosure;

  constructor(data?: PartialMessage<Execution>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.Execution";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Execution;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Execution;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Execution;

  static equals(a: Execution | PlainMessage<Execution> | undefined, b: Execution | PlainMessage<Execution> | undefined): boolean;
}

/**
 * Used as a response for request to list executions.
 * See :ref:`ref_flyteidl.admin.Execution` for more details
 *
 * @generated from message flyteidl.admin.ExecutionList
 */
export declare class ExecutionList extends Message<ExecutionList> {
  /**
   * @generated from field: repeated flyteidl.admin.Execution executions = 1;
   */
  executions: Execution[];

  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page
   * in a query. If there are no more results, this value will be empty.
   *
   * @generated from field: string token = 2;
   */
  token: string;

  constructor(data?: PartialMessage<ExecutionList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionList;

  static equals(a: ExecutionList | PlainMessage<ExecutionList> | undefined, b: ExecutionList | PlainMessage<ExecutionList> | undefined): boolean;
}

/**
 * Input/output data can represented by actual values or a link to where values are stored
 *
 * @generated from message flyteidl.admin.LiteralMapBlob
 */
export declare class LiteralMapBlob extends Message<LiteralMapBlob> {
  /**
   * @generated from oneof flyteidl.admin.LiteralMapBlob.data
   */
  data: {
    /**
     * Data in LiteralMap format
     *
     * @generated from field: flyteidl.core.LiteralMap values = 1 [deprecated = true];
     * @deprecated
     */
    value: LiteralMap;
    case: "values";
  } | {
    /**
     * In the event that the map is too large, we return a uri to the data
     *
     * @generated from field: string uri = 2;
     */
    value: string;
    case: "uri";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<LiteralMapBlob>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.LiteralMapBlob";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LiteralMapBlob;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LiteralMapBlob;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LiteralMapBlob;

  static equals(a: LiteralMapBlob | PlainMessage<LiteralMapBlob> | undefined, b: LiteralMapBlob | PlainMessage<LiteralMapBlob> | undefined): boolean;
}

/**
 * Specifies metadata around an aborted workflow execution.
 *
 * @generated from message flyteidl.admin.AbortMetadata
 */
export declare class AbortMetadata extends Message<AbortMetadata> {
  /**
   * In the case of a user-specified abort, this will pass along the user-supplied cause.
   *
   * @generated from field: string cause = 1;
   */
  cause: string;

  /**
   * Identifies the entity (if any) responsible for terminating the execution
   *
   * @generated from field: string principal = 2;
   */
  principal: string;

  constructor(data?: PartialMessage<AbortMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.AbortMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AbortMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AbortMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AbortMetadata;

  static equals(a: AbortMetadata | PlainMessage<AbortMetadata> | undefined, b: AbortMetadata | PlainMessage<AbortMetadata> | undefined): boolean;
}

/**
 * Encapsulates the results of the Execution
 *
 * @generated from message flyteidl.admin.ExecutionClosure
 */
export declare class ExecutionClosure extends Message<ExecutionClosure> {
  /**
   * A result produced by a terminated execution.
   * A pending (non-terminal) execution will not have any output result.
   *
   * @generated from oneof flyteidl.admin.ExecutionClosure.output_result
   */
  outputResult: {
    /**
     * Output URI in the case of a successful execution.
     * DEPRECATED. Use GetExecutionData to fetch output data instead.
     *
     * @generated from field: flyteidl.admin.LiteralMapBlob outputs = 1 [deprecated = true];
     * @deprecated
     */
    value: LiteralMapBlob;
    case: "outputs";
  } | {
    /**
     * Error information in the case of a failed execution.
     *
     * @generated from field: flyteidl.core.ExecutionError error = 2;
     */
    value: ExecutionError;
    case: "error";
  } | {
    /**
     * In the case of a user-specified abort, this will pass along the user-supplied cause.
     *
     * @generated from field: string abort_cause = 10 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "abortCause";
  } | {
    /**
     * In the case of a user-specified abort, this will pass along the user and their supplied cause.
     *
     * @generated from field: flyteidl.admin.AbortMetadata abort_metadata = 12;
     */
    value: AbortMetadata;
    case: "abortMetadata";
  } | {
    /**
     * Raw output data produced by this execution.
     * DEPRECATED. Use GetExecutionData to fetch output data instead.
     *
     * @generated from field: flyteidl.core.LiteralMap output_data = 13 [deprecated = true];
     * @deprecated
     */
    value: LiteralMap;
    case: "outputData";
  } | { case: undefined; value?: undefined };

  /**
   * Inputs computed and passed for execution.
   * computed_inputs depends on inputs in ExecutionSpec, fixed and default inputs in launch plan
   *
   * @generated from field: flyteidl.core.LiteralMap computed_inputs = 3 [deprecated = true];
   * @deprecated
   */
  computedInputs?: LiteralMap;

  /**
   * Most recent recorded phase for the execution.
   *
   * @generated from field: flyteidl.core.WorkflowExecution.Phase phase = 4;
   */
  phase: WorkflowExecution_Phase;

  /**
   * Reported time at which the execution began running.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 5;
   */
  startedAt?: Timestamp;

  /**
   * The amount of time the execution spent running.
   *
   * @generated from field: google.protobuf.Duration duration = 6;
   */
  duration?: Duration;

  /**
   * Reported time at which the execution was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: Timestamp;

  /**
   * Reported time at which the execution was last updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 8;
   */
  updatedAt?: Timestamp;

  /**
   * The notification settings to use after merging the CreateExecutionRequest and the launch plan
   * notification settings. An execution launched with notifications will always prefer that definition
   * to notifications defined statically in a launch plan.
   *
   * @generated from field: repeated flyteidl.admin.Notification notifications = 9;
   */
  notifications: Notification[];

  /**
   * Identifies the workflow definition for this execution.
   *
   * @generated from field: flyteidl.core.Identifier workflow_id = 11;
   */
  workflowId?: Identifier;

  /**
   * Provides the details of the last stage change
   *
   * @generated from field: flyteidl.admin.ExecutionStateChangeDetails state_change_details = 14;
   */
  stateChangeDetails?: ExecutionStateChangeDetails;

  constructor(data?: PartialMessage<ExecutionClosure>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionClosure";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionClosure;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionClosure;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionClosure;

  static equals(a: ExecutionClosure | PlainMessage<ExecutionClosure> | undefined, b: ExecutionClosure | PlainMessage<ExecutionClosure> | undefined): boolean;
}

/**
 * Represents system, rather than user-facing, metadata about an execution.
 *
 * @generated from message flyteidl.admin.SystemMetadata
 */
export declare class SystemMetadata extends Message<SystemMetadata> {
  /**
   * Which execution cluster this execution ran on.
   *
   * @generated from field: string execution_cluster = 1;
   */
  executionCluster: string;

  /**
   * Which kubernetes namespace the execution ran under.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  constructor(data?: PartialMessage<SystemMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.SystemMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SystemMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SystemMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SystemMetadata;

  static equals(a: SystemMetadata | PlainMessage<SystemMetadata> | undefined, b: SystemMetadata | PlainMessage<SystemMetadata> | undefined): boolean;
}

/**
 * Represents attributes about an execution which are not required to launch the execution but are useful to record.
 * These attributes are assigned at launch time and do not change.
 *
 * @generated from message flyteidl.admin.ExecutionMetadata
 */
export declare class ExecutionMetadata extends Message<ExecutionMetadata> {
  /**
   * @generated from field: flyteidl.admin.ExecutionMetadata.ExecutionMode mode = 1;
   */
  mode: ExecutionMetadata_ExecutionMode;

  /**
   * Identifier of the entity that triggered this execution.
   * For systems using back-end authentication any value set here will be discarded in favor of the
   * authenticated user context.
   *
   * @generated from field: string principal = 2;
   */
  principal: string;

  /**
   * Indicates the nestedness of this execution.
   * If a user launches a workflow execution, the default nesting is 0.
   * If this execution further launches a workflow (child workflow), the nesting level is incremented by 0 => 1
   * Generally, if workflow at nesting level k launches a workflow then the child workflow will have
   * nesting = k + 1.
   *
   * @generated from field: uint32 nesting = 3;
   */
  nesting: number;

  /**
   * For scheduled executions, the requested time for execution for this specific schedule invocation.
   *
   * @generated from field: google.protobuf.Timestamp scheduled_at = 4;
   */
  scheduledAt?: Timestamp;

  /**
   * Which subworkflow node (if any) launched this execution
   *
   * @generated from field: flyteidl.core.NodeExecutionIdentifier parent_node_execution = 5;
   */
  parentNodeExecution?: NodeExecutionIdentifier;

  /**
   * Optional, a reference workflow execution related to this execution.
   * In the case of a relaunch, this references the original workflow execution.
   *
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier reference_execution = 16;
   */
  referenceExecution?: WorkflowExecutionIdentifier;

  /**
   * Optional, platform-specific metadata about the execution.
   * In this the future this may be gated behind an ACL or some sort of authorization.
   *
   * @generated from field: flyteidl.admin.SystemMetadata system_metadata = 17;
   */
  systemMetadata?: SystemMetadata;

  constructor(data?: PartialMessage<ExecutionMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionMetadata;

  static equals(a: ExecutionMetadata | PlainMessage<ExecutionMetadata> | undefined, b: ExecutionMetadata | PlainMessage<ExecutionMetadata> | undefined): boolean;
}

/**
 * The method by which this execution was launched.
 *
 * @generated from enum flyteidl.admin.ExecutionMetadata.ExecutionMode
 */
export declare enum ExecutionMetadata_ExecutionMode {
  /**
   * The default execution mode, MANUAL implies that an execution was launched by an individual.
   *
   * @generated from enum value: MANUAL = 0;
   */
  MANUAL = 0,

  /**
   * A schedule triggered this execution launch.
   *
   * @generated from enum value: SCHEDULED = 1;
   */
  SCHEDULED = 1,

  /**
   * A system process was responsible for launching this execution rather an individual.
   *
   * @generated from enum value: SYSTEM = 2;
   */
  SYSTEM = 2,

  /**
   * This execution was launched with identical inputs as a previous execution.
   *
   * @generated from enum value: RELAUNCH = 3;
   */
  RELAUNCH = 3,

  /**
   * This execution was triggered by another execution.
   *
   * @generated from enum value: CHILD_WORKFLOW = 4;
   */
  CHILD_WORKFLOW = 4,

  /**
   * This execution was recovered from another execution.
   *
   * @generated from enum value: RECOVERED = 5;
   */
  RECOVERED = 5,
}

/**
 * @generated from message flyteidl.admin.NotificationList
 */
export declare class NotificationList extends Message<NotificationList> {
  /**
   * @generated from field: repeated flyteidl.admin.Notification notifications = 1;
   */
  notifications: Notification[];

  constructor(data?: PartialMessage<NotificationList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.NotificationList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotificationList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotificationList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotificationList;

  static equals(a: NotificationList | PlainMessage<NotificationList> | undefined, b: NotificationList | PlainMessage<NotificationList> | undefined): boolean;
}

/**
 * An ExecutionSpec encompasses all data used to launch this execution. The Spec does not change over the lifetime
 * of an execution as it progresses across phase changes.
 *
 * @generated from message flyteidl.admin.ExecutionSpec
 */
export declare class ExecutionSpec extends Message<ExecutionSpec> {
  /**
   * Launch plan to be executed
   *
   * @generated from field: flyteidl.core.Identifier launch_plan = 1;
   */
  launchPlan?: Identifier;

  /**
   * Input values to be passed for the execution
   *
   * @generated from field: flyteidl.core.LiteralMap inputs = 2 [deprecated = true];
   * @deprecated
   */
  inputs?: LiteralMap;

  /**
   * Metadata for the execution
   *
   * @generated from field: flyteidl.admin.ExecutionMetadata metadata = 3;
   */
  metadata?: ExecutionMetadata;

  /**
   * @generated from oneof flyteidl.admin.ExecutionSpec.notification_overrides
   */
  notificationOverrides: {
    /**
     * List of notifications based on Execution status transitions
     * When this list is not empty it is used rather than any notifications defined in the referenced launch plan.
     * When this list is empty, the notifications defined for the launch plan will be applied.
     *
     * @generated from field: flyteidl.admin.NotificationList notifications = 5;
     */
    value: NotificationList;
    case: "notifications";
  } | {
    /**
     * This should be set to true if all notifications are intended to be disabled for this execution.
     *
     * @generated from field: bool disable_all = 6;
     */
    value: boolean;
    case: "disableAll";
  } | { case: undefined; value?: undefined };

  /**
   * Labels to apply to the execution resource.
   *
   * @generated from field: flyteidl.admin.Labels labels = 7;
   */
  labels?: Labels;

  /**
   * Annotations to apply to the execution resource.
   *
   * @generated from field: flyteidl.admin.Annotations annotations = 8;
   */
  annotations?: Annotations;

  /**
   * Optional: security context override to apply this execution.
   *
   * @generated from field: flyteidl.core.SecurityContext security_context = 10;
   */
  securityContext?: SecurityContext;

  /**
   * Optional: auth override to apply this execution.
   *
   * @generated from field: flyteidl.admin.AuthRole auth_role = 16 [deprecated = true];
   * @deprecated
   */
  authRole?: AuthRole;

  /**
   * Indicates the runtime priority of the execution.
   *
   * @generated from field: flyteidl.core.QualityOfService quality_of_service = 17;
   */
  qualityOfService?: QualityOfService;

  /**
   * Controls the maximum number of task nodes that can be run in parallel for the entire workflow.
   * This is useful to achieve fairness. Note: MapTasks are regarded as one unit,
   * and parallelism/concurrency of MapTasks is independent from this.
   *
   * @generated from field: int32 max_parallelism = 18;
   */
  maxParallelism: number;

  /**
   * User setting to configure where to store offloaded data (i.e. Blobs, structured datasets, query data, etc.).
   * This should be a prefix like s3://my-bucket/my-data
   *
   * @generated from field: flyteidl.admin.RawOutputDataConfig raw_output_data_config = 19;
   */
  rawOutputDataConfig?: RawOutputDataConfig;

  /**
   * Controls how to select an available cluster on which this execution should run.
   *
   * @generated from field: flyteidl.admin.ClusterAssignment cluster_assignment = 20;
   */
  clusterAssignment?: ClusterAssignment;

  /**
   * Allows for the interruptible flag of a workflow to be overwritten for a single execution.
   * Omitting this field uses the workflow's value as a default.
   * As we need to distinguish between the field not being provided and its default value false, we have to use a wrapper
   * around the bool field.
   *
   * @generated from field: google.protobuf.BoolValue interruptible = 21;
   */
  interruptible?: boolean;

  /**
   * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution.
   * If enabled, all calculations are performed even if cached results would be available, overwriting the stored
   * data once execution finishes successfully.
   *
   * @generated from field: bool overwrite_cache = 22;
   */
  overwriteCache: boolean;

  /**
   * Environment variables to be set for the execution.
   *
   * @generated from field: flyteidl.admin.Envs envs = 23;
   */
  envs?: Envs;

  /**
   * Tags to be set for the execution.
   *
   * @generated from field: repeated string tags = 24;
   */
  tags: string[];

  constructor(data?: PartialMessage<ExecutionSpec>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionSpec";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionSpec;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionSpec;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionSpec;

  static equals(a: ExecutionSpec | PlainMessage<ExecutionSpec> | undefined, b: ExecutionSpec | PlainMessage<ExecutionSpec> | undefined): boolean;
}

/**
 * Request to terminate an in-progress execution.  This action is irreversible.
 * If an execution is already terminated, this request will simply be a no-op.
 * This request will fail if it references a non-existent execution.
 * If the request succeeds the phase "ABORTED" will be recorded for the termination
 * with the optional cause added to the output_result.
 *
 * @generated from message flyteidl.admin.ExecutionTerminateRequest
 */
export declare class ExecutionTerminateRequest extends Message<ExecutionTerminateRequest> {
  /**
   * Uniquely identifies the individual workflow execution to be terminated.
   *
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier id = 1;
   */
  id?: WorkflowExecutionIdentifier;

  /**
   * Optional reason for aborting.
   *
   * @generated from field: string cause = 2;
   */
  cause: string;

  constructor(data?: PartialMessage<ExecutionTerminateRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionTerminateRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionTerminateRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionTerminateRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionTerminateRequest;

  static equals(a: ExecutionTerminateRequest | PlainMessage<ExecutionTerminateRequest> | undefined, b: ExecutionTerminateRequest | PlainMessage<ExecutionTerminateRequest> | undefined): boolean;
}

/**
 * Purposefully empty, may be populated in the future.
 *
 * @generated from message flyteidl.admin.ExecutionTerminateResponse
 */
export declare class ExecutionTerminateResponse extends Message<ExecutionTerminateResponse> {
  constructor(data?: PartialMessage<ExecutionTerminateResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionTerminateResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionTerminateResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionTerminateResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionTerminateResponse;

  static equals(a: ExecutionTerminateResponse | PlainMessage<ExecutionTerminateResponse> | undefined, b: ExecutionTerminateResponse | PlainMessage<ExecutionTerminateResponse> | undefined): boolean;
}

/**
 * Request structure to fetch inputs, output and other data produced by an execution.
 * By default this data is not returned inline in :ref:`ref_flyteidl.admin.WorkflowExecutionGetRequest`
 *
 * @generated from message flyteidl.admin.WorkflowExecutionGetDataRequest
 */
export declare class WorkflowExecutionGetDataRequest extends Message<WorkflowExecutionGetDataRequest> {
  /**
   * The identifier of the execution for which to fetch inputs and outputs.
   *
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier id = 1;
   */
  id?: WorkflowExecutionIdentifier;

  constructor(data?: PartialMessage<WorkflowExecutionGetDataRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.WorkflowExecutionGetDataRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionGetDataRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionGetDataRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecutionGetDataRequest;

  static equals(a: WorkflowExecutionGetDataRequest | PlainMessage<WorkflowExecutionGetDataRequest> | undefined, b: WorkflowExecutionGetDataRequest | PlainMessage<WorkflowExecutionGetDataRequest> | undefined): boolean;
}

/**
 * Response structure for WorkflowExecutionGetDataRequest which contains inputs and outputs for an execution.
 *
 * @generated from message flyteidl.admin.WorkflowExecutionGetDataResponse
 */
export declare class WorkflowExecutionGetDataResponse extends Message<WorkflowExecutionGetDataResponse> {
  /**
   * Signed url to fetch a core.LiteralMap of execution outputs.
   * Deprecated: Please use full_outputs instead.
   *
   * @generated from field: flyteidl.admin.UrlBlob outputs = 1 [deprecated = true];
   * @deprecated
   */
  outputs?: UrlBlob;

  /**
   * Signed url to fetch a core.LiteralMap of execution inputs.
   * Deprecated: Please use full_inputs instead.
   *
   * @generated from field: flyteidl.admin.UrlBlob inputs = 2 [deprecated = true];
   * @deprecated
   */
  inputs?: UrlBlob;

  /**
   * Full_inputs will only be populated if they are under a configured size threshold.
   *
   * @generated from field: flyteidl.core.LiteralMap full_inputs = 3;
   */
  fullInputs?: LiteralMap;

  /**
   * Full_outputs will only be populated if they are under a configured size threshold.
   *
   * @generated from field: flyteidl.core.LiteralMap full_outputs = 4;
   */
  fullOutputs?: LiteralMap;

  constructor(data?: PartialMessage<WorkflowExecutionGetDataResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.WorkflowExecutionGetDataResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionGetDataResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionGetDataResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecutionGetDataResponse;

  static equals(a: WorkflowExecutionGetDataResponse | PlainMessage<WorkflowExecutionGetDataResponse> | undefined, b: WorkflowExecutionGetDataResponse | PlainMessage<WorkflowExecutionGetDataResponse> | undefined): boolean;
}

/**
 * @generated from message flyteidl.admin.ExecutionUpdateRequest
 */
export declare class ExecutionUpdateRequest extends Message<ExecutionUpdateRequest> {
  /**
   * Identifier of the execution to update
   *
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier id = 1;
   */
  id?: WorkflowExecutionIdentifier;

  /**
   * State to set as the new value active/archive
   *
   * @generated from field: flyteidl.admin.ExecutionState state = 2;
   */
  state: ExecutionState;

  constructor(data?: PartialMessage<ExecutionUpdateRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionUpdateRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionUpdateRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionUpdateRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionUpdateRequest;

  static equals(a: ExecutionUpdateRequest | PlainMessage<ExecutionUpdateRequest> | undefined, b: ExecutionUpdateRequest | PlainMessage<ExecutionUpdateRequest> | undefined): boolean;
}

/**
 * @generated from message flyteidl.admin.ExecutionStateChangeDetails
 */
export declare class ExecutionStateChangeDetails extends Message<ExecutionStateChangeDetails> {
  /**
   * The state of the execution is used to control its visibility in the UI/CLI.
   *
   * @generated from field: flyteidl.admin.ExecutionState state = 1;
   */
  state: ExecutionState;

  /**
   * This timestamp represents when the state changed.
   *
   * @generated from field: google.protobuf.Timestamp occurred_at = 2;
   */
  occurredAt?: Timestamp;

  /**
   * Identifies the entity (if any) responsible for causing the state change of the execution
   *
   * @generated from field: string principal = 3;
   */
  principal: string;

  constructor(data?: PartialMessage<ExecutionStateChangeDetails>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionStateChangeDetails";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionStateChangeDetails;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionStateChangeDetails;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionStateChangeDetails;

  static equals(a: ExecutionStateChangeDetails | PlainMessage<ExecutionStateChangeDetails> | undefined, b: ExecutionStateChangeDetails | PlainMessage<ExecutionStateChangeDetails> | undefined): boolean;
}

/**
 * @generated from message flyteidl.admin.ExecutionUpdateResponse
 */
export declare class ExecutionUpdateResponse extends Message<ExecutionUpdateResponse> {
  constructor(data?: PartialMessage<ExecutionUpdateResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.ExecutionUpdateResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionUpdateResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionUpdateResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionUpdateResponse;

  static equals(a: ExecutionUpdateResponse | PlainMessage<ExecutionUpdateResponse> | undefined, b: ExecutionUpdateResponse | PlainMessage<ExecutionUpdateResponse> | undefined): boolean;
}

/**
 * WorkflowExecutionGetMetricsRequest represents a request to retrieve metrics for the specified workflow execution.
 *
 * @generated from message flyteidl.admin.WorkflowExecutionGetMetricsRequest
 */
export declare class WorkflowExecutionGetMetricsRequest extends Message<WorkflowExecutionGetMetricsRequest> {
  /**
   * id defines the workflow execution to query for.
   *
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier id = 1;
   */
  id?: WorkflowExecutionIdentifier;

  /**
   * depth defines the number of Flyte entity levels to traverse when breaking down execution details.
   *
   * @generated from field: int32 depth = 2;
   */
  depth: number;

  constructor(data?: PartialMessage<WorkflowExecutionGetMetricsRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.WorkflowExecutionGetMetricsRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionGetMetricsRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionGetMetricsRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecutionGetMetricsRequest;

  static equals(a: WorkflowExecutionGetMetricsRequest | PlainMessage<WorkflowExecutionGetMetricsRequest> | undefined, b: WorkflowExecutionGetMetricsRequest | PlainMessage<WorkflowExecutionGetMetricsRequest> | undefined): boolean;
}

/**
 * WorkflowExecutionGetMetricsResponse represents the response containing metrics for the specified workflow execution.
 *
 * @generated from message flyteidl.admin.WorkflowExecutionGetMetricsResponse
 */
export declare class WorkflowExecutionGetMetricsResponse extends Message<WorkflowExecutionGetMetricsResponse> {
  /**
   * Span defines the top-level breakdown of the workflows execution. More precise information is nested in a
   * hierarchical structure using Flyte entity references.
   *
   * @generated from field: flyteidl.core.Span span = 1;
   */
  span?: Span;

  constructor(data?: PartialMessage<WorkflowExecutionGetMetricsResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "flyteidl.admin.WorkflowExecutionGetMetricsResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionGetMetricsResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionGetMetricsResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecutionGetMetricsResponse;

  static equals(a: WorkflowExecutionGetMetricsResponse | PlainMessage<WorkflowExecutionGetMetricsResponse> | undefined, b: WorkflowExecutionGetMetricsResponse | PlainMessage<WorkflowExecutionGetMetricsResponse> | undefined): boolean;
}

