/**
 * flyteidl/service/admin.proto
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Specifies metadata around an aborted workflow execution.
*/
export class AdminAbortMetadata {
    /**
    * In the case of a user-specified abort, this will pass along the user-supplied cause.
    */
    'cause'?: string;
    'principal'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cause",
            "baseName": "cause",
            "type": "string"
        },
        {
            "name": "principal",
            "baseName": "principal",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminAbortMetadata.attributeTypeMap;
    }
}

/**
* Annotation values to be applied to an execution resource. In the future a mode (e.g. OVERRIDE, APPEND, etc) can be defined to specify how to merge annotations defined at registration and execution time.
*/
export class AdminAnnotations {
    /**
    * Map of custom annotations to be applied to the execution resource.
    */
    'values'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return AdminAnnotations.attributeTypeMap;
    }
}

/**
* Defines permissions associated with executions created by this launch plan spec. Use either of these roles when they have permissions required by your workflow execution. Deprecated.
*/
export class AdminAuth {
    /**
    * Defines an optional iam role which will be used for tasks run in executions created with this launch plan.
    */
    'assumableIamRole'?: string;
    /**
    * Defines an optional kubernetes service account which will be used for tasks run in executions created with this launch plan.
    */
    'kubernetesServiceAccount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assumableIamRole",
            "baseName": "assumable_iam_role",
            "type": "string"
        },
        {
            "name": "kubernetesServiceAccount",
            "baseName": "kubernetes_service_account",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminAuth.attributeTypeMap;
    }
}

/**
* Defines permissions associated with executions created by this launch plan spec. Use either of these roles when they have permissions required by your workflow execution. Deprecated.
*/
export class AdminAuthRole {
    /**
    * Defines an optional iam role which will be used for tasks run in executions created with this launch plan.
    */
    'assumableIamRole'?: string;
    /**
    * Defines an optional kubernetes service account which will be used for tasks run in executions created with this launch plan.
    */
    'kubernetesServiceAccount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assumableIamRole",
            "baseName": "assumable_iam_role",
            "type": "string"
        },
        {
            "name": "kubernetesServiceAccount",
            "baseName": "kubernetes_service_account",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminAuthRole.attributeTypeMap;
    }
}

/**
* Encapsulates specifications for routing an execution onto a specific cluster.
*/
export class AdminClusterAssignment {
    'clusterPoolName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clusterPoolName",
            "baseName": "cluster_pool_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminClusterAssignment.attributeTypeMap;
    }
}

export class AdminClusterResourceAttributes {
    /**
    * Custom resource attributes which will be applied in cluster resource creation (e.g. quotas). Map keys are the *case-sensitive* names of variables in templatized resource files. Map values should be the custom values which get substituted during resource creation.
    */
    'attributes'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return AdminClusterResourceAttributes.attributeTypeMap;
    }
}

/**
* Options for schedules to run according to a cron expression.
*/
export class AdminCronSchedule {
    'schedule'?: string;
    'offset'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "string"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminCronSchedule.attributeTypeMap;
    }
}

/**
* Full user description with formatting preserved. This can be rendered by clients, such as the console or command line tools with in-tact formatting.
*/
export class AdminDescription {
    'value'?: string;
    'uri'?: string;
    'format'?: AdminDescriptionFormat;
    'iconLink'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "AdminDescriptionFormat"
        },
        {
            "name": "iconLink",
            "baseName": "icon_link",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminDescription.attributeTypeMap;
    }
}

/**
* DescriptionEntity contains detailed description for the task/workflow. Documentation could provide insight into the algorithms, business use case, etc.
*/
export class AdminDescriptionEntity {
    /**
    * id represents the unique identifier of the description entity.
    */
    'id'?: CoreIdentifier;
    /**
    * One-liner overview of the entity.
    */
    'shortDescription'?: string;
    /**
    * Full user description with formatting preserved.
    */
    'longDescription'?: AdminDescription;
    /**
    * Optional link to source code used to define this entity.
    */
    'sourceCode'?: AdminSourceCode;
    /**
    * User-specified tags. These are arbitrary and can be used for searching filtering and discovering tasks.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        },
        {
            "name": "longDescription",
            "baseName": "long_description",
            "type": "AdminDescription"
        },
        {
            "name": "sourceCode",
            "baseName": "source_code",
            "type": "AdminSourceCode"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AdminDescriptionEntity.attributeTypeMap;
    }
}

export class AdminDescriptionEntityList {
    /**
    * A list of DescriptionEntities returned based on the request.
    */
    'descriptionEntities'?: Array<AdminDescriptionEntity>;
    /**
    * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "descriptionEntities",
            "baseName": "descriptionEntities",
            "type": "Array<AdminDescriptionEntity>"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminDescriptionEntityList.attributeTypeMap;
    }
}

/**
* - DESCRIPTION_FORMAT_RST: python default documentation - comments is rst
*/
export class AdminDescriptionFormat {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminDescriptionFormat.attributeTypeMap;
    }
}

/**
* Namespace within a project commonly used to differentiate between different service instances. e.g. \"production\", \"development\", etc.
*/
export class AdminDomain {
    /**
    * Globally unique domain name.
    */
    'id'?: string;
    /**
    * Display name.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminDomain.attributeTypeMap;
    }
}

/**
* Defines an email notification specification.
*/
export class AdminEmailNotification {
    'recipientsEmail'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipientsEmail",
            "baseName": "recipients_email",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AdminEmailNotification.attributeTypeMap;
    }
}

/**
* Environment variable values to be applied to an execution resource. In the future a mode (e.g. OVERRIDE, APPEND, etc) can be defined to specify how to merge environment variables defined at registration and execution time.
*/
export class AdminEnvs {
    /**
    * Map of custom environment variables to be applied to the execution resource.
    */
    'values'?: Array<CoreKeyValuePair>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<CoreKeyValuePair>"
        }    ];

    static getAttributeTypeMap() {
        return AdminEnvs.attributeTypeMap;
    }
}

/**
* A workflow execution represents an instantiated workflow, including all inputs and additional metadata as well as computed results included state, outputs, and duration-based attributes. Used as a response object used in Get and List execution requests.
*/
export class AdminExecution {
    /**
    * Unique identifier of the workflow execution.
    */
    'id'?: CoreWorkflowExecutionIdentifier;
    /**
    * User-provided configuration and inputs for launching the execution.
    */
    'spec'?: AdminExecutionSpec;
    /**
    * Execution results.
    */
    'closure'?: AdminExecutionClosure;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreWorkflowExecutionIdentifier"
        },
        {
            "name": "spec",
            "baseName": "spec",
            "type": "AdminExecutionSpec"
        },
        {
            "name": "closure",
            "baseName": "closure",
            "type": "AdminExecutionClosure"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecution.attributeTypeMap;
    }
}

export class AdminExecutionClosure {
    /**
    * Output URI in the case of a successful execution. DEPRECATED. Use GetExecutionData to fetch output data instead.
    */
    'outputs'?: AdminLiteralMapBlob;
    /**
    * Error information in the case of a failed execution.
    */
    'error'?: CoreExecutionError;
    /**
    * In the case of a user-specified abort, this will pass along the user-supplied cause.
    */
    'abortCause'?: string;
    /**
    * In the case of a user-specified abort, this will pass along the user and their supplied cause.
    */
    'abortMetadata'?: AdminAbortMetadata;
    /**
    * Raw output data produced by this execution. DEPRECATED. Use GetExecutionData to fetch output data instead.
    */
    'outputData'?: CoreLiteralMap;
    'computedInputs'?: CoreLiteralMap;
    /**
    * Most recent recorded phase for the execution.
    */
    'phase'?: CoreWorkflowExecutionPhase;
    /**
    * Reported time at which the execution began running.
    */
    'startedAt'?: Date;
    /**
    * The amount of time the execution spent running.
    */
    'duration'?: string;
    /**
    * Reported time at which the execution was created.
    */
    'createdAt'?: Date;
    /**
    * Reported time at which the execution was last updated.
    */
    'updatedAt'?: Date;
    /**
    * The notification settings to use after merging the CreateExecutionRequest and the launch plan notification settings. An execution launched with notifications will always prefer that definition to notifications defined statically in a launch plan.
    */
    'notifications'?: Array<AdminNotification>;
    /**
    * Identifies the workflow definition for this execution.
    */
    'workflowId'?: CoreIdentifier;
    'stateChangeDetails'?: AdminExecutionStateChangeDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "outputs",
            "baseName": "outputs",
            "type": "AdminLiteralMapBlob"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "CoreExecutionError"
        },
        {
            "name": "abortCause",
            "baseName": "abort_cause",
            "type": "string"
        },
        {
            "name": "abortMetadata",
            "baseName": "abort_metadata",
            "type": "AdminAbortMetadata"
        },
        {
            "name": "outputData",
            "baseName": "output_data",
            "type": "CoreLiteralMap"
        },
        {
            "name": "computedInputs",
            "baseName": "computed_inputs",
            "type": "CoreLiteralMap"
        },
        {
            "name": "phase",
            "baseName": "phase",
            "type": "CoreWorkflowExecutionPhase"
        },
        {
            "name": "startedAt",
            "baseName": "started_at",
            "type": "Date"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "Array<AdminNotification>"
        },
        {
            "name": "workflowId",
            "baseName": "workflow_id",
            "type": "CoreIdentifier"
        },
        {
            "name": "stateChangeDetails",
            "baseName": "state_change_details",
            "type": "AdminExecutionStateChangeDetails"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionClosure.attributeTypeMap;
    }
}

export class AdminExecutionClusterLabel {
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionClusterLabel.attributeTypeMap;
    }
}

/**
* Request to launch an execution with the given project, domain and optionally-assigned name.
*/
export class AdminExecutionCreateRequest {
    'project'?: string;
    'domain'?: string;
    'name'?: string;
    'spec'?: AdminExecutionSpec;
    'inputs'?: CoreLiteralMap;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "spec",
            "baseName": "spec",
            "type": "AdminExecutionSpec"
        },
        {
            "name": "inputs",
            "baseName": "inputs",
            "type": "CoreLiteralMap"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionCreateRequest.attributeTypeMap;
    }
}

/**
* The unique identifier for a successfully created execution. If the name was *not* specified in the create request, this identifier will include a generated name.
*/
export class AdminExecutionCreateResponse {
    'id'?: CoreWorkflowExecutionIdentifier;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreWorkflowExecutionIdentifier"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionCreateResponse.attributeTypeMap;
    }
}

export class AdminExecutionList {
    'executions'?: Array<AdminExecution>;
    /**
    * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "executions",
            "baseName": "executions",
            "type": "Array<AdminExecution>"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionList.attributeTypeMap;
    }
}

/**
* Represents attributes about an execution which are not required to launch the execution but are useful to record. These attributes are assigned at launch time and do not change.
*/
export class AdminExecutionMetadata {
    'mode'?: ExecutionMetadataExecutionMode;
    /**
    * Identifier of the entity that triggered this execution. For systems using back-end authentication any value set here will be discarded in favor of the authenticated user context.
    */
    'principal'?: string;
    /**
    * Indicates the nestedness of this execution. If a user launches a workflow execution, the default nesting is 0. If this execution further launches a workflow (child workflow), the nesting level is incremented by 0 => 1 Generally, if workflow at nesting level k launches a workflow then the child workflow will have nesting = k + 1.
    */
    'nesting'?: number;
    /**
    * For scheduled executions, the requested time for execution for this specific schedule invocation.
    */
    'scheduledAt'?: Date;
    'parentNodeExecution'?: CoreNodeExecutionIdentifier;
    /**
    * Optional, a reference workflow execution related to this execution. In the case of a relaunch, this references the original workflow execution.
    */
    'referenceExecution'?: CoreWorkflowExecutionIdentifier;
    /**
    * Optional, platform-specific metadata about the execution. In this the future this may be gated behind an ACL or some sort of authorization.
    */
    'systemMetadata'?: AdminSystemMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mode",
            "baseName": "mode",
            "type": "ExecutionMetadataExecutionMode"
        },
        {
            "name": "principal",
            "baseName": "principal",
            "type": "string"
        },
        {
            "name": "nesting",
            "baseName": "nesting",
            "type": "number"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduled_at",
            "type": "Date"
        },
        {
            "name": "parentNodeExecution",
            "baseName": "parent_node_execution",
            "type": "CoreNodeExecutionIdentifier"
        },
        {
            "name": "referenceExecution",
            "baseName": "reference_execution",
            "type": "CoreWorkflowExecutionIdentifier"
        },
        {
            "name": "systemMetadata",
            "baseName": "system_metadata",
            "type": "AdminSystemMetadata"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionMetadata.attributeTypeMap;
    }
}

export class AdminExecutionQueueAttributes {
    /**
    * Tags used for assigning execution queues for tasks defined within this project.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionQueueAttributes.attributeTypeMap;
    }
}

/**
* Request to recover the referenced execution.
*/
export class AdminExecutionRecoverRequest {
    /**
    * Identifier of the workflow execution to recover.
    */
    'id'?: CoreWorkflowExecutionIdentifier;
    'name'?: string;
    /**
    * Additional metadata which will be used to overwrite any metadata in the reference execution when triggering a recovery execution.
    */
    'metadata'?: AdminExecutionMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreWorkflowExecutionIdentifier"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "AdminExecutionMetadata"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionRecoverRequest.attributeTypeMap;
    }
}

/**
* Request to relaunch the referenced execution.
*/
export class AdminExecutionRelaunchRequest {
    'id'?: CoreWorkflowExecutionIdentifier;
    'name'?: string;
    /**
    * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution. If enabled, all calculations are performed even if cached results would be available, overwriting the stored data once execution finishes successfully.
    */
    'overwriteCache'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreWorkflowExecutionIdentifier"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "overwriteCache",
            "baseName": "overwrite_cache",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionRelaunchRequest.attributeTypeMap;
    }
}

/**
* An ExecutionSpec encompasses all data used to launch this execution. The Spec does not change over the lifetime of an execution as it progresses across phase changes.
*/
export class AdminExecutionSpec {
    'launchPlan'?: CoreIdentifier;
    'inputs'?: CoreLiteralMap;
    'metadata'?: AdminExecutionMetadata;
    /**
    * List of notifications based on Execution status transitions When this list is not empty it is used rather than any notifications defined in the referenced launch plan. When this list is empty, the notifications defined for the launch plan will be applied.
    */
    'notifications'?: AdminNotificationList;
    /**
    * This should be set to true if all notifications are intended to be disabled for this execution.
    */
    'disableAll'?: boolean;
    /**
    * Labels to apply to the execution resource.
    */
    'labels'?: AdminLabels;
    /**
    * Annotations to apply to the execution resource.
    */
    'annotations'?: AdminAnnotations;
    /**
    * Optional: security context override to apply this execution.
    */
    'securityContext'?: CoreSecurityContext;
    /**
    * Optional: auth override to apply this execution.
    */
    'authRole'?: AdminAuthRole;
    /**
    * Indicates the runtime priority of the execution.
    */
    'qualityOfService'?: CoreQualityOfService;
    /**
    * Controls the maximum number of task nodes that can be run in parallel for the entire workflow. This is useful to achieve fairness. Note: MapTasks are regarded as one unit, and parallelism/concurrency of MapTasks is independent from this.
    */
    'maxParallelism'?: number;
    'rawOutputDataConfig'?: AdminRawOutputDataConfig;
    /**
    * Controls how to select an available cluster on which this execution should run.
    */
    'clusterAssignment'?: AdminClusterAssignment;
    /**
    * Allows for the interruptible flag of a workflow to be overwritten for a single execution. Omitting this field uses the workflow's value as a default. As we need to distinguish between the field not being provided and its default value false, we have to use a wrapper around the bool field.
    */
    'interruptible'?: boolean;
    /**
    * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution. If enabled, all calculations are performed even if cached results would be available, overwriting the stored data once execution finishes successfully.
    */
    'overwriteCache'?: boolean;
    /**
    * Environment variables to be set for the execution.
    */
    'envs'?: AdminEnvs;
    /**
    * Tags to be set for the execution.
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "launchPlan",
            "baseName": "launch_plan",
            "type": "CoreIdentifier"
        },
        {
            "name": "inputs",
            "baseName": "inputs",
            "type": "CoreLiteralMap"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "AdminExecutionMetadata"
        },
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "AdminNotificationList"
        },
        {
            "name": "disableAll",
            "baseName": "disable_all",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "AdminLabels"
        },
        {
            "name": "annotations",
            "baseName": "annotations",
            "type": "AdminAnnotations"
        },
        {
            "name": "securityContext",
            "baseName": "security_context",
            "type": "CoreSecurityContext"
        },
        {
            "name": "authRole",
            "baseName": "auth_role",
            "type": "AdminAuthRole"
        },
        {
            "name": "qualityOfService",
            "baseName": "quality_of_service",
            "type": "CoreQualityOfService"
        },
        {
            "name": "maxParallelism",
            "baseName": "max_parallelism",
            "type": "number"
        },
        {
            "name": "rawOutputDataConfig",
            "baseName": "raw_output_data_config",
            "type": "AdminRawOutputDataConfig"
        },
        {
            "name": "clusterAssignment",
            "baseName": "cluster_assignment",
            "type": "AdminClusterAssignment"
        },
        {
            "name": "interruptible",
            "baseName": "interruptible",
            "type": "boolean"
        },
        {
            "name": "overwriteCache",
            "baseName": "overwrite_cache",
            "type": "boolean"
        },
        {
            "name": "envs",
            "baseName": "envs",
            "type": "AdminEnvs"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionSpec.attributeTypeMap;
    }
}

/**
* The state of the execution is used to control its visibility in the UI/CLI.   - EXECUTION_ACTIVE: By default, all executions are considered active.  - EXECUTION_ARCHIVED: Archived executions are no longer visible in the UI.
*/
export class AdminExecutionState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminExecutionState.attributeTypeMap;
    }
}

export class AdminExecutionStateChangeDetails {
    /**
    * The state of the execution is used to control its visibility in the UI/CLI.
    */
    'state'?: AdminExecutionState;
    /**
    * This timestamp represents when the state changed.
    */
    'occurredAt'?: Date;
    'principal'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "state",
            "baseName": "state",
            "type": "AdminExecutionState"
        },
        {
            "name": "occurredAt",
            "baseName": "occurred_at",
            "type": "Date"
        },
        {
            "name": "principal",
            "baseName": "principal",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionStateChangeDetails.attributeTypeMap;
    }
}

/**
* Request to terminate an in-progress execution.  This action is irreversible. If an execution is already terminated, this request will simply be a no-op. This request will fail if it references a non-existent execution. If the request succeeds the phase \"ABORTED\" will be recorded for the termination with the optional cause added to the output_result.
*/
export class AdminExecutionTerminateRequest {
    /**
    * Uniquely identifies the individual workflow execution to be terminated.
    */
    'id'?: CoreWorkflowExecutionIdentifier;
    /**
    * Optional reason for aborting.
    */
    'cause'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreWorkflowExecutionIdentifier"
        },
        {
            "name": "cause",
            "baseName": "cause",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionTerminateRequest.attributeTypeMap;
    }
}

export class AdminExecutionTerminateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminExecutionTerminateResponse.attributeTypeMap;
    }
}

export class AdminExecutionUpdateRequest {
    'id'?: CoreWorkflowExecutionIdentifier;
    'state'?: AdminExecutionState;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreWorkflowExecutionIdentifier"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "AdminExecutionState"
        }    ];

    static getAttributeTypeMap() {
        return AdminExecutionUpdateRequest.attributeTypeMap;
    }
}

export class AdminExecutionUpdateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminExecutionUpdateResponse.attributeTypeMap;
    }
}

/**
* Option for schedules run at a certain frequency e.g. every 2 minutes.
*/
export class AdminFixedRate {
    'value'?: number;
    'unit'?: AdminFixedRateUnit;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "unit",
            "baseName": "unit",
            "type": "AdminFixedRateUnit"
        }    ];

    static getAttributeTypeMap() {
        return AdminFixedRate.attributeTypeMap;
    }
}

/**
* Represents a frequency at which to run a schedule.
*/
export class AdminFixedRateUnit {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminFixedRateUnit.attributeTypeMap;
    }
}

/**
* These URLs are returned as part of node and task execution data requests.
*/
export class AdminFlyteURLs {
    'inputs'?: string;
    'outputs'?: string;
    'deck'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "inputs",
            "baseName": "inputs",
            "type": "string"
        },
        {
            "name": "outputs",
            "baseName": "outputs",
            "type": "string"
        },
        {
            "name": "deck",
            "baseName": "deck",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminFlyteURLs.attributeTypeMap;
    }
}

export class AdminGetVersionResponse {
    'controlPlaneVersion'?: AdminVersion;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "controlPlaneVersion",
            "baseName": "control_plane_version",
            "type": "AdminVersion"
        }    ];

    static getAttributeTypeMap() {
        return AdminGetVersionResponse.attributeTypeMap;
    }
}

/**
* Label values to be applied to an execution resource. In the future a mode (e.g. OVERRIDE, APPEND, etc) can be defined to specify how to merge labels defined at registration and execution time.
*/
export class AdminLabels {
    /**
    * Map of custom labels to be applied to the execution resource.
    */
    'values'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return AdminLabels.attributeTypeMap;
    }
}

/**
* A LaunchPlan provides the capability to templatize workflow executions. Launch plans simplify associating one or more schedules, inputs and notifications with your workflows. Launch plans can be shared and used to trigger executions with predefined inputs even when a workflow definition doesn't necessarily have a default value for said input.
*/
export class AdminLaunchPlan {
    /**
    * Uniquely identifies a launch plan entity.
    */
    'id'?: CoreIdentifier;
    /**
    * User-provided launch plan details, including reference workflow, inputs and other metadata.
    */
    'spec'?: AdminLaunchPlanSpec;
    /**
    * Values computed by the flyte platform after launch plan registration.
    */
    'closure'?: AdminLaunchPlanClosure;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "spec",
            "baseName": "spec",
            "type": "AdminLaunchPlanSpec"
        },
        {
            "name": "closure",
            "baseName": "closure",
            "type": "AdminLaunchPlanClosure"
        }    ];

    static getAttributeTypeMap() {
        return AdminLaunchPlan.attributeTypeMap;
    }
}

/**
* Values computed by the flyte platform after launch plan registration. These include expected_inputs required to be present in a CreateExecutionRequest to launch the reference workflow as well timestamp values associated with the launch plan.
*/
export class AdminLaunchPlanClosure {
    /**
    * Indicate the Launch plan state.
    */
    'state'?: AdminLaunchPlanState;
    'expectedInputs'?: CoreParameterMap;
    'expectedOutputs'?: CoreVariableMap;
    /**
    * Time at which the launch plan was created.
    */
    'createdAt'?: Date;
    /**
    * Time at which the launch plan was last updated.
    */
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "state",
            "baseName": "state",
            "type": "AdminLaunchPlanState"
        },
        {
            "name": "expectedInputs",
            "baseName": "expected_inputs",
            "type": "CoreParameterMap"
        },
        {
            "name": "expectedOutputs",
            "baseName": "expected_outputs",
            "type": "CoreVariableMap"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return AdminLaunchPlanClosure.attributeTypeMap;
    }
}

/**
* Request to register a launch plan. The included LaunchPlanSpec may have a complete or incomplete set of inputs required to launch a workflow execution. By default all launch plans are registered in state INACTIVE. If you wish to set the state to ACTIVE, you must submit a LaunchPlanUpdateRequest, after you have successfully created a launch plan.
*/
export class AdminLaunchPlanCreateRequest {
    /**
    * Uniquely identifies a launch plan entity.
    */
    'id'?: CoreIdentifier;
    /**
    * User-provided launch plan details, including reference workflow, inputs and other metadata.
    */
    'spec'?: AdminLaunchPlanSpec;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "spec",
            "baseName": "spec",
            "type": "AdminLaunchPlanSpec"
        }    ];

    static getAttributeTypeMap() {
        return AdminLaunchPlanCreateRequest.attributeTypeMap;
    }
}

export class AdminLaunchPlanCreateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminLaunchPlanCreateResponse.attributeTypeMap;
    }
}

export class AdminLaunchPlanList {
    'launchPlans'?: Array<AdminLaunchPlan>;
    /**
    * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "launchPlans",
            "baseName": "launch_plans",
            "type": "Array<AdminLaunchPlan>"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminLaunchPlanList.attributeTypeMap;
    }
}

/**
* Additional launch plan attributes included in the LaunchPlanSpec not strictly required to launch the reference workflow.
*/
export class AdminLaunchPlanMetadata {
    'schedule'?: AdminSchedule;
    'notifications'?: Array<AdminNotification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "AdminSchedule"
        },
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "Array<AdminNotification>"
        }    ];

    static getAttributeTypeMap() {
        return AdminLaunchPlanMetadata.attributeTypeMap;
    }
}

/**
* User-provided launch plan definition and configuration values.
*/
export class AdminLaunchPlanSpec {
    'workflowId'?: CoreIdentifier;
    'entityMetadata'?: AdminLaunchPlanMetadata;
    /**
    * Input values to be passed for the execution. These can be overridden when an execution is created with this launch plan.
    */
    'defaultInputs'?: CoreParameterMap;
    /**
    * Fixed, non-overridable inputs for the Launch Plan. These can not be overridden when an execution is created with this launch plan.
    */
    'fixedInputs'?: CoreLiteralMap;
    'role'?: string;
    /**
    * Custom labels to be applied to the execution resource.
    */
    'labels'?: AdminLabels;
    /**
    * Custom annotations to be applied to the execution resource.
    */
    'annotations'?: AdminAnnotations;
    /**
    * Indicates the permission associated with workflow executions triggered with this launch plan.
    */
    'auth'?: AdminAuth;
    'authRole'?: AdminAuthRole;
    'securityContext'?: CoreSecurityContext;
    /**
    * Indicates the runtime priority of the execution.
    */
    'qualityOfService'?: CoreQualityOfService;
    /**
    * Encapsulates user settings pertaining to offloaded data (i.e. Blobs, Schema, query data, etc.).
    */
    'rawOutputDataConfig'?: AdminRawOutputDataConfig;
    /**
    * Controls the maximum number of tasknodes that can be run in parallel for the entire workflow. This is useful to achieve fairness. Note: MapTasks are regarded as one unit, and parallelism/concurrency of MapTasks is independent from this.
    */
    'maxParallelism'?: number;
    /**
    * Allows for the interruptible flag of a workflow to be overwritten for a single execution. Omitting this field uses the workflow's value as a default. As we need to distinguish between the field not being provided and its default value false, we have to use a wrapper around the bool field.
    */
    'interruptible'?: boolean;
    /**
    * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution. If enabled, all calculations are performed even if cached results would be available, overwriting the stored data once execution finishes successfully.
    */
    'overwriteCache'?: boolean;
    /**
    * Environment variables to be set for the execution.
    */
    'envs'?: AdminEnvs;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "workflowId",
            "baseName": "workflow_id",
            "type": "CoreIdentifier"
        },
        {
            "name": "entityMetadata",
            "baseName": "entity_metadata",
            "type": "AdminLaunchPlanMetadata"
        },
        {
            "name": "defaultInputs",
            "baseName": "default_inputs",
            "type": "CoreParameterMap"
        },
        {
            "name": "fixedInputs",
            "baseName": "fixed_inputs",
            "type": "CoreLiteralMap"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "AdminLabels"
        },
        {
            "name": "annotations",
            "baseName": "annotations",
            "type": "AdminAnnotations"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "AdminAuth"
        },
        {
            "name": "authRole",
            "baseName": "auth_role",
            "type": "AdminAuthRole"
        },
        {
            "name": "securityContext",
            "baseName": "security_context",
            "type": "CoreSecurityContext"
        },
        {
            "name": "qualityOfService",
            "baseName": "quality_of_service",
            "type": "CoreQualityOfService"
        },
        {
            "name": "rawOutputDataConfig",
            "baseName": "raw_output_data_config",
            "type": "AdminRawOutputDataConfig"
        },
        {
            "name": "maxParallelism",
            "baseName": "max_parallelism",
            "type": "number"
        },
        {
            "name": "interruptible",
            "baseName": "interruptible",
            "type": "boolean"
        },
        {
            "name": "overwriteCache",
            "baseName": "overwrite_cache",
            "type": "boolean"
        },
        {
            "name": "envs",
            "baseName": "envs",
            "type": "AdminEnvs"
        }    ];

    static getAttributeTypeMap() {
        return AdminLaunchPlanSpec.attributeTypeMap;
    }
}

/**
* By default any launch plan regardless of state can be used to launch a workflow execution. However, at most one version of a launch plan (e.g. a NamedEntityIdentifier set of shared project, domain and name values) can be active at a time in regards to *schedules*. That is, at most one schedule in a NamedEntityIdentifier group will be observed and trigger executions at a defined cadence.
*/
export class AdminLaunchPlanState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminLaunchPlanState.attributeTypeMap;
    }
}

export class AdminLaunchPlanUpdateRequest {
    /**
    * Identifier of launch plan for which to change state. +required.
    */
    'id'?: CoreIdentifier;
    /**
    * Desired state to apply to the launch plan. +required.
    */
    'state'?: AdminLaunchPlanState;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "AdminLaunchPlanState"
        }    ];

    static getAttributeTypeMap() {
        return AdminLaunchPlanUpdateRequest.attributeTypeMap;
    }
}

/**
* Purposefully empty, may be populated in the future.
*/
export class AdminLaunchPlanUpdateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminLaunchPlanUpdateResponse.attributeTypeMap;
    }
}

export class AdminListMatchableAttributesResponse {
    'configurations'?: Array<AdminMatchableAttributesConfiguration>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "Array<AdminMatchableAttributesConfiguration>"
        }    ];

    static getAttributeTypeMap() {
        return AdminListMatchableAttributesResponse.attributeTypeMap;
    }
}

export class AdminLiteralMapBlob {
    'values'?: CoreLiteralMap;
    'uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "CoreLiteralMap"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminLiteralMapBlob.attributeTypeMap;
    }
}

/**
* Represents a custom set of attributes applied for either a domain; a domain and project; or domain, project and workflow name. These are used to override system level defaults for kubernetes cluster resource management, default execution values, and more all across different levels of specificity.
*/
export class AdminMatchableAttributesConfiguration {
    'attributes'?: AdminMatchingAttributes;
    'domain'?: string;
    'project'?: string;
    'workflow'?: string;
    'launchPlan'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "AdminMatchingAttributes"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "string"
        },
        {
            "name": "launchPlan",
            "baseName": "launch_plan",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminMatchableAttributesConfiguration.attributeTypeMap;
    }
}

/**
* Defines a resource that can be configured by customizable Project-, ProjectDomain- or WorkflowAttributes based on matching tags.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
*/
export class AdminMatchableResource {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminMatchableResource.attributeTypeMap;
    }
}

/**
* Generic container for encapsulating all types of the above attributes messages.
*/
export class AdminMatchingAttributes {
    'taskResourceAttributes'?: AdminTaskResourceAttributes;
    'clusterResourceAttributes'?: AdminClusterResourceAttributes;
    'executionQueueAttributes'?: AdminExecutionQueueAttributes;
    'executionClusterLabel'?: AdminExecutionClusterLabel;
    'qualityOfService'?: CoreQualityOfService;
    'pluginOverrides'?: AdminPluginOverrides;
    'workflowExecutionConfig'?: AdminWorkflowExecutionConfig;
    'clusterAssignment'?: AdminClusterAssignment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taskResourceAttributes",
            "baseName": "task_resource_attributes",
            "type": "AdminTaskResourceAttributes"
        },
        {
            "name": "clusterResourceAttributes",
            "baseName": "cluster_resource_attributes",
            "type": "AdminClusterResourceAttributes"
        },
        {
            "name": "executionQueueAttributes",
            "baseName": "execution_queue_attributes",
            "type": "AdminExecutionQueueAttributes"
        },
        {
            "name": "executionClusterLabel",
            "baseName": "execution_cluster_label",
            "type": "AdminExecutionClusterLabel"
        },
        {
            "name": "qualityOfService",
            "baseName": "quality_of_service",
            "type": "CoreQualityOfService"
        },
        {
            "name": "pluginOverrides",
            "baseName": "plugin_overrides",
            "type": "AdminPluginOverrides"
        },
        {
            "name": "workflowExecutionConfig",
            "baseName": "workflow_execution_config",
            "type": "AdminWorkflowExecutionConfig"
        },
        {
            "name": "clusterAssignment",
            "baseName": "cluster_assignment",
            "type": "AdminClusterAssignment"
        }    ];

    static getAttributeTypeMap() {
        return AdminMatchingAttributes.attributeTypeMap;
    }
}

/**
* Encapsulates information common to a NamedEntity, a Flyte resource such as a task, workflow or launch plan. A NamedEntity is exclusively identified by its resource type and identifier.
*/
export class AdminNamedEntity {
    /**
    * Resource type of the named entity. One of Task, Workflow or LaunchPlan.
    */
    'resourceType'?: CoreResourceType;
    'id'?: AdminNamedEntityIdentifier;
    /**
    * Additional metadata around a named entity.
    */
    'metadata'?: AdminNamedEntityMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resourceType",
            "baseName": "resource_type",
            "type": "CoreResourceType"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "AdminNamedEntityIdentifier"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "AdminNamedEntityMetadata"
        }    ];

    static getAttributeTypeMap() {
        return AdminNamedEntity.attributeTypeMap;
    }
}

/**
* Encapsulation of fields that identifies a Flyte resource. A Flyte resource can be a task, workflow or launch plan. A resource can internally have multiple versions and is uniquely identified by project, domain, and name.
*/
export class AdminNamedEntityIdentifier {
    /**
    * Name of the project the resource belongs to.
    */
    'project'?: string;
    /**
    * Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
    */
    'domain'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminNamedEntityIdentifier.attributeTypeMap;
    }
}

/**
* Represents a list of NamedEntityIdentifiers.
*/
export class AdminNamedEntityIdentifierList {
    /**
    * A list of identifiers.
    */
    'entities'?: Array<AdminNamedEntityIdentifier>;
    /**
    * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entities",
            "baseName": "entities",
            "type": "Array<AdminNamedEntityIdentifier>"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminNamedEntityIdentifierList.attributeTypeMap;
    }
}

/**
* Represents a list of NamedEntityIdentifiers.
*/
export class AdminNamedEntityList {
    'entities'?: Array<AdminNamedEntity>;
    /**
    * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entities",
            "baseName": "entities",
            "type": "Array<AdminNamedEntity>"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminNamedEntityList.attributeTypeMap;
    }
}

/**
* Additional metadata around a named entity.
*/
export class AdminNamedEntityMetadata {
    'description'?: string;
    /**
    * Shared state across all version of the entity At this point in time, only workflow entities can have their state archived.
    */
    'state'?: AdminNamedEntityState;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "AdminNamedEntityState"
        }    ];

    static getAttributeTypeMap() {
        return AdminNamedEntityMetadata.attributeTypeMap;
    }
}

/**
* The status of the named entity is used to control its visibility in the UI.   - NAMED_ENTITY_ACTIVE: By default, all named entities are considered active and under development.  - NAMED_ENTITY_ARCHIVED: Archived named entities are no longer visible in the UI.  - SYSTEM_GENERATED: System generated entities that aren't explicitly created or managed by a user.
*/
export class AdminNamedEntityState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminNamedEntityState.attributeTypeMap;
    }
}

/**
* Request to set the referenced named entity state to the configured value.
*/
export class AdminNamedEntityUpdateRequest {
    'resourceType'?: CoreResourceType;
    'id'?: AdminNamedEntityIdentifier;
    'metadata'?: AdminNamedEntityMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resourceType",
            "baseName": "resource_type",
            "type": "CoreResourceType"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "AdminNamedEntityIdentifier"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "AdminNamedEntityMetadata"
        }    ];

    static getAttributeTypeMap() {
        return AdminNamedEntityUpdateRequest.attributeTypeMap;
    }
}

/**
* Purposefully empty, may be populated in the future.
*/
export class AdminNamedEntityUpdateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminNamedEntityUpdateResponse.attributeTypeMap;
    }
}

/**
* Container for node execution details and results.
*/
export class AdminNodeExecutionClosure {
    /**
    * Links to a remotely stored, serialized core.LiteralMap of node execution outputs. DEPRECATED. Use GetNodeExecutionData to fetch output data instead.
    */
    'outputUri'?: string;
    'error'?: CoreExecutionError;
    /**
    * Raw output data produced by this node execution. DEPRECATED. Use GetNodeExecutionData to fetch output data instead.
    */
    'outputData'?: CoreLiteralMap;
    /**
    * The last recorded phase for this node execution.
    */
    'phase'?: CoreNodeExecutionPhase;
    /**
    * Time at which the node execution began running.
    */
    'startedAt'?: Date;
    /**
    * The amount of time the node execution spent running.
    */
    'duration'?: string;
    /**
    * Time at which the node execution was created.
    */
    'createdAt'?: Date;
    /**
    * Time at which the node execution was last updated.
    */
    'updatedAt'?: Date;
    'workflowNodeMetadata'?: FlyteidladminWorkflowNodeMetadata;
    'taskNodeMetadata'?: FlyteidladminTaskNodeMetadata;
    'deckUri'?: string;
    /**
    * dynamic_job_spec_uri is the location of the DynamicJobSpec proto message for a DynamicWorkflow. This is required to correctly recover partially completed executions where the subworkflow has already been compiled.
    */
    'dynamicJobSpecUri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "outputUri",
            "baseName": "output_uri",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "CoreExecutionError"
        },
        {
            "name": "outputData",
            "baseName": "output_data",
            "type": "CoreLiteralMap"
        },
        {
            "name": "phase",
            "baseName": "phase",
            "type": "CoreNodeExecutionPhase"
        },
        {
            "name": "startedAt",
            "baseName": "started_at",
            "type": "Date"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "workflowNodeMetadata",
            "baseName": "workflow_node_metadata",
            "type": "FlyteidladminWorkflowNodeMetadata"
        },
        {
            "name": "taskNodeMetadata",
            "baseName": "task_node_metadata",
            "type": "FlyteidladminTaskNodeMetadata"
        },
        {
            "name": "deckUri",
            "baseName": "deck_uri",
            "type": "string"
        },
        {
            "name": "dynamicJobSpecUri",
            "baseName": "dynamic_job_spec_uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminNodeExecutionClosure.attributeTypeMap;
    }
}

/**
* Request to send a notification that a node execution event has occurred.
*/
export class AdminNodeExecutionEventRequest {
    'requestId'?: string;
    /**
    * Details about the event that occurred.
    */
    'event'?: EventNodeExecutionEvent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "request_id",
            "type": "string"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "EventNodeExecutionEvent"
        }    ];

    static getAttributeTypeMap() {
        return AdminNodeExecutionEventRequest.attributeTypeMap;
    }
}

export class AdminNodeExecutionEventResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminNodeExecutionEventResponse.attributeTypeMap;
    }
}

/**
* Response structure for NodeExecutionGetDataRequest which contains inputs and outputs for a node execution.
*/
export class AdminNodeExecutionGetDataResponse {
    /**
    * Signed url to fetch a core.LiteralMap of node execution inputs. Deprecated: Please use full_inputs instead.
    */
    'inputs'?: AdminUrlBlob;
    /**
    * Signed url to fetch a core.LiteralMap of node execution outputs. Deprecated: Please use full_outputs instead.
    */
    'outputs'?: AdminUrlBlob;
    /**
    * Full_inputs will only be populated if they are under a configured size threshold.
    */
    'fullInputs'?: CoreLiteralMap;
    /**
    * Full_outputs will only be populated if they are under a configured size threshold.
    */
    'fullOutputs'?: CoreLiteralMap;
    /**
    * Optional Workflow closure for a dynamically generated workflow, in the case this node yields a dynamic workflow we return its structure here.
    */
    'dynamicWorkflow'?: FlyteidladminDynamicWorkflowNodeMetadata;
    'flyteUrls'?: AdminFlyteURLs;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "inputs",
            "baseName": "inputs",
            "type": "AdminUrlBlob"
        },
        {
            "name": "outputs",
            "baseName": "outputs",
            "type": "AdminUrlBlob"
        },
        {
            "name": "fullInputs",
            "baseName": "full_inputs",
            "type": "CoreLiteralMap"
        },
        {
            "name": "fullOutputs",
            "baseName": "full_outputs",
            "type": "CoreLiteralMap"
        },
        {
            "name": "dynamicWorkflow",
            "baseName": "dynamic_workflow",
            "type": "FlyteidladminDynamicWorkflowNodeMetadata"
        },
        {
            "name": "flyteUrls",
            "baseName": "flyte_urls",
            "type": "AdminFlyteURLs"
        }    ];

    static getAttributeTypeMap() {
        return AdminNodeExecutionGetDataResponse.attributeTypeMap;
    }
}

export class AdminNodeExecutionList {
    'nodeExecutions'?: Array<FlyteidladminNodeExecution>;
    /**
    * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nodeExecutions",
            "baseName": "node_executions",
            "type": "Array<FlyteidladminNodeExecution>"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminNodeExecutionList.attributeTypeMap;
    }
}

export class AdminNodeExecutionMetaData {
    /**
    * Node executions are grouped depending on retries of the parent Retry group is unique within the context of a parent node.
    */
    'retryGroup'?: string;
    /**
    * Boolean flag indicating if the node has child nodes under it This can be true when a node contains a dynamic workflow which then produces child nodes.
    */
    'isParentNode'?: boolean;
    'specNodeId'?: string;
    /**
    * Boolean flag indicating if the node has contains a dynamic workflow which then produces child nodes. This is to distinguish between subworkflows and dynamic workflows which can both have is_parent_node as true.
    */
    'isDynamic'?: boolean;
    /**
    * Boolean flag indicating if the node is an array node. This is intended to uniquely identify array nodes from other nodes which can have is_parent_node as true.
    */
    'isArray'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retryGroup",
            "baseName": "retry_group",
            "type": "string"
        },
        {
            "name": "isParentNode",
            "baseName": "is_parent_node",
            "type": "boolean"
        },
        {
            "name": "specNodeId",
            "baseName": "spec_node_id",
            "type": "string"
        },
        {
            "name": "isDynamic",
            "baseName": "is_dynamic",
            "type": "boolean"
        },
        {
            "name": "isArray",
            "baseName": "is_array",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AdminNodeExecutionMetaData.attributeTypeMap;
    }
}

/**
* Represents a structure for notifications based on execution status. The notification content is configured within flyte admin but can be templatized. Future iterations could expose configuring notifications with custom content.
*/
export class AdminNotification {
    'phases'?: Array<CoreWorkflowExecutionPhase>;
    'email'?: AdminEmailNotification;
    'pagerDuty'?: AdminPagerDutyNotification;
    'slack'?: AdminSlackNotification;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "phases",
            "baseName": "phases",
            "type": "Array<CoreWorkflowExecutionPhase>"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "AdminEmailNotification"
        },
        {
            "name": "pagerDuty",
            "baseName": "pager_duty",
            "type": "AdminPagerDutyNotification"
        },
        {
            "name": "slack",
            "baseName": "slack",
            "type": "AdminSlackNotification"
        }    ];

    static getAttributeTypeMap() {
        return AdminNotification.attributeTypeMap;
    }
}

export class AdminNotificationList {
    'notifications'?: Array<AdminNotification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "Array<AdminNotification>"
        }    ];

    static getAttributeTypeMap() {
        return AdminNotificationList.attributeTypeMap;
    }
}

/**
* Defines a pager duty notification specification.
*/
export class AdminPagerDutyNotification {
    'recipientsEmail'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipientsEmail",
            "baseName": "recipients_email",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AdminPagerDutyNotification.attributeTypeMap;
    }
}

/**
* This MatchableAttribute configures selecting alternate plugin implementations for a given task type. In addition to an override implementation a selection of fallbacks can be provided or other modes for handling cases where the desired plugin override is not enabled in a given Flyte deployment.
*/
export class AdminPluginOverride {
    /**
    * A predefined yet extensible Task type identifier.
    */
    'taskType'?: string;
    /**
    * A set of plugin ids which should handle tasks of this type instead of the default registered plugin. The list will be tried in order until a plugin is found with that id.
    */
    'pluginId'?: Array<string>;
    /**
    * Defines the behavior when no plugin from the plugin_id list is not found.
    */
    'missingPluginBehavior'?: PluginOverrideMissingPluginBehavior;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taskType",
            "baseName": "task_type",
            "type": "string"
        },
        {
            "name": "pluginId",
            "baseName": "plugin_id",
            "type": "Array<string>"
        },
        {
            "name": "missingPluginBehavior",
            "baseName": "missing_plugin_behavior",
            "type": "PluginOverrideMissingPluginBehavior"
        }    ];

    static getAttributeTypeMap() {
        return AdminPluginOverride.attributeTypeMap;
    }
}

export class AdminPluginOverrides {
    'overrides'?: Array<AdminPluginOverride>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "overrides",
            "baseName": "overrides",
            "type": "Array<AdminPluginOverride>"
        }    ];

    static getAttributeTypeMap() {
        return AdminPluginOverrides.attributeTypeMap;
    }
}

/**
* Top-level namespace used to classify different entities like workflows and executions.
*/
export class AdminProject {
    /**
    * Globally unique project name.
    */
    'id'?: string;
    /**
    * Display name.
    */
    'name'?: string;
    'domains'?: Array<AdminDomain>;
    'description'?: string;
    /**
    * Leverage Labels from flyteidl.admin.common.proto to tag projects with ownership information.
    */
    'labels'?: AdminLabels;
    'state'?: ProjectProjectState;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "domains",
            "baseName": "domains",
            "type": "Array<AdminDomain>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "AdminLabels"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "ProjectProjectState"
        }    ];

    static getAttributeTypeMap() {
        return AdminProject.attributeTypeMap;
    }
}

export class AdminProjectAttributes {
    /**
    * Unique project id for which this set of attributes will be applied.
    */
    'project'?: string;
    'matchingAttributes'?: AdminMatchingAttributes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "matchingAttributes",
            "baseName": "matching_attributes",
            "type": "AdminMatchingAttributes"
        }    ];

    static getAttributeTypeMap() {
        return AdminProjectAttributes.attributeTypeMap;
    }
}

export class AdminProjectAttributesDeleteRequest {
    'project'?: string;
    'resourceType'?: AdminMatchableResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "resourceType",
            "baseName": "resource_type",
            "type": "AdminMatchableResource"
        }    ];

    static getAttributeTypeMap() {
        return AdminProjectAttributesDeleteRequest.attributeTypeMap;
    }
}

/**
* Purposefully empty, may be populated in the future.
*/
export class AdminProjectAttributesDeleteResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminProjectAttributesDeleteResponse.attributeTypeMap;
    }
}

export class AdminProjectAttributesGetResponse {
    'attributes'?: AdminProjectAttributes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "AdminProjectAttributes"
        }    ];

    static getAttributeTypeMap() {
        return AdminProjectAttributesGetResponse.attributeTypeMap;
    }
}

export class AdminProjectAttributesUpdateRequest {
    'attributes'?: AdminProjectAttributes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "AdminProjectAttributes"
        }    ];

    static getAttributeTypeMap() {
        return AdminProjectAttributesUpdateRequest.attributeTypeMap;
    }
}

/**
* Purposefully empty, may be populated in the future.
*/
export class AdminProjectAttributesUpdateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminProjectAttributesUpdateResponse.attributeTypeMap;
    }
}

export class AdminProjectDomainAttributes {
    /**
    * Unique project id for which this set of attributes will be applied.
    */
    'project'?: string;
    /**
    * Unique domain id for which this set of attributes will be applied.
    */
    'domain'?: string;
    'matchingAttributes'?: AdminMatchingAttributes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "matchingAttributes",
            "baseName": "matching_attributes",
            "type": "AdminMatchingAttributes"
        }    ];

    static getAttributeTypeMap() {
        return AdminProjectDomainAttributes.attributeTypeMap;
    }
}

export class AdminProjectDomainAttributesDeleteRequest {
    'project'?: string;
    'domain'?: string;
    'resourceType'?: AdminMatchableResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "resourceType",
            "baseName": "resource_type",
            "type": "AdminMatchableResource"
        }    ];

    static getAttributeTypeMap() {
        return AdminProjectDomainAttributesDeleteRequest.attributeTypeMap;
    }
}

/**
* Purposefully empty, may be populated in the future.
*/
export class AdminProjectDomainAttributesDeleteResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminProjectDomainAttributesDeleteResponse.attributeTypeMap;
    }
}

export class AdminProjectDomainAttributesGetResponse {
    'attributes'?: AdminProjectDomainAttributes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "AdminProjectDomainAttributes"
        }    ];

    static getAttributeTypeMap() {
        return AdminProjectDomainAttributesGetResponse.attributeTypeMap;
    }
}

export class AdminProjectDomainAttributesUpdateRequest {
    'attributes'?: AdminProjectDomainAttributes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "AdminProjectDomainAttributes"
        }    ];

    static getAttributeTypeMap() {
        return AdminProjectDomainAttributesUpdateRequest.attributeTypeMap;
    }
}

/**
* Purposefully empty, may be populated in the future.
*/
export class AdminProjectDomainAttributesUpdateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminProjectDomainAttributesUpdateResponse.attributeTypeMap;
    }
}

export class AdminProjectRegisterRequest {
    'project'?: AdminProject;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "AdminProject"
        }    ];

    static getAttributeTypeMap() {
        return AdminProjectRegisterRequest.attributeTypeMap;
    }
}

/**
* Purposefully empty, may be updated in the future.
*/
export class AdminProjectRegisterResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminProjectRegisterResponse.attributeTypeMap;
    }
}

/**
* Purposefully empty, may be updated in the future.
*/
export class AdminProjectUpdateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminProjectUpdateResponse.attributeTypeMap;
    }
}

export class AdminProjects {
    'projects'?: Array<AdminProject>;
    /**
    * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Array<AdminProject>"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminProjects.attributeTypeMap;
    }
}

/**
* Encapsulates user settings pertaining to offloaded data (i.e. Blobs, Schema, query data, etc.). See https://github.com/flyteorg/flyte/issues/211 for more background information.
*/
export class AdminRawOutputDataConfig {
    'outputLocationPrefix'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "outputLocationPrefix",
            "baseName": "output_location_prefix",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminRawOutputDataConfig.attributeTypeMap;
    }
}

/**
* Reason is a single message annotated with a timestamp to indicate the instant the reason occurred.
*/
export class AdminReason {
    /**
    * occurred_at is the timestamp indicating the instant that this reason happened.
    */
    'occurredAt'?: Date;
    /**
    * message is the explanation for the most recent phase transition or status update.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "occurredAt",
            "baseName": "occurred_at",
            "type": "Date"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminReason.attributeTypeMap;
    }
}

/**
* Defines complete set of information required to trigger an execution on a schedule.
*/
export class AdminSchedule {
    'cronExpression'?: string;
    'rate'?: AdminFixedRate;
    'cronSchedule'?: AdminCronSchedule;
    /**
    * Name of the input variable that the kickoff time will be supplied to when the workflow is kicked off.
    */
    'kickoffTimeInputArg'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cronExpression",
            "baseName": "cron_expression",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "AdminFixedRate"
        },
        {
            "name": "cronSchedule",
            "baseName": "cron_schedule",
            "type": "AdminCronSchedule"
        },
        {
            "name": "kickoffTimeInputArg",
            "baseName": "kickoff_time_input_arg",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminSchedule.attributeTypeMap;
    }
}

/**
* Defines a slack notification specification.
*/
export class AdminSlackNotification {
    'recipientsEmail'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipientsEmail",
            "baseName": "recipients_email",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AdminSlackNotification.attributeTypeMap;
    }
}

/**
* Specifies sort ordering in a list request.
*/
export class AdminSort {
    'key'?: string;
    'direction'?: SortDirection;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "direction",
            "baseName": "direction",
            "type": "SortDirection"
        }    ];

    static getAttributeTypeMap() {
        return AdminSort.attributeTypeMap;
    }
}

export class AdminSourceCode {
    'link'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminSourceCode.attributeTypeMap;
    }
}

/**
* Represents system, rather than user-facing, metadata about an execution.
*/
export class AdminSystemMetadata {
    /**
    * Which execution cluster this execution ran on.
    */
    'executionCluster'?: string;
    /**
    * Which kubernetes namespace the execution ran under.
    */
    'namespace'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "executionCluster",
            "baseName": "execution_cluster",
            "type": "string"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminSystemMetadata.attributeTypeMap;
    }
}

/**
* Flyte workflows are composed of many ordered tasks. That is small, reusable, self-contained logical blocks arranged to process workflow inputs and produce a deterministic set of outputs. Tasks can come in many varieties tuned for specialized behavior.
*/
export class AdminTask {
    /**
    * id represents the unique identifier of the task.
    */
    'id'?: CoreIdentifier;
    /**
    * closure encapsulates all the fields that maps to a compiled version of the task.
    */
    'closure'?: AdminTaskClosure;
    /**
    * One-liner overview of the entity.
    */
    'shortDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "closure",
            "baseName": "closure",
            "type": "AdminTaskClosure"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminTask.attributeTypeMap;
    }
}

/**
* Compute task attributes which include values derived from the TaskSpec, as well as plugin-specific data and task metadata.
*/
export class AdminTaskClosure {
    /**
    * Represents the compiled representation of the task from the specification provided.
    */
    'compiledTask'?: CoreCompiledTask;
    /**
    * Time at which the task was created.
    */
    'createdAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "compiledTask",
            "baseName": "compiled_task",
            "type": "CoreCompiledTask"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return AdminTaskClosure.attributeTypeMap;
    }
}

/**
* Container for task execution details and results.
*/
export class AdminTaskExecutionClosure {
    /**
    * Path to remote data store where output blob is stored if the execution succeeded (and produced outputs). DEPRECATED. Use GetTaskExecutionData to fetch output data instead.
    */
    'outputUri'?: string;
    /**
    * Error information for the task execution. Populated if the execution failed.
    */
    'error'?: CoreExecutionError;
    /**
    * Raw output data produced by this task execution. DEPRECATED. Use GetTaskExecutionData to fetch output data instead.
    */
    'outputData'?: CoreLiteralMap;
    /**
    * The last recorded phase for this task execution.
    */
    'phase'?: CoreTaskExecutionPhase;
    /**
    * Detailed log information output by the task execution.
    */
    'logs'?: Array<CoreTaskLog>;
    /**
    * Time at which the task execution began running.
    */
    'startedAt'?: Date;
    /**
    * The amount of time the task execution spent running.
    */
    'duration'?: string;
    /**
    * Time at which the task execution was created.
    */
    'createdAt'?: Date;
    /**
    * Time at which the task execution was last updated.
    */
    'updatedAt'?: Date;
    /**
    * Custom data specific to the task plugin.
    */
    'customInfo'?: ProtobufStruct;
    /**
    * If there is an explanation for the most recent phase transition, the reason will capture it.
    */
    'reason'?: string;
    /**
    * A predefined yet extensible Task type identifier.
    */
    'taskType'?: string;
    /**
    * Metadata around how a task was executed.
    */
    'metadata'?: FlyteidleventTaskExecutionMetadata;
    /**
    * The event version is used to indicate versioned changes in how data is maintained using this proto message. For example, event_verison > 0 means that maps tasks logs use the TaskExecutionMetadata ExternalResourceInfo fields for each subtask rather than the TaskLog in this message.
    */
    'eventVersion'?: number;
    /**
    * A time-series of the phase transition or update explanations. This, when compared to storing a singular reason as previously done, is much more valuable in visualizing and understanding historical evaluations.
    */
    'reasons'?: Array<AdminReason>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "outputUri",
            "baseName": "output_uri",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "CoreExecutionError"
        },
        {
            "name": "outputData",
            "baseName": "output_data",
            "type": "CoreLiteralMap"
        },
        {
            "name": "phase",
            "baseName": "phase",
            "type": "CoreTaskExecutionPhase"
        },
        {
            "name": "logs",
            "baseName": "logs",
            "type": "Array<CoreTaskLog>"
        },
        {
            "name": "startedAt",
            "baseName": "started_at",
            "type": "Date"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "customInfo",
            "baseName": "custom_info",
            "type": "ProtobufStruct"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "taskType",
            "baseName": "task_type",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "FlyteidleventTaskExecutionMetadata"
        },
        {
            "name": "eventVersion",
            "baseName": "event_version",
            "type": "number"
        },
        {
            "name": "reasons",
            "baseName": "reasons",
            "type": "Array<AdminReason>"
        }    ];

    static getAttributeTypeMap() {
        return AdminTaskExecutionClosure.attributeTypeMap;
    }
}

/**
* Request to send a notification that a task execution event has occurred.
*/
export class AdminTaskExecutionEventRequest {
    'requestId'?: string;
    /**
    * Details about the event that occurred.
    */
    'event'?: EventTaskExecutionEvent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "request_id",
            "type": "string"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "EventTaskExecutionEvent"
        }    ];

    static getAttributeTypeMap() {
        return AdminTaskExecutionEventRequest.attributeTypeMap;
    }
}

export class AdminTaskExecutionEventResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminTaskExecutionEventResponse.attributeTypeMap;
    }
}

/**
* Response structure for TaskExecutionGetDataRequest which contains inputs and outputs for a task execution.
*/
export class AdminTaskExecutionGetDataResponse {
    /**
    * Signed url to fetch a core.LiteralMap of task execution inputs. Deprecated: Please use full_inputs instead.
    */
    'inputs'?: AdminUrlBlob;
    /**
    * Signed url to fetch a core.LiteralMap of task execution outputs. Deprecated: Please use full_outputs instead.
    */
    'outputs'?: AdminUrlBlob;
    /**
    * Full_inputs will only be populated if they are under a configured size threshold.
    */
    'fullInputs'?: CoreLiteralMap;
    /**
    * Full_outputs will only be populated if they are under a configured size threshold.
    */
    'fullOutputs'?: CoreLiteralMap;
    'flyteUrls'?: AdminFlyteURLs;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "inputs",
            "baseName": "inputs",
            "type": "AdminUrlBlob"
        },
        {
            "name": "outputs",
            "baseName": "outputs",
            "type": "AdminUrlBlob"
        },
        {
            "name": "fullInputs",
            "baseName": "full_inputs",
            "type": "CoreLiteralMap"
        },
        {
            "name": "fullOutputs",
            "baseName": "full_outputs",
            "type": "CoreLiteralMap"
        },
        {
            "name": "flyteUrls",
            "baseName": "flyte_urls",
            "type": "AdminFlyteURLs"
        }    ];

    static getAttributeTypeMap() {
        return AdminTaskExecutionGetDataResponse.attributeTypeMap;
    }
}

export class AdminTaskExecutionList {
    'taskExecutions'?: Array<FlyteidladminTaskExecution>;
    /**
    * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taskExecutions",
            "baseName": "task_executions",
            "type": "Array<FlyteidladminTaskExecution>"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminTaskExecutionList.attributeTypeMap;
    }
}

export class AdminTaskList {
    /**
    * A list of tasks returned based on the request.
    */
    'tasks'?: Array<AdminTask>;
    /**
    * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tasks",
            "baseName": "tasks",
            "type": "Array<AdminTask>"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminTaskList.attributeTypeMap;
    }
}

/**
* Defines task resource defaults and limits that will be applied at task registration.
*/
export class AdminTaskResourceAttributes {
    'defaults'?: AdminTaskResourceSpec;
    'limits'?: AdminTaskResourceSpec;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaults",
            "baseName": "defaults",
            "type": "AdminTaskResourceSpec"
        },
        {
            "name": "limits",
            "baseName": "limits",
            "type": "AdminTaskResourceSpec"
        }    ];

    static getAttributeTypeMap() {
        return AdminTaskResourceAttributes.attributeTypeMap;
    }
}

/**
* Defines a set of overridable task resource attributes set during task registration.
*/
export class AdminTaskResourceSpec {
    'cpu'?: string;
    'gpu'?: string;
    'memory'?: string;
    'storage'?: string;
    'ephemeralStorage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cpu",
            "baseName": "cpu",
            "type": "string"
        },
        {
            "name": "gpu",
            "baseName": "gpu",
            "type": "string"
        },
        {
            "name": "memory",
            "baseName": "memory",
            "type": "string"
        },
        {
            "name": "storage",
            "baseName": "storage",
            "type": "string"
        },
        {
            "name": "ephemeralStorage",
            "baseName": "ephemeral_storage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminTaskResourceSpec.attributeTypeMap;
    }
}

/**
* Represents a structure that encapsulates the user-configured specification of the task.
*/
export class AdminTaskSpec {
    /**
    * Template of the task that encapsulates all the metadata of the task.
    */
    'template'?: CoreTaskTemplate;
    /**
    * Represents the specification for description entity.
    */
    'description'?: AdminDescriptionEntity;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "template",
            "baseName": "template",
            "type": "CoreTaskTemplate"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "AdminDescriptionEntity"
        }    ];

    static getAttributeTypeMap() {
        return AdminTaskSpec.attributeTypeMap;
    }
}

/**
* Represents a string url and associated metadata used throughout the platform.
*/
export class AdminUrlBlob {
    /**
    * Actual url value.
    */
    'url'?: string;
    /**
    * Represents the size of the file accessible at the above url.
    */
    'bytes'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "bytes",
            "baseName": "bytes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminUrlBlob.attributeTypeMap;
    }
}

export class AdminVersion {
    'build'?: string;
    'version'?: string;
    'buildTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "build",
            "baseName": "Build",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "buildTime",
            "baseName": "BuildTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminVersion.attributeTypeMap;
    }
}

/**
* Represents the workflow structure stored in the Admin A workflow is created by ordering tasks and associating outputs to inputs in order to produce a directed-acyclic execution graph.
*/
export class AdminWorkflow {
    /**
    * id represents the unique identifier of the workflow.
    */
    'id'?: CoreIdentifier;
    /**
    * closure encapsulates all the fields that maps to a compiled version of the workflow.
    */
    'closure'?: AdminWorkflowClosure;
    /**
    * One-liner overview of the entity.
    */
    'shortDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "closure",
            "baseName": "closure",
            "type": "AdminWorkflowClosure"
        },
        {
            "name": "shortDescription",
            "baseName": "short_description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflow.attributeTypeMap;
    }
}

export class AdminWorkflowAttributes {
    /**
    * Unique project id for which this set of attributes will be applied.
    */
    'project'?: string;
    /**
    * Unique domain id for which this set of attributes will be applied.
    */
    'domain'?: string;
    /**
    * Workflow name for which this set of attributes will be applied.
    */
    'workflow'?: string;
    'matchingAttributes'?: AdminMatchingAttributes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "string"
        },
        {
            "name": "matchingAttributes",
            "baseName": "matching_attributes",
            "type": "AdminMatchingAttributes"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowAttributes.attributeTypeMap;
    }
}

export class AdminWorkflowAttributesDeleteRequest {
    'project'?: string;
    'domain'?: string;
    'workflow'?: string;
    'resourceType'?: AdminMatchableResource;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "workflow",
            "baseName": "workflow",
            "type": "string"
        },
        {
            "name": "resourceType",
            "baseName": "resource_type",
            "type": "AdminMatchableResource"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowAttributesDeleteRequest.attributeTypeMap;
    }
}

/**
* Purposefully empty, may be populated in the future.
*/
export class AdminWorkflowAttributesDeleteResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminWorkflowAttributesDeleteResponse.attributeTypeMap;
    }
}

/**
* Response to get an individual workflow attribute override.
*/
export class AdminWorkflowAttributesGetResponse {
    'attributes'?: AdminWorkflowAttributes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "AdminWorkflowAttributes"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowAttributesGetResponse.attributeTypeMap;
    }
}

export class AdminWorkflowAttributesUpdateRequest {
    'attributes'?: AdminWorkflowAttributes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "AdminWorkflowAttributes"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowAttributesUpdateRequest.attributeTypeMap;
    }
}

/**
* Purposefully empty, may be populated in the future.
*/
export class AdminWorkflowAttributesUpdateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminWorkflowAttributesUpdateResponse.attributeTypeMap;
    }
}

/**
* A container holding the compiled workflow produced from the WorkflowSpec and additional metadata.
*/
export class AdminWorkflowClosure {
    /**
    * Represents the compiled representation of the workflow from the specification provided.
    */
    'compiledWorkflow'?: CoreCompiledWorkflowClosure;
    /**
    * Time at which the workflow was created.
    */
    'createdAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "compiledWorkflow",
            "baseName": "compiled_workflow",
            "type": "CoreCompiledWorkflowClosure"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowClosure.attributeTypeMap;
    }
}

export class AdminWorkflowCreateRequest {
    'id'?: CoreIdentifier;
    'spec'?: AdminWorkflowSpec;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "spec",
            "baseName": "spec",
            "type": "AdminWorkflowSpec"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowCreateRequest.attributeTypeMap;
    }
}

export class AdminWorkflowCreateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminWorkflowCreateResponse.attributeTypeMap;
    }
}

/**
* Adds defaults for customizable workflow-execution specifications and overrides.
*/
export class AdminWorkflowExecutionConfig {
    /**
    * Can be used to control the number of parallel nodes to run within the workflow. This is useful to achieve fairness.
    */
    'maxParallelism'?: number;
    /**
    * Indicates security context permissions for executions triggered with this matchable attribute.
    */
    'securityContext'?: CoreSecurityContext;
    /**
    * Encapsulates user settings pertaining to offloaded data (i.e. Blobs, Schema, query data, etc.).
    */
    'rawOutputDataConfig'?: AdminRawOutputDataConfig;
    /**
    * Custom labels to be applied to a triggered execution resource.
    */
    'labels'?: AdminLabels;
    /**
    * Custom annotations to be applied to a triggered execution resource.
    */
    'annotations'?: AdminAnnotations;
    /**
    * Allows for the interruptible flag of a workflow to be overwritten for a single execution. Omitting this field uses the workflow's value as a default. As we need to distinguish between the field not being provided and its default value false, we have to use a wrapper around the bool field.
    */
    'interruptible'?: boolean;
    /**
    * Allows for all cached values of a workflow and its tasks to be overwritten for a single execution. If enabled, all calculations are performed even if cached results would be available, overwriting the stored data once execution finishes successfully.
    */
    'overwriteCache'?: boolean;
    /**
    * Environment variables to be set for the execution.
    */
    'envs'?: AdminEnvs;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "maxParallelism",
            "baseName": "max_parallelism",
            "type": "number"
        },
        {
            "name": "securityContext",
            "baseName": "security_context",
            "type": "CoreSecurityContext"
        },
        {
            "name": "rawOutputDataConfig",
            "baseName": "raw_output_data_config",
            "type": "AdminRawOutputDataConfig"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "AdminLabels"
        },
        {
            "name": "annotations",
            "baseName": "annotations",
            "type": "AdminAnnotations"
        },
        {
            "name": "interruptible",
            "baseName": "interruptible",
            "type": "boolean"
        },
        {
            "name": "overwriteCache",
            "baseName": "overwrite_cache",
            "type": "boolean"
        },
        {
            "name": "envs",
            "baseName": "envs",
            "type": "AdminEnvs"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowExecutionConfig.attributeTypeMap;
    }
}

/**
* Request to send a notification that a workflow execution event has occurred.
*/
export class AdminWorkflowExecutionEventRequest {
    'requestId'?: string;
    /**
    * Details about the event that occurred.
    */
    'event'?: EventWorkflowExecutionEvent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "request_id",
            "type": "string"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "EventWorkflowExecutionEvent"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowExecutionEventRequest.attributeTypeMap;
    }
}

export class AdminWorkflowExecutionEventResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return AdminWorkflowExecutionEventResponse.attributeTypeMap;
    }
}

/**
* Response structure for WorkflowExecutionGetDataRequest which contains inputs and outputs for an execution.
*/
export class AdminWorkflowExecutionGetDataResponse {
    /**
    * Signed url to fetch a core.LiteralMap of execution outputs. Deprecated: Please use full_outputs instead.
    */
    'outputs'?: AdminUrlBlob;
    /**
    * Signed url to fetch a core.LiteralMap of execution inputs. Deprecated: Please use full_inputs instead.
    */
    'inputs'?: AdminUrlBlob;
    /**
    * Full_inputs will only be populated if they are under a configured size threshold.
    */
    'fullInputs'?: CoreLiteralMap;
    /**
    * Full_outputs will only be populated if they are under a configured size threshold.
    */
    'fullOutputs'?: CoreLiteralMap;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "outputs",
            "baseName": "outputs",
            "type": "AdminUrlBlob"
        },
        {
            "name": "inputs",
            "baseName": "inputs",
            "type": "AdminUrlBlob"
        },
        {
            "name": "fullInputs",
            "baseName": "full_inputs",
            "type": "CoreLiteralMap"
        },
        {
            "name": "fullOutputs",
            "baseName": "full_outputs",
            "type": "CoreLiteralMap"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowExecutionGetDataResponse.attributeTypeMap;
    }
}

/**
* WorkflowExecutionGetMetricsResponse represents the response containing metrics for the specified workflow execution.
*/
export class AdminWorkflowExecutionGetMetricsResponse {
    /**
    * Span defines the top-level breakdown of the workflows execution. More precise information is nested in a hierarchical structure using Flyte entity references.
    */
    'span'?: CoreSpan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "span",
            "baseName": "span",
            "type": "CoreSpan"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowExecutionGetMetricsResponse.attributeTypeMap;
    }
}

export class AdminWorkflowList {
    /**
    * A list of workflows returned based on the request.
    */
    'workflows'?: Array<AdminWorkflow>;
    /**
    * In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. If there are no more results, this value will be empty.
    */
    'token'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "workflows",
            "baseName": "workflows",
            "type": "Array<AdminWorkflow>"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowList.attributeTypeMap;
    }
}

/**
* Represents a structure that encapsulates the specification of the workflow.
*/
export class AdminWorkflowSpec {
    /**
    * Template of the task that encapsulates all the metadata of the workflow.
    */
    'template'?: CoreWorkflowTemplate;
    /**
    * Workflows that are embedded into other workflows need to be passed alongside the parent workflow to the propeller compiler (since the compiler doesn't have any knowledge of other workflows - ie, it doesn't reach out to Admin to see other registered workflows).  In fact, subworkflows do not even need to be registered.
    */
    'subWorkflows'?: Array<CoreWorkflowTemplate>;
    /**
    * Represents the specification for description entity.
    */
    'description'?: AdminDescriptionEntity;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "template",
            "baseName": "template",
            "type": "CoreWorkflowTemplate"
        },
        {
            "name": "subWorkflows",
            "baseName": "sub_workflows",
            "type": "Array<CoreWorkflowTemplate>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "AdminDescriptionEntity"
        }    ];

    static getAttributeTypeMap() {
        return AdminWorkflowSpec.attributeTypeMap;
    }
}

export class BlobTypeBlobDimensionality {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return BlobTypeBlobDimensionality.attributeTypeMap;
    }
}

/**
* Indicates the status of a catalog reservation operation.   - RESERVATION_DISABLED: Used to indicate that reservations are disabled  - RESERVATION_ACQUIRED: Used to indicate that a reservation was successfully acquired or extended  - RESERVATION_EXISTS: Used to indicate that an active reservation currently exists  - RESERVATION_RELEASED: Used to indicate that the reservation has been successfully released  - RESERVATION_FAILURE: Used to indicate that a reservation operation resulted in failure
*/
export class CatalogReservationStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CatalogReservationStatus.attributeTypeMap;
    }
}

/**
* - GT: Greater Than  - LT: Less Than
*/
export class ComparisonExpressionOperator {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ComparisonExpressionOperator.attributeTypeMap;
    }
}

/**
* - AND: Conjunction
*/
export class ConjunctionExpressionLogicalOperator {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ConjunctionExpressionLogicalOperator.attributeTypeMap;
    }
}

export class ConnectionSetIdList {
    'ids'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ids",
            "baseName": "ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ConnectionSetIdList.attributeTypeMap;
    }
}

/**
* Architecture-type the container image supports.
*/
export class ContainerArchitecture {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ContainerArchitecture.attributeTypeMap;
    }
}

/**
* Links a variable to an alias.
*/
export class CoreAlias {
    /**
    * Must match one of the output variable names on a node.
    */
    '_var'?: string;
    /**
    * A workflow-level unique alias that downstream nodes can refer to in their input.
    */
    'alias'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_var",
            "baseName": "var",
            "type": "string"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreAlias.attributeTypeMap;
    }
}

/**
* ApproveCondition represents a dependency on an external approval. During execution, this will manifest as a boolean signal with the provided signal_id.
*/
export class CoreApproveCondition {
    /**
    * A unique identifier for the requested boolean signal.
    */
    'signalId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "signalId",
            "baseName": "signal_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreApproveCondition.attributeTypeMap;
    }
}

/**
* ArrayNode is a Flyte node type that simplifies the execution of a sub-node over a list of input values. An ArrayNode can be executed with configurable parallelism (separate from the parent workflow) and can be configured to succeed when a certain number of sub-nodes succeed.
*/
export class CoreArrayNode {
    /**
    * node is the sub-node that will be executed for each element in the array.
    */
    'node'?: CoreNode;
    /**
    * parallelism defines the minimum number of instances to bring up concurrently at any given point. Note that this is an optimistic restriction and that, due to network partitioning or other failures, the actual number of currently running instances might be more. This has to be a positive number if assigned. Default value is size.
    */
    'parallelism'?: number;
    /**
    * min_successes is an absolute number of the minimum number of successful completions of sub-nodes. As soon as this criteria is met, the ArrayNode will be marked as successful and outputs will be computed. This has to be a non-negative number if assigned. Default value is size (if specified).
    */
    'minSuccesses'?: number;
    /**
    * If the array job size is not known beforehand, the min_success_ratio can instead be used to determine when an ArrayNode can be marked successful.
    */
    'minSuccessRatio'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "node",
            "baseName": "node",
            "type": "CoreNode"
        },
        {
            "name": "parallelism",
            "baseName": "parallelism",
            "type": "number"
        },
        {
            "name": "minSuccesses",
            "baseName": "min_successes",
            "type": "number"
        },
        {
            "name": "minSuccessRatio",
            "baseName": "min_success_ratio",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreArrayNode.attributeTypeMap;
    }
}

/**
* A simple byte array with a tag to help different parts of the system communicate about what is in the byte array. It's strongly advisable that consumers of this type define a unique tag and validate the tag before parsing the data.
*/
export class CoreBinary {
    'value'?: string;
    'tag'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreBinary.attributeTypeMap;
    }
}

/**
* An input/output binding of a variable to either static value or a node output.
*/
export class CoreBinding {
    /**
    * Variable name must match an input/output variable of the node.
    */
    '_var'?: string;
    /**
    * Data to use to bind this variable.
    */
    'binding'?: CoreBindingData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_var",
            "baseName": "var",
            "type": "string"
        },
        {
            "name": "binding",
            "baseName": "binding",
            "type": "CoreBindingData"
        }    ];

    static getAttributeTypeMap() {
        return CoreBinding.attributeTypeMap;
    }
}

/**
* Specifies either a simple value or a reference to another output.
*/
export class CoreBindingData {
    /**
    * A simple scalar value.
    */
    'scalar'?: CoreScalar;
    /**
    * A collection of binding data. This allows nesting of binding data to any number of levels.
    */
    'collection'?: CoreBindingDataCollection;
    /**
    * References an output promised by another node.
    */
    'promise'?: CoreOutputReference;
    /**
    * A map of bindings. The key is always a string.
    */
    'map'?: CoreBindingDataMap;
    'union'?: CoreUnionInfo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "scalar",
            "baseName": "scalar",
            "type": "CoreScalar"
        },
        {
            "name": "collection",
            "baseName": "collection",
            "type": "CoreBindingDataCollection"
        },
        {
            "name": "promise",
            "baseName": "promise",
            "type": "CoreOutputReference"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "CoreBindingDataMap"
        },
        {
            "name": "union",
            "baseName": "union",
            "type": "CoreUnionInfo"
        }    ];

    static getAttributeTypeMap() {
        return CoreBindingData.attributeTypeMap;
    }
}

/**
* A collection of BindingData items.
*/
export class CoreBindingDataCollection {
    'bindings'?: Array<CoreBindingData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bindings",
            "baseName": "bindings",
            "type": "Array<CoreBindingData>"
        }    ];

    static getAttributeTypeMap() {
        return CoreBindingDataCollection.attributeTypeMap;
    }
}

/**
* A map of BindingData items.
*/
export class CoreBindingDataMap {
    'bindings'?: { [key: string]: CoreBindingData; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bindings",
            "baseName": "bindings",
            "type": "{ [key: string]: CoreBindingData; }"
        }    ];

    static getAttributeTypeMap() {
        return CoreBindingDataMap.attributeTypeMap;
    }
}

/**
* Refers to an offloaded set of files. It encapsulates the type of the store and a unique uri for where the data is. There are no restrictions on how the uri is formatted since it will depend on how to interact with the store.
*/
export class CoreBlob {
    'metadata'?: CoreBlobMetadata;
    'uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "CoreBlobMetadata"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreBlob.attributeTypeMap;
    }
}

export class CoreBlobMetadata {
    'type'?: CoreBlobType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "CoreBlobType"
        }    ];

    static getAttributeTypeMap() {
        return CoreBlobMetadata.attributeTypeMap;
    }
}

export class CoreBlobType {
    'format'?: string;
    'dimensionality'?: BlobTypeBlobDimensionality;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        },
        {
            "name": "dimensionality",
            "baseName": "dimensionality",
            "type": "BlobTypeBlobDimensionality"
        }    ];

    static getAttributeTypeMap() {
        return CoreBlobType.attributeTypeMap;
    }
}

/**
* Defines a boolean expression tree. It can be a simple or a conjunction expression. Multiple expressions can be combined using a conjunction or a disjunction to result in a final boolean result.
*/
export class CoreBooleanExpression {
    'conjunction'?: CoreConjunctionExpression;
    'comparison'?: CoreComparisonExpression;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "conjunction",
            "baseName": "conjunction",
            "type": "CoreConjunctionExpression"
        },
        {
            "name": "comparison",
            "baseName": "comparison",
            "type": "CoreComparisonExpression"
        }    ];

    static getAttributeTypeMap() {
        return CoreBooleanExpression.attributeTypeMap;
    }
}

/**
* BranchNode is a special node that alter the flow of the workflow graph. It allows the control flow to branch at runtime based on a series of conditions that get evaluated on various parameters (e.g. inputs, primitives).
*/
export class CoreBranchNode {
    'ifElse'?: CoreIfElseBlock;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ifElse",
            "baseName": "if_else",
            "type": "CoreIfElseBlock"
        }    ];

    static getAttributeTypeMap() {
        return CoreBranchNode.attributeTypeMap;
    }
}

export class CoreCatalogArtifactTag {
    'artifactId'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "artifactId",
            "baseName": "artifact_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreCatalogArtifactTag.attributeTypeMap;
    }
}

/**
* - CACHE_DISABLED: Used to indicate that caching was disabled  - CACHE_MISS: Used to indicate that the cache lookup resulted in no matches  - CACHE_HIT: used to indicate that the associated artifact was a result of a previous execution  - CACHE_POPULATED: used to indicate that the resultant artifact was added to the cache  - CACHE_LOOKUP_FAILURE: Used to indicate that cache lookup failed because of an error  - CACHE_PUT_FAILURE: Used to indicate that cache lookup failed because of an error  - CACHE_SKIPPED: Used to indicate the cache lookup was skipped
*/
export class CoreCatalogCacheStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CoreCatalogCacheStatus.attributeTypeMap;
    }
}

export class CoreCatalogMetadata {
    'datasetId'?: CoreIdentifier;
    'artifactTag'?: CoreCatalogArtifactTag;
    'sourceTaskExecution'?: CoreTaskExecutionIdentifier;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "datasetId",
            "baseName": "dataset_id",
            "type": "CoreIdentifier"
        },
        {
            "name": "artifactTag",
            "baseName": "artifact_tag",
            "type": "CoreCatalogArtifactTag"
        },
        {
            "name": "sourceTaskExecution",
            "baseName": "source_task_execution",
            "type": "CoreTaskExecutionIdentifier"
        }    ];

    static getAttributeTypeMap() {
        return CoreCatalogMetadata.attributeTypeMap;
    }
}

/**
* Defines a 2-level tree where the root is a comparison operator and Operands are primitives or known variables. Each expression results in a boolean result.
*/
export class CoreComparisonExpression {
    'operator'?: ComparisonExpressionOperator;
    'leftValue'?: CoreOperand;
    'rightValue'?: CoreOperand;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "operator",
            "baseName": "operator",
            "type": "ComparisonExpressionOperator"
        },
        {
            "name": "leftValue",
            "baseName": "left_value",
            "type": "CoreOperand"
        },
        {
            "name": "rightValue",
            "baseName": "right_value",
            "type": "CoreOperand"
        }    ];

    static getAttributeTypeMap() {
        return CoreComparisonExpression.attributeTypeMap;
    }
}

export class CoreCompiledTask {
    'template'?: CoreTaskTemplate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "template",
            "baseName": "template",
            "type": "CoreTaskTemplate"
        }    ];

    static getAttributeTypeMap() {
        return CoreCompiledTask.attributeTypeMap;
    }
}

export class CoreCompiledWorkflow {
    'template'?: CoreWorkflowTemplate;
    /**
    * For internal use only! This field is used by the system and must not be filled in. Any values set will be ignored.
    */
    'connections'?: CoreConnectionSet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "template",
            "baseName": "template",
            "type": "CoreWorkflowTemplate"
        },
        {
            "name": "connections",
            "baseName": "connections",
            "type": "CoreConnectionSet"
        }    ];

    static getAttributeTypeMap() {
        return CoreCompiledWorkflow.attributeTypeMap;
    }
}

/**
* A Compiled Workflow Closure contains all the information required to start a new execution, or to visualize a workflow and its details. The CompiledWorkflowClosure should always contain a primary workflow, that is the main workflow that will being the execution. All subworkflows are denormalized. WorkflowNodes refer to the workflow identifiers of compiled subworkflows.
*/
export class CoreCompiledWorkflowClosure {
    'primary'?: CoreCompiledWorkflow;
    'subWorkflows'?: Array<CoreCompiledWorkflow>;
    'tasks'?: Array<CoreCompiledTask>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "primary",
            "baseName": "primary",
            "type": "CoreCompiledWorkflow"
        },
        {
            "name": "subWorkflows",
            "baseName": "sub_workflows",
            "type": "Array<CoreCompiledWorkflow>"
        },
        {
            "name": "tasks",
            "baseName": "tasks",
            "type": "Array<CoreCompiledTask>"
        }    ];

    static getAttributeTypeMap() {
        return CoreCompiledWorkflowClosure.attributeTypeMap;
    }
}

/**
* Defines a conjunction expression of two boolean expressions.
*/
export class CoreConjunctionExpression {
    'operator'?: ConjunctionExpressionLogicalOperator;
    'leftExpression'?: CoreBooleanExpression;
    'rightExpression'?: CoreBooleanExpression;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "operator",
            "baseName": "operator",
            "type": "ConjunctionExpressionLogicalOperator"
        },
        {
            "name": "leftExpression",
            "baseName": "left_expression",
            "type": "CoreBooleanExpression"
        },
        {
            "name": "rightExpression",
            "baseName": "right_expression",
            "type": "CoreBooleanExpression"
        }    ];

    static getAttributeTypeMap() {
        return CoreConjunctionExpression.attributeTypeMap;
    }
}

export class CoreConnectionSet {
    'downstream'?: { [key: string]: ConnectionSetIdList; };
    'upstream'?: { [key: string]: ConnectionSetIdList; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "downstream",
            "baseName": "downstream",
            "type": "{ [key: string]: ConnectionSetIdList; }"
        },
        {
            "name": "upstream",
            "baseName": "upstream",
            "type": "{ [key: string]: ConnectionSetIdList; }"
        }    ];

    static getAttributeTypeMap() {
        return CoreConnectionSet.attributeTypeMap;
    }
}

export class CoreContainer {
    'image'?: string;
    /**
    * Command to be executed, if not provided, the default entrypoint in the container image will be used.
    */
    'command'?: Array<string>;
    /**
    * These will default to Flyte given paths. If provided, the system will not append known paths. If the task still needs flyte's inputs and outputs path, add $(FLYTE_INPUT_FILE), $(FLYTE_OUTPUT_FILE) wherever makes sense and the system will populate these before executing the container.
    */
    'args'?: Array<string>;
    /**
    * Container resources requirement as specified by the container engine.
    */
    'resources'?: CoreResources;
    /**
    * Environment variables will be set as the container is starting up.
    */
    'env'?: Array<CoreKeyValuePair>;
    /**
    * Allows extra configs to be available for the container. TODO: elaborate on how configs will become available. Deprecated, please use TaskTemplate.config instead.
    */
    'config'?: Array<CoreKeyValuePair>;
    'ports'?: Array<CoreContainerPort>;
    'dataConfig'?: CoreDataLoadingConfig;
    'architecture'?: ContainerArchitecture;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "command",
            "baseName": "command",
            "type": "Array<string>"
        },
        {
            "name": "args",
            "baseName": "args",
            "type": "Array<string>"
        },
        {
            "name": "resources",
            "baseName": "resources",
            "type": "CoreResources"
        },
        {
            "name": "env",
            "baseName": "env",
            "type": "Array<CoreKeyValuePair>"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "Array<CoreKeyValuePair>"
        },
        {
            "name": "ports",
            "baseName": "ports",
            "type": "Array<CoreContainerPort>"
        },
        {
            "name": "dataConfig",
            "baseName": "data_config",
            "type": "CoreDataLoadingConfig"
        },
        {
            "name": "architecture",
            "baseName": "architecture",
            "type": "ContainerArchitecture"
        }    ];

    static getAttributeTypeMap() {
        return CoreContainer.attributeTypeMap;
    }
}

/**
* Defines port properties for a container.
*/
export class CoreContainerPort {
    /**
    * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
    */
    'containerPort'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "containerPort",
            "baseName": "container_port",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreContainerPort.attributeTypeMap;
    }
}

/**
* This configuration allows executing raw containers in Flyte using the Flyte CoPilot system. Flyte CoPilot, eliminates the needs of flytekit or sdk inside the container. Any inputs required by the users container are side-loaded in the input_path Any outputs generated by the user container - within output_path are automatically uploaded.
*/
export class CoreDataLoadingConfig {
    'enabled'?: boolean;
    'inputPath'?: string;
    'outputPath'?: string;
    'format'?: DataLoadingConfigLiteralMapFormat;
    'ioStrategy'?: CoreIOStrategy;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "inputPath",
            "baseName": "input_path",
            "type": "string"
        },
        {
            "name": "outputPath",
            "baseName": "output_path",
            "type": "string"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "DataLoadingConfigLiteralMapFormat"
        },
        {
            "name": "ioStrategy",
            "baseName": "io_strategy",
            "type": "CoreIOStrategy"
        }    ];

    static getAttributeTypeMap() {
        return CoreDataLoadingConfig.attributeTypeMap;
    }
}

/**
* Enables declaring enum types, with predefined string values For len(values) > 0, the first value in the ordered list is regarded as the default value. If you wish To provide no defaults, make the first value as undefined.
*/
export class CoreEnumType {
    /**
    * Predefined set of enum values.
    */
    'values'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CoreEnumType.attributeTypeMap;
    }
}

/**
* Represents an error thrown from a node.
*/
export class CoreError {
    /**
    * The node id that threw the error.
    */
    'failedNodeId'?: string;
    /**
    * Error message thrown.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "failedNodeId",
            "baseName": "failed_node_id",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreError.attributeTypeMap;
    }
}

/**
* Represents the error message from the execution.
*/
export class CoreExecutionError {
    'code'?: string;
    /**
    * Detailed description of the error - including stack trace.
    */
    'message'?: string;
    'errorUri'?: string;
    'kind'?: ExecutionErrorErrorKind;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "errorUri",
            "baseName": "error_uri",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "ExecutionErrorErrorKind"
        }    ];

    static getAttributeTypeMap() {
        return CoreExecutionError.attributeTypeMap;
    }
}

/**
* Encapsulates all non-standard resources, not captured by v1.ResourceRequirements, to allocate to a task.
*/
export class CoreExtendedResources {
    /**
    * GPU accelerator to select for task. Contains information about device type, and for multi-instance GPUs, the partition size to use.
    */
    'gpuAccelerator'?: CoreGPUAccelerator;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "gpuAccelerator",
            "baseName": "gpu_accelerator",
            "type": "CoreGPUAccelerator"
        }    ];

    static getAttributeTypeMap() {
        return CoreExtendedResources.attributeTypeMap;
    }
}

/**
* Metadata associated with the GPU accelerator to allocate to a task. Contains information about device type, and for multi-instance GPUs, the partition size to use.
*/
export class CoreGPUAccelerator {
    /**
    * This can be any arbitrary string, and should be informed by the labels or taints associated with the nodes in question. Default cloud provider labels typically use the following values: `nvidia-tesla-t4`, `nvidia-tesla-a100`, etc.
    */
    'device'?: string;
    'unpartitioned'?: boolean;
    /**
    * Like `device`, this can be any arbitrary string, and should be informed by the labels or taints associated with the nodes in question. Default cloud provider labels typically use the following values: `1g.5gb`, `2g.10gb`, etc.
    */
    'partitionSize'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "device",
            "baseName": "device",
            "type": "string"
        },
        {
            "name": "unpartitioned",
            "baseName": "unpartitioned",
            "type": "boolean"
        },
        {
            "name": "partitionSize",
            "baseName": "partition_size",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreGPUAccelerator.attributeTypeMap;
    }
}

/**
* GateNode refers to the condition that is required for the gate to successfully complete.
*/
export class CoreGateNode {
    /**
    * ApproveCondition represents a dependency on an external approval provided by a boolean signal.
    */
    'approve'?: CoreApproveCondition;
    /**
    * SignalCondition represents a dependency on an signal.
    */
    'signal'?: CoreSignalCondition;
    /**
    * SleepCondition represents a dependency on waiting for the specified duration.
    */
    'sleep'?: CoreSleepCondition;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approve",
            "baseName": "approve",
            "type": "CoreApproveCondition"
        },
        {
            "name": "signal",
            "baseName": "signal",
            "type": "CoreSignalCondition"
        },
        {
            "name": "sleep",
            "baseName": "sleep",
            "type": "CoreSleepCondition"
        }    ];

    static getAttributeTypeMap() {
        return CoreGateNode.attributeTypeMap;
    }
}

export class CoreIOStrategy {
    'downloadMode'?: IOStrategyDownloadMode;
    'uploadMode'?: IOStrategyUploadMode;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "downloadMode",
            "baseName": "download_mode",
            "type": "IOStrategyDownloadMode"
        },
        {
            "name": "uploadMode",
            "baseName": "upload_mode",
            "type": "IOStrategyUploadMode"
        }    ];

    static getAttributeTypeMap() {
        return CoreIOStrategy.attributeTypeMap;
    }
}

/**
* Encapsulation of fields that uniquely identifies a Flyte resource.
*/
export class CoreIdentifier {
    /**
    * Identifies the specific type of resource that this identifier corresponds to.
    */
    'resourceType'?: CoreResourceType;
    /**
    * Name of the project the resource belongs to.
    */
    'project'?: string;
    /**
    * Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
    */
    'domain'?: string;
    /**
    * User provided value for the resource.
    */
    'name'?: string;
    /**
    * Specific version of the resource.
    */
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resourceType",
            "baseName": "resource_type",
            "type": "CoreResourceType"
        },
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreIdentifier.attributeTypeMap;
    }
}

/**
* Identity encapsulates the various security identities a task can run as. It's up to the underlying plugin to pick the right identity for the execution environment.
*/
export class CoreIdentity {
    /**
    * iam_role references the fully qualified name of Identity & Access Management role to impersonate.
    */
    'iamRole'?: string;
    /**
    * k8s_service_account references a kubernetes service account to impersonate.
    */
    'k8sServiceAccount'?: string;
    /**
    * oauth2_client references an oauth2 client. Backend plugins can use this information to impersonate the client when making external calls.
    */
    'oauth2Client'?: CoreOAuth2Client;
    'executionIdentity'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "iamRole",
            "baseName": "iam_role",
            "type": "string"
        },
        {
            "name": "k8sServiceAccount",
            "baseName": "k8s_service_account",
            "type": "string"
        },
        {
            "name": "oauth2Client",
            "baseName": "oauth2_client",
            "type": "CoreOAuth2Client"
        },
        {
            "name": "executionIdentity",
            "baseName": "execution_identity",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreIdentity.attributeTypeMap;
    }
}

/**
* Defines a condition and the execution unit that should be executed if the condition is satisfied.
*/
export class CoreIfBlock {
    'condition'?: CoreBooleanExpression;
    'thenNode'?: CoreNode;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "condition",
            "baseName": "condition",
            "type": "CoreBooleanExpression"
        },
        {
            "name": "thenNode",
            "baseName": "then_node",
            "type": "CoreNode"
        }    ];

    static getAttributeTypeMap() {
        return CoreIfBlock.attributeTypeMap;
    }
}

/**
* Defines a series of if/else blocks. The first branch whose condition evaluates to true is the one to execute. If no conditions were satisfied, the else_node or the error will execute.
*/
export class CoreIfElseBlock {
    /**
    * +required. First condition to evaluate.
    */
    '_case'?: CoreIfBlock;
    /**
    * +optional. Additional branches to evaluate.
    */
    'other'?: Array<CoreIfBlock>;
    /**
    * The node to execute in case none of the branches were taken.
    */
    'elseNode'?: CoreNode;
    /**
    * An error to throw in case none of the branches were taken.
    */
    'error'?: CoreError;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_case",
            "baseName": "case",
            "type": "CoreIfBlock"
        },
        {
            "name": "other",
            "baseName": "other",
            "type": "Array<CoreIfBlock>"
        },
        {
            "name": "elseNode",
            "baseName": "else_node",
            "type": "CoreNode"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "CoreError"
        }    ];

    static getAttributeTypeMap() {
        return CoreIfElseBlock.attributeTypeMap;
    }
}

/**
* Metadata for building a kubernetes object when a task is executed.
*/
export class CoreK8sObjectMetadata {
    /**
    * Optional labels to add to the pod definition.
    */
    'labels'?: { [key: string]: string; };
    /**
    * Optional annotations to add to the pod definition.
    */
    'annotations'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "labels",
            "baseName": "labels",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "annotations",
            "baseName": "annotations",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return CoreK8sObjectMetadata.attributeTypeMap;
    }
}

/**
* Defines a pod spec and additional pod metadata that is created when a task is executed.
*/
export class CoreK8sPod {
    /**
    * Contains additional metadata for building a kubernetes pod.
    */
    'metadata'?: CoreK8sObjectMetadata;
    'podSpec'?: ProtobufStruct;
    'dataConfig'?: CoreDataLoadingConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "CoreK8sObjectMetadata"
        },
        {
            "name": "podSpec",
            "baseName": "pod_spec",
            "type": "ProtobufStruct"
        },
        {
            "name": "dataConfig",
            "baseName": "data_config",
            "type": "CoreDataLoadingConfig"
        }    ];

    static getAttributeTypeMap() {
        return CoreK8sPod.attributeTypeMap;
    }
}

/**
* A generic key value pair.
*/
export class CoreKeyValuePair {
    /**
    * required.
    */
    'key'?: string;
    /**
    * +optional.
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreKeyValuePair.attributeTypeMap;
    }
}

/**
* A simple value. This supports any level of nesting (e.g. array of array of array of Blobs) as well as simple primitives.
*/
export class CoreLiteral {
    /**
    * A simple value.
    */
    'scalar'?: CoreScalar;
    /**
    * A collection of literals to allow nesting.
    */
    'collection'?: CoreLiteralCollection;
    /**
    * A map of strings to literals.
    */
    'map'?: CoreLiteralMap;
    'hash'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "scalar",
            "baseName": "scalar",
            "type": "CoreScalar"
        },
        {
            "name": "collection",
            "baseName": "collection",
            "type": "CoreLiteralCollection"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "CoreLiteralMap"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreLiteral.attributeTypeMap;
    }
}

/**
* A collection of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
*/
export class CoreLiteralCollection {
    'literals'?: Array<CoreLiteral>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "literals",
            "baseName": "literals",
            "type": "Array<CoreLiteral>"
        }    ];

    static getAttributeTypeMap() {
        return CoreLiteralCollection.attributeTypeMap;
    }
}

/**
* A map of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
*/
export class CoreLiteralMap {
    'literals'?: { [key: string]: CoreLiteral; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "literals",
            "baseName": "literals",
            "type": "{ [key: string]: CoreLiteral; }"
        }    ];

    static getAttributeTypeMap() {
        return CoreLiteralMap.attributeTypeMap;
    }
}

/**
* Defines a strong type to allow type checking between interfaces.
*/
export class CoreLiteralType {
    /**
    * A simple type that can be compared one-to-one with another.
    */
    'simple'?: CoreSimpleType;
    /**
    * A complex type that requires matching of inner fields.
    */
    'schema'?: CoreSchemaType;
    /**
    * Defines the type of the value of a collection. Only homogeneous collections are allowed.
    */
    'collectionType'?: CoreLiteralType;
    /**
    * Defines the type of the value of a map type. The type of the key is always a string.
    */
    'mapValueType'?: CoreLiteralType;
    /**
    * A blob might have specialized implementation details depending on associated metadata.
    */
    'blob'?: CoreBlobType;
    /**
    * Defines an enum with pre-defined string values.
    */
    'enumType'?: CoreEnumType;
    'structuredDatasetType'?: CoreStructuredDatasetType;
    /**
    * Defines an union type with pre-defined LiteralTypes.
    */
    'unionType'?: CoreUnionType;
    /**
    * This field contains type metadata that is descriptive of the type, but is NOT considered in type-checking.  This might be used by consumers to identify special behavior or display extended information for the type.
    */
    'metadata'?: ProtobufStruct;
    /**
    * This field contains arbitrary data that might have special semantic meaning for the client but does not effect internal flyte behavior.
    */
    'annotation'?: CoreTypeAnnotation;
    /**
    * Hints to improve type matching.
    */
    'structure'?: CoreTypeStructure;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "simple",
            "baseName": "simple",
            "type": "CoreSimpleType"
        },
        {
            "name": "schema",
            "baseName": "schema",
            "type": "CoreSchemaType"
        },
        {
            "name": "collectionType",
            "baseName": "collection_type",
            "type": "CoreLiteralType"
        },
        {
            "name": "mapValueType",
            "baseName": "map_value_type",
            "type": "CoreLiteralType"
        },
        {
            "name": "blob",
            "baseName": "blob",
            "type": "CoreBlobType"
        },
        {
            "name": "enumType",
            "baseName": "enum_type",
            "type": "CoreEnumType"
        },
        {
            "name": "structuredDatasetType",
            "baseName": "structured_dataset_type",
            "type": "CoreStructuredDatasetType"
        },
        {
            "name": "unionType",
            "baseName": "union_type",
            "type": "CoreUnionType"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ProtobufStruct"
        },
        {
            "name": "annotation",
            "baseName": "annotation",
            "type": "CoreTypeAnnotation"
        },
        {
            "name": "structure",
            "baseName": "structure",
            "type": "CoreTypeStructure"
        }    ];

    static getAttributeTypeMap() {
        return CoreLiteralType.attributeTypeMap;
    }
}

/**
* A Workflow graph Node. One unit of execution in the graph. Each node can be linked to a Task, a Workflow or a branch node.
*/
export class CoreNode {
    /**
    * A workflow-level unique identifier that identifies this node in the workflow. 'inputs' and 'outputs' are reserved node ids that cannot be used by other nodes.
    */
    'id'?: string;
    /**
    * Extra metadata about the node.
    */
    'metadata'?: CoreNodeMetadata;
    /**
    * Specifies how to bind the underlying interface's inputs. All required inputs specified in the underlying interface must be fulfilled.
    */
    'inputs'?: Array<CoreBinding>;
    /**
    * +optional Specifies execution dependency for this node ensuring it will only get scheduled to run after all its upstream nodes have completed. This node will have an implicit dependency on any node that appears in inputs field.
    */
    'upstreamNodeIds'?: Array<string>;
    /**
    * +optional. A node can define aliases for a subset of its outputs. This is particularly useful if different nodes need to conform to the same interface (e.g. all branches in a branch node). Downstream nodes must refer to this nodes outputs using the alias if one's specified.
    */
    'outputAliases'?: Array<CoreAlias>;
    /**
    * Information about the Task to execute in this node.
    */
    'taskNode'?: CoreTaskNode;
    /**
    * Information about the Workflow to execute in this mode.
    */
    'workflowNode'?: CoreWorkflowNode;
    /**
    * Information about the branch node to evaluate in this node.
    */
    'branchNode'?: CoreBranchNode;
    /**
    * Information about the condition to evaluate in this node.
    */
    'gateNode'?: CoreGateNode;
    /**
    * Information about the sub-node executions for each value in the list of this nodes inputs values.
    */
    'arrayNode'?: CoreArrayNode;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "CoreNodeMetadata"
        },
        {
            "name": "inputs",
            "baseName": "inputs",
            "type": "Array<CoreBinding>"
        },
        {
            "name": "upstreamNodeIds",
            "baseName": "upstream_node_ids",
            "type": "Array<string>"
        },
        {
            "name": "outputAliases",
            "baseName": "output_aliases",
            "type": "Array<CoreAlias>"
        },
        {
            "name": "taskNode",
            "baseName": "task_node",
            "type": "CoreTaskNode"
        },
        {
            "name": "workflowNode",
            "baseName": "workflow_node",
            "type": "CoreWorkflowNode"
        },
        {
            "name": "branchNode",
            "baseName": "branch_node",
            "type": "CoreBranchNode"
        },
        {
            "name": "gateNode",
            "baseName": "gate_node",
            "type": "CoreGateNode"
        },
        {
            "name": "arrayNode",
            "baseName": "array_node",
            "type": "CoreArrayNode"
        }    ];

    static getAttributeTypeMap() {
        return CoreNode.attributeTypeMap;
    }
}

/**
* Encapsulation of fields that identify a Flyte node execution entity.
*/
export class CoreNodeExecutionIdentifier {
    'nodeId'?: string;
    'executionId'?: CoreWorkflowExecutionIdentifier;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nodeId",
            "baseName": "node_id",
            "type": "string"
        },
        {
            "name": "executionId",
            "baseName": "execution_id",
            "type": "CoreWorkflowExecutionIdentifier"
        }    ];

    static getAttributeTypeMap() {
        return CoreNodeExecutionIdentifier.attributeTypeMap;
    }
}

export class CoreNodeExecutionPhase {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CoreNodeExecutionPhase.attributeTypeMap;
    }
}

/**
* Defines extra information about the Node.
*/
export class CoreNodeMetadata {
    'name'?: string;
    /**
    * The overall timeout of a task.
    */
    'timeout'?: string;
    /**
    * Number of retries per task.
    */
    'retries'?: CoreRetryStrategy;
    'interruptible'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "string"
        },
        {
            "name": "retries",
            "baseName": "retries",
            "type": "CoreRetryStrategy"
        },
        {
            "name": "interruptible",
            "baseName": "interruptible",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CoreNodeMetadata.attributeTypeMap;
    }
}

/**
* OAuth2Client encapsulates OAuth2 Client Credentials to be used when making calls on behalf of that task.
*/
export class CoreOAuth2Client {
    'clientId'?: string;
    'clientSecret'?: CoreSecret;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "clientSecret",
            "baseName": "client_secret",
            "type": "CoreSecret"
        }    ];

    static getAttributeTypeMap() {
        return CoreOAuth2Client.attributeTypeMap;
    }
}

/**
* OAuth2TokenRequest encapsulates information needed to request an OAuth2 token. FLYTE_TOKENS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if tokens are passed through environment variables. FLYTE_TOKENS_PATH_PREFIX will be passed to indicate the prefix of the path where secrets will be mounted if tokens are passed through file mounts.
*/
export class CoreOAuth2TokenRequest {
    'name'?: string;
    'type'?: CoreOAuth2TokenRequestType;
    'client'?: CoreOAuth2Client;
    'idpDiscoveryEndpoint'?: string;
    'tokenEndpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CoreOAuth2TokenRequestType"
        },
        {
            "name": "client",
            "baseName": "client",
            "type": "CoreOAuth2Client"
        },
        {
            "name": "idpDiscoveryEndpoint",
            "baseName": "idp_discovery_endpoint",
            "type": "string"
        },
        {
            "name": "tokenEndpoint",
            "baseName": "token_endpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreOAuth2TokenRequest.attributeTypeMap;
    }
}

/**
* Type of the token requested.   - CLIENT_CREDENTIALS: CLIENT_CREDENTIALS indicates a 2-legged OAuth token requested using client credentials.
*/
export class CoreOAuth2TokenRequestType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CoreOAuth2TokenRequestType.attributeTypeMap;
    }
}

/**
* Defines an operand to a comparison expression.
*/
export class CoreOperand {
    'primitive'?: CorePrimitive;
    '_var'?: string;
    'scalar'?: CoreScalar;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "primitive",
            "baseName": "primitive",
            "type": "CorePrimitive"
        },
        {
            "name": "_var",
            "baseName": "var",
            "type": "string"
        },
        {
            "name": "scalar",
            "baseName": "scalar",
            "type": "CoreScalar"
        }    ];

    static getAttributeTypeMap() {
        return CoreOperand.attributeTypeMap;
    }
}

/**
* A reference to an output produced by a node. The type can be retrieved -and validated- from the underlying interface of the node.
*/
export class CoreOutputReference {
    /**
    * Node id must exist at the graph layer.
    */
    'nodeId'?: string;
    /**
    * Variable name must refer to an output variable for the node.
    */
    '_var'?: string;
    'attrPath'?: Array<CorePromiseAttribute>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nodeId",
            "baseName": "node_id",
            "type": "string"
        },
        {
            "name": "_var",
            "baseName": "var",
            "type": "string"
        },
        {
            "name": "attrPath",
            "baseName": "attr_path",
            "type": "Array<CorePromiseAttribute>"
        }    ];

    static getAttributeTypeMap() {
        return CoreOutputReference.attributeTypeMap;
    }
}

/**
* A parameter is used as input to a launch plan and has the special ability to have a default value or mark itself as required.
*/
export class CoreParameter {
    /**
    * +required Variable. Defines the type of the variable backing this parameter.
    */
    '_var'?: CoreVariable;
    /**
    * Defines a default value that has to match the variable type defined.
    */
    '_default'?: CoreLiteral;
    /**
    * +optional, is this value required to be filled.
    */
    'required'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_var",
            "baseName": "var",
            "type": "CoreVariable"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "CoreLiteral"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CoreParameter.attributeTypeMap;
    }
}

/**
* A map of Parameters.
*/
export class CoreParameterMap {
    /**
    * Defines a map of parameter names to parameters.
    */
    'parameters'?: { [key: string]: CoreParameter; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "{ [key: string]: CoreParameter; }"
        }    ];

    static getAttributeTypeMap() {
        return CoreParameterMap.attributeTypeMap;
    }
}

export class CorePrimitive {
    'integer'?: string;
    'floatValue'?: number;
    'stringValue'?: string;
    '_boolean'?: boolean;
    'datetime'?: Date;
    'duration'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "integer",
            "baseName": "integer",
            "type": "string"
        },
        {
            "name": "floatValue",
            "baseName": "float_value",
            "type": "number"
        },
        {
            "name": "stringValue",
            "baseName": "string_value",
            "type": "string"
        },
        {
            "name": "_boolean",
            "baseName": "boolean",
            "type": "boolean"
        },
        {
            "name": "datetime",
            "baseName": "datetime",
            "type": "Date"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CorePrimitive.attributeTypeMap;
    }
}

export class CorePromiseAttribute {
    'stringValue'?: string;
    'intValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stringValue",
            "baseName": "string_value",
            "type": "string"
        },
        {
            "name": "intValue",
            "baseName": "int_value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CorePromiseAttribute.attributeTypeMap;
    }
}

/**
* Indicates the priority of an execution.
*/
export class CoreQualityOfService {
    'tier'?: QualityOfServiceTier;
    'spec'?: CoreQualityOfServiceSpec;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tier",
            "baseName": "tier",
            "type": "QualityOfServiceTier"
        },
        {
            "name": "spec",
            "baseName": "spec",
            "type": "CoreQualityOfServiceSpec"
        }    ];

    static getAttributeTypeMap() {
        return CoreQualityOfService.attributeTypeMap;
    }
}

/**
* Represents customized execution run-time attributes.
*/
export class CoreQualityOfServiceSpec {
    /**
    * Indicates how much queueing delay an execution can tolerate.
    */
    'queueingBudget'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "queueingBudget",
            "baseName": "queueing_budget",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreQualityOfServiceSpec.attributeTypeMap;
    }
}

/**
* Indicates a resource type within Flyte.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
*/
export class CoreResourceType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CoreResourceType.attributeTypeMap;
    }
}

/**
* A customizable interface to convey resources requested for a container. This can be interpreted differently for different container engines.
*/
export class CoreResources {
    /**
    * The desired set of resources requested. ResourceNames must be unique within the list.
    */
    'requests'?: Array<ResourcesResourceEntry>;
    /**
    * Defines a set of bounds (e.g. min/max) within which the task can reliably run. ResourceNames must be unique within the list.
    */
    'limits'?: Array<ResourcesResourceEntry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requests",
            "baseName": "requests",
            "type": "Array<ResourcesResourceEntry>"
        },
        {
            "name": "limits",
            "baseName": "limits",
            "type": "Array<ResourcesResourceEntry>"
        }    ];

    static getAttributeTypeMap() {
        return CoreResources.attributeTypeMap;
    }
}

/**
* Retry strategy associated with an executable unit.
*/
export class CoreRetryStrategy {
    /**
    * Number of retries. Retries will be consumed when the job fails with a recoverable error. The number of retries must be less than or equals to 10.
    */
    'retries'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "retries",
            "baseName": "retries",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreRetryStrategy.attributeTypeMap;
    }
}

/**
* Runtime information. This is loosely defined to allow for extensibility.
*/
export class CoreRuntimeMetadata {
    /**
    * Type of runtime.
    */
    'type'?: RuntimeMetadataRuntimeType;
    /**
    * Version of the runtime. All versions should be backward compatible. However, certain cases call for version checks to ensure tighter validation or setting expectations.
    */
    'version'?: string;
    /**
    * +optional It can be used to provide extra information about the runtime (e.g. python, golang... etc.).
    */
    'flavor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "RuntimeMetadataRuntimeType"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "flavor",
            "baseName": "flavor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreRuntimeMetadata.attributeTypeMap;
    }
}

export class CoreScalar {
    'primitive'?: CorePrimitive;
    'blob'?: CoreBlob;
    'binary'?: CoreBinary;
    'schema'?: CoreSchema;
    'noneType'?: CoreVoid;
    'error'?: CoreError;
    'generic'?: ProtobufStruct;
    'structuredDataset'?: CoreStructuredDataset;
    'union'?: CoreUnion;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "primitive",
            "baseName": "primitive",
            "type": "CorePrimitive"
        },
        {
            "name": "blob",
            "baseName": "blob",
            "type": "CoreBlob"
        },
        {
            "name": "binary",
            "baseName": "binary",
            "type": "CoreBinary"
        },
        {
            "name": "schema",
            "baseName": "schema",
            "type": "CoreSchema"
        },
        {
            "name": "noneType",
            "baseName": "none_type",
            "type": "CoreVoid"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "CoreError"
        },
        {
            "name": "generic",
            "baseName": "generic",
            "type": "ProtobufStruct"
        },
        {
            "name": "structuredDataset",
            "baseName": "structured_dataset",
            "type": "CoreStructuredDataset"
        },
        {
            "name": "union",
            "baseName": "union",
            "type": "CoreUnion"
        }    ];

    static getAttributeTypeMap() {
        return CoreScalar.attributeTypeMap;
    }
}

/**
* A strongly typed schema that defines the interface of data retrieved from the underlying storage medium.
*/
export class CoreSchema {
    'uri'?: string;
    'type'?: CoreSchemaType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CoreSchemaType"
        }    ];

    static getAttributeTypeMap() {
        return CoreSchema.attributeTypeMap;
    }
}

/**
* Defines schema columns and types to strongly type-validate schemas interoperability.
*/
export class CoreSchemaType {
    /**
    * A list of ordered columns this schema comprises of.
    */
    'columns'?: Array<SchemaTypeSchemaColumn>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "columns",
            "baseName": "columns",
            "type": "Array<SchemaTypeSchemaColumn>"
        }    ];

    static getAttributeTypeMap() {
        return CoreSchemaType.attributeTypeMap;
    }
}

/**
* Secret encapsulates information about the secret a task needs to proceed. An environment variable FLYTE_SECRETS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if secrets are passed through environment variables. FLYTE_SECRETS_DEFAULT_DIR will be passed to indicate the prefix of the path where secrets will be mounted if secrets are passed through file mounts.
*/
export class CoreSecret {
    'group'?: string;
    'groupVersion'?: string;
    'key'?: string;
    'mountRequirement'?: SecretMountType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "group",
            "baseName": "group",
            "type": "string"
        },
        {
            "name": "groupVersion",
            "baseName": "group_version",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "mountRequirement",
            "baseName": "mount_requirement",
            "type": "SecretMountType"
        }    ];

    static getAttributeTypeMap() {
        return CoreSecret.attributeTypeMap;
    }
}

/**
* SecurityContext holds security attributes that apply to tasks.
*/
export class CoreSecurityContext {
    /**
    * run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the backend plugin to choose the appropriate identity for the execution engine the task will run on.
    */
    'runAs'?: CoreIdentity;
    /**
    * secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.
    */
    'secrets'?: Array<CoreSecret>;
    /**
    * tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the pod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS Batch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access to the secret) and to pass it to the remote execution engine.
    */
    'tokens'?: Array<CoreOAuth2TokenRequest>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "runAs",
            "baseName": "run_as",
            "type": "CoreIdentity"
        },
        {
            "name": "secrets",
            "baseName": "secrets",
            "type": "Array<CoreSecret>"
        },
        {
            "name": "tokens",
            "baseName": "tokens",
            "type": "Array<CoreOAuth2TokenRequest>"
        }    ];

    static getAttributeTypeMap() {
        return CoreSecurityContext.attributeTypeMap;
    }
}

/**
* SignalCondition represents a dependency on an signal.
*/
export class CoreSignalCondition {
    /**
    * A unique identifier for the requested signal.
    */
    'signalId'?: string;
    /**
    * A type denoting the required value type for this signal.
    */
    'type'?: CoreLiteralType;
    /**
    * The variable name for the signal value in this nodes outputs.
    */
    'outputVariableName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "signalId",
            "baseName": "signal_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CoreLiteralType"
        },
        {
            "name": "outputVariableName",
            "baseName": "output_variable_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreSignalCondition.attributeTypeMap;
    }
}

/**
* Define a set of simple types.
*/
export class CoreSimpleType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CoreSimpleType.attributeTypeMap;
    }
}

/**
* SleepCondition represents a dependency on waiting for the specified duration.
*/
export class CoreSleepCondition {
    /**
    * The overall duration for this sleep.
    */
    'duration'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreSleepCondition.attributeTypeMap;
    }
}

/**
* Span represents a duration trace of Flyte execution. The id field denotes a Flyte execution entity or an operation which uniquely identifies the Span. The spans attribute allows this Span to be further broken down into more precise definitions.
*/
export class CoreSpan {
    /**
    * start_time defines the instance this span began.
    */
    'startTime'?: Date;
    /**
    * end_time defines the instance this span completed.
    */
    'endTime'?: Date;
    /**
    * workflow_id is the id of the workflow execution this Span represents.
    */
    'workflowId'?: CoreWorkflowExecutionIdentifier;
    /**
    * node_id is the id of the node execution this Span represents.
    */
    'nodeId'?: CoreNodeExecutionIdentifier;
    /**
    * task_id is the id of the task execution this Span represents.
    */
    'taskId'?: CoreTaskExecutionIdentifier;
    /**
    * operation_id is the id of a unique operation that this Span represents.
    */
    'operationId'?: string;
    /**
    * spans defines a collection of Spans that breakdown this execution.
    */
    'spans'?: Array<CoreSpan>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "Date"
        },
        {
            "name": "workflowId",
            "baseName": "workflow_id",
            "type": "CoreWorkflowExecutionIdentifier"
        },
        {
            "name": "nodeId",
            "baseName": "node_id",
            "type": "CoreNodeExecutionIdentifier"
        },
        {
            "name": "taskId",
            "baseName": "task_id",
            "type": "CoreTaskExecutionIdentifier"
        },
        {
            "name": "operationId",
            "baseName": "operation_id",
            "type": "string"
        },
        {
            "name": "spans",
            "baseName": "spans",
            "type": "Array<CoreSpan>"
        }    ];

    static getAttributeTypeMap() {
        return CoreSpan.attributeTypeMap;
    }
}

/**
* Sql represents a generic sql workload with a statement and dialect.
*/
export class CoreSql {
    'statement'?: string;
    'dialect'?: SqlDialect;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "statement",
            "baseName": "statement",
            "type": "string"
        },
        {
            "name": "dialect",
            "baseName": "dialect",
            "type": "SqlDialect"
        }    ];

    static getAttributeTypeMap() {
        return CoreSql.attributeTypeMap;
    }
}

export class CoreStructuredDataset {
    'uri'?: string;
    'metadata'?: CoreStructuredDatasetMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "CoreStructuredDatasetMetadata"
        }    ];

    static getAttributeTypeMap() {
        return CoreStructuredDataset.attributeTypeMap;
    }
}

export class CoreStructuredDatasetMetadata {
    /**
    * Bundle the type information along with the literal. This is here because StructuredDatasets can often be more defined at run time than at compile time. That is, at compile time you might only declare a task to return a pandas dataframe or a StructuredDataset, without any column information, but at run time, you might have that column information. flytekit python will copy this type information into the literal, from the type information, if not provided by the various plugins (encoders). Since this field is run time generated, it's not used for any type checking.
    */
    'structuredDatasetType'?: CoreStructuredDatasetType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "structuredDatasetType",
            "baseName": "structured_dataset_type",
            "type": "CoreStructuredDatasetType"
        }    ];

    static getAttributeTypeMap() {
        return CoreStructuredDatasetMetadata.attributeTypeMap;
    }
}

export class CoreStructuredDatasetType {
    /**
    * A list of ordered columns this schema comprises of.
    */
    'columns'?: Array<StructuredDatasetTypeDatasetColumn>;
    /**
    * This is the storage format, the format of the bits at rest parquet, feather, csv, etc. For two types to be compatible, the format will need to be an exact match.
    */
    'format'?: string;
    /**
    * This is a string representing the type that the bytes in external_schema_bytes are formatted in. This is an optional field that will not be used for type checking.
    */
    'externalSchemaType'?: string;
    /**
    * The serialized bytes of a third-party schema library like Arrow. This is an optional field that will not be used for type checking.
    */
    'externalSchemaBytes'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "columns",
            "baseName": "columns",
            "type": "Array<StructuredDatasetTypeDatasetColumn>"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        },
        {
            "name": "externalSchemaType",
            "baseName": "external_schema_type",
            "type": "string"
        },
        {
            "name": "externalSchemaBytes",
            "baseName": "external_schema_bytes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreStructuredDatasetType.attributeTypeMap;
    }
}

/**
* Encapsulation of fields that identify a Flyte task execution entity.
*/
export class CoreTaskExecutionIdentifier {
    'taskId'?: CoreIdentifier;
    'nodeExecutionId'?: CoreNodeExecutionIdentifier;
    'retryAttempt'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taskId",
            "baseName": "task_id",
            "type": "CoreIdentifier"
        },
        {
            "name": "nodeExecutionId",
            "baseName": "node_execution_id",
            "type": "CoreNodeExecutionIdentifier"
        },
        {
            "name": "retryAttempt",
            "baseName": "retry_attempt",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreTaskExecutionIdentifier.attributeTypeMap;
    }
}

export class CoreTaskExecutionPhase {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CoreTaskExecutionPhase.attributeTypeMap;
    }
}

export class CoreTaskLog {
    'uri'?: string;
    'name'?: string;
    'messageFormat'?: TaskLogMessageFormat;
    'ttl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "messageFormat",
            "baseName": "message_format",
            "type": "TaskLogMessageFormat"
        },
        {
            "name": "ttl",
            "baseName": "ttl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreTaskLog.attributeTypeMap;
    }
}

export class CoreTaskMetadata {
    /**
    * Indicates whether the system should attempt to lookup this task's output to avoid duplication of work.
    */
    'discoverable'?: boolean;
    /**
    * Runtime information about the task.
    */
    'runtime'?: CoreRuntimeMetadata;
    /**
    * The overall timeout of a task including user-triggered retries.
    */
    'timeout'?: string;
    /**
    * Number of retries per task.
    */
    'retries'?: CoreRetryStrategy;
    /**
    * Indicates a logical version to apply to this task for the purpose of discovery.
    */
    'discoveryVersion'?: string;
    /**
    * If set, this indicates that this task is deprecated.  This will enable owners of tasks to notify consumers of the ending of support for a given task.
    */
    'deprecatedErrorMessage'?: string;
    'interruptible'?: boolean;
    'cacheSerializable'?: boolean;
    /**
    * Indicates whether the task will generate a Deck URI when it finishes executing.
    */
    'generatesDeck'?: boolean;
    'tags'?: { [key: string]: string; };
    /**
    * pod_template_name is the unique name of a PodTemplate k8s resource to be used as the base configuration if this task creates a k8s Pod. If this value is set, the specified PodTemplate will be used instead of, but applied identically as, the default PodTemplate configured in FlytePropeller.
    */
    'podTemplateName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discoverable",
            "baseName": "discoverable",
            "type": "boolean"
        },
        {
            "name": "runtime",
            "baseName": "runtime",
            "type": "CoreRuntimeMetadata"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "string"
        },
        {
            "name": "retries",
            "baseName": "retries",
            "type": "CoreRetryStrategy"
        },
        {
            "name": "discoveryVersion",
            "baseName": "discovery_version",
            "type": "string"
        },
        {
            "name": "deprecatedErrorMessage",
            "baseName": "deprecated_error_message",
            "type": "string"
        },
        {
            "name": "interruptible",
            "baseName": "interruptible",
            "type": "boolean"
        },
        {
            "name": "cacheSerializable",
            "baseName": "cache_serializable",
            "type": "boolean"
        },
        {
            "name": "generatesDeck",
            "baseName": "generates_deck",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "podTemplateName",
            "baseName": "pod_template_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreTaskMetadata.attributeTypeMap;
    }
}

/**
* Refers to the task that the Node is to execute.
*/
export class CoreTaskNode {
    /**
    * A globally unique identifier for the task.
    */
    'referenceId'?: CoreIdentifier;
    /**
    * Optional overrides applied at task execution time.
    */
    'overrides'?: CoreTaskNodeOverrides;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "referenceId",
            "baseName": "reference_id",
            "type": "CoreIdentifier"
        },
        {
            "name": "overrides",
            "baseName": "overrides",
            "type": "CoreTaskNodeOverrides"
        }    ];

    static getAttributeTypeMap() {
        return CoreTaskNode.attributeTypeMap;
    }
}

/**
* Optional task node overrides that will be applied at task execution time.
*/
export class CoreTaskNodeOverrides {
    /**
    * A customizable interface to convey resources requested for a task container.
    */
    'resources'?: CoreResources;
    /**
    * Overrides for all non-standard resources, not captured by v1.ResourceRequirements, to allocate to a task.
    */
    'extendedResources'?: CoreExtendedResources;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resources",
            "baseName": "resources",
            "type": "CoreResources"
        },
        {
            "name": "extendedResources",
            "baseName": "extended_resources",
            "type": "CoreExtendedResources"
        }    ];

    static getAttributeTypeMap() {
        return CoreTaskNodeOverrides.attributeTypeMap;
    }
}

/**
* A Task structure that uniquely identifies a task in the system Tasks are registered as a first step in the system.
*/
export class CoreTaskTemplate {
    /**
    * Auto generated taskId by the system. Task Id uniquely identifies this task globally.
    */
    'id'?: CoreIdentifier;
    /**
    * A predefined yet extensible Task type identifier. This can be used to customize any of the components. If no extensions are provided in the system, Flyte will resolve the this task to its TaskCategory and default the implementation registered for the TaskCategory.
    */
    'type'?: string;
    /**
    * Extra metadata about the task.
    */
    'metadata'?: CoreTaskMetadata;
    /**
    * A strongly typed interface for the task. This enables others to use this task within a workflow and guarantees compile-time validation of the workflow to avoid costly runtime failures.
    */
    '_interface'?: CoreTypedInterface;
    /**
    * Custom data about the task. This is extensible to allow various plugins in the system.
    */
    'custom'?: ProtobufStruct;
    'container'?: CoreContainer;
    'k8sPod'?: CoreK8sPod;
    'sql'?: CoreSql;
    /**
    * This can be used to customize task handling at execution time for the same task type.
    */
    'taskTypeVersion'?: number;
    /**
    * security_context encapsulates security attributes requested to run this task.
    */
    'securityContext'?: CoreSecurityContext;
    /**
    * Encapsulates all non-standard resources, not captured by v1.ResourceRequirements, to allocate to a task.
    */
    'extendedResources'?: CoreExtendedResources;
    'config'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "CoreTaskMetadata"
        },
        {
            "name": "_interface",
            "baseName": "interface",
            "type": "CoreTypedInterface"
        },
        {
            "name": "custom",
            "baseName": "custom",
            "type": "ProtobufStruct"
        },
        {
            "name": "container",
            "baseName": "container",
            "type": "CoreContainer"
        },
        {
            "name": "k8sPod",
            "baseName": "k8s_pod",
            "type": "CoreK8sPod"
        },
        {
            "name": "sql",
            "baseName": "sql",
            "type": "CoreSql"
        },
        {
            "name": "taskTypeVersion",
            "baseName": "task_type_version",
            "type": "number"
        },
        {
            "name": "securityContext",
            "baseName": "security_context",
            "type": "CoreSecurityContext"
        },
        {
            "name": "extendedResources",
            "baseName": "extended_resources",
            "type": "CoreExtendedResources"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return CoreTaskTemplate.attributeTypeMap;
    }
}

/**
* TypeAnnotation encapsulates registration time information about a type. This can be used for various control-plane operations. TypeAnnotation will not be available at runtime when a task runs.
*/
export class CoreTypeAnnotation {
    /**
    * A arbitrary JSON payload to describe a type.
    */
    'annotations'?: ProtobufStruct;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "annotations",
            "baseName": "annotations",
            "type": "ProtobufStruct"
        }    ];

    static getAttributeTypeMap() {
        return CoreTypeAnnotation.attributeTypeMap;
    }
}

/**
* Hints to improve type matching e.g. allows distinguishing output from custom type transformers even if the underlying IDL serialization matches.
*/
export class CoreTypeStructure {
    'tag'?: string;
    'dataclassType'?: { [key: string]: CoreLiteralType; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "dataclassType",
            "baseName": "dataclass_type",
            "type": "{ [key: string]: CoreLiteralType; }"
        }    ];

    static getAttributeTypeMap() {
        return CoreTypeStructure.attributeTypeMap;
    }
}

/**
* Defines strongly typed inputs and outputs.
*/
export class CoreTypedInterface {
    'inputs'?: CoreVariableMap;
    'outputs'?: CoreVariableMap;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "inputs",
            "baseName": "inputs",
            "type": "CoreVariableMap"
        },
        {
            "name": "outputs",
            "baseName": "outputs",
            "type": "CoreVariableMap"
        }    ];

    static getAttributeTypeMap() {
        return CoreTypedInterface.attributeTypeMap;
    }
}

/**
* The runtime representation of a tagged union value. See `UnionType` for more details.
*/
export class CoreUnion {
    'value'?: CoreLiteral;
    'type'?: CoreLiteralType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "CoreLiteral"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CoreLiteralType"
        }    ];

    static getAttributeTypeMap() {
        return CoreUnion.attributeTypeMap;
    }
}

export class CoreUnionInfo {
    'targetType'?: CoreLiteralType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "targetType",
            "baseName": "targetType",
            "type": "CoreLiteralType"
        }    ];

    static getAttributeTypeMap() {
        return CoreUnionInfo.attributeTypeMap;
    }
}

/**
* Defines a tagged union type, also known as a variant (and formally as the sum type).  A sum type S is defined by a sequence of types (A, B, C, ...), each tagged by a string tag A value of type S is constructed from a value of any of the variant types. The specific choice of type is recorded by storing the varaint's tag with the literal value and can be examined in runtime.  Type S is typically written as S := Apple A | Banana B | Cantaloupe C | ...  Notably, a nullable (optional) type is a sum type between some type X and the singleton type representing a null-value: Optional X := X | Null  See also: https://en.wikipedia.org/wiki/Tagged_union
*/
export class CoreUnionType {
    /**
    * Predefined set of variants in union.
    */
    'variants'?: Array<CoreLiteralType>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variants",
            "baseName": "variants",
            "type": "Array<CoreLiteralType>"
        }    ];

    static getAttributeTypeMap() {
        return CoreUnionType.attributeTypeMap;
    }
}

/**
* Defines a strongly typed variable.
*/
export class CoreVariable {
    /**
    * Variable literal type.
    */
    'type'?: CoreLiteralType;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "CoreLiteralType"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreVariable.attributeTypeMap;
    }
}

export class CoreVariableMap {
    /**
    * Defines a map of variable names to variables.
    */
    'variables'?: { [key: string]: CoreVariable; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variables",
            "baseName": "variables",
            "type": "{ [key: string]: CoreVariable; }"
        }    ];

    static getAttributeTypeMap() {
        return CoreVariableMap.attributeTypeMap;
    }
}

/**
* Used to denote a nil/null/None assignment to a scalar value. The underlying LiteralType for Void is intentionally undefined since it can be assigned to a scalar of any LiteralType.
*/
export class CoreVoid {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CoreVoid.attributeTypeMap;
    }
}

export class CoreWorkflowExecutionIdentifier {
    /**
    * Name of the project the resource belongs to.
    */
    'project'?: string;
    /**
    * Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
    */
    'domain'?: string;
    /**
    * User or system provided value for the resource.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "project",
            "baseName": "project",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreWorkflowExecutionIdentifier.attributeTypeMap;
    }
}

export class CoreWorkflowExecutionPhase {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CoreWorkflowExecutionPhase.attributeTypeMap;
    }
}

/**
* This is workflow layer metadata. These settings are only applicable to the workflow as a whole, and do not percolate down to child entities (like tasks) launched by the workflow.
*/
export class CoreWorkflowMetadata {
    /**
    * Indicates the runtime priority of workflow executions.
    */
    'qualityOfService'?: CoreQualityOfService;
    /**
    * Defines how the system should behave when a failure is detected in the workflow execution.
    */
    'onFailure'?: WorkflowMetadataOnFailurePolicy;
    'tags'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "qualityOfService",
            "baseName": "quality_of_service",
            "type": "CoreQualityOfService"
        },
        {
            "name": "onFailure",
            "baseName": "on_failure",
            "type": "WorkflowMetadataOnFailurePolicy"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return CoreWorkflowMetadata.attributeTypeMap;
    }
}

/**
* The difference between these settings and the WorkflowMetadata ones is that these are meant to be passed down to a workflow's underlying entities (like tasks). For instance, 'interruptible' has no meaning at the workflow layer, it is only relevant when a task executes. The settings here are the defaults that are passed to all nodes unless explicitly overridden at the node layer. If you are adding a setting that applies to both the Workflow itself, and everything underneath it, it should be added to both this object and the WorkflowMetadata object above.
*/
export class CoreWorkflowMetadataDefaults {
    /**
    * Whether child nodes of the workflow are interruptible.
    */
    'interruptible'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "interruptible",
            "baseName": "interruptible",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CoreWorkflowMetadataDefaults.attributeTypeMap;
    }
}

/**
* Refers to a the workflow the node is to execute.
*/
export class CoreWorkflowNode {
    /**
    * A globally unique identifier for the launch plan.
    */
    'launchplanRef'?: CoreIdentifier;
    'subWorkflowRef'?: CoreIdentifier;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "launchplanRef",
            "baseName": "launchplan_ref",
            "type": "CoreIdentifier"
        },
        {
            "name": "subWorkflowRef",
            "baseName": "sub_workflow_ref",
            "type": "CoreIdentifier"
        }    ];

    static getAttributeTypeMap() {
        return CoreWorkflowNode.attributeTypeMap;
    }
}

/**
* Flyte Workflow Structure that encapsulates task, branch and subworkflow nodes to form a statically analyzable, directed acyclic graph.
*/
export class CoreWorkflowTemplate {
    /**
    * A globally unique identifier for the workflow.
    */
    'id'?: CoreIdentifier;
    /**
    * Extra metadata about the workflow.
    */
    'metadata'?: CoreWorkflowMetadata;
    /**
    * Defines a strongly typed interface for the Workflow. This can include some optional parameters.
    */
    '_interface'?: CoreTypedInterface;
    /**
    * A list of nodes. In addition, 'globals' is a special reserved node id that can be used to consume workflow inputs.
    */
    'nodes'?: Array<CoreNode>;
    /**
    * A list of output bindings that specify how to construct workflow outputs. Bindings can pull node outputs or specify literals. All workflow outputs specified in the interface field must be bound in order for the workflow to be validated. A workflow has an implicit dependency on all of its nodes to execute successfully in order to bind final outputs. Most of these outputs will be Binding's with a BindingData of type OutputReference.  That is, your workflow can just have an output of some constant (`Output(5)`), but usually, the workflow will be pulling outputs from the output of a task.
    */
    'outputs'?: Array<CoreBinding>;
    /**
    * +optional A catch-all node. This node is executed whenever the execution engine determines the workflow has failed. The interface of this node must match the Workflow interface with an additional input named 'error' of type pb.lyft.flyte.core.Error.
    */
    'failureNode'?: CoreNode;
    'metadataDefaults'?: CoreWorkflowMetadataDefaults;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "CoreWorkflowMetadata"
        },
        {
            "name": "_interface",
            "baseName": "interface",
            "type": "CoreTypedInterface"
        },
        {
            "name": "nodes",
            "baseName": "nodes",
            "type": "Array<CoreNode>"
        },
        {
            "name": "outputs",
            "baseName": "outputs",
            "type": "Array<CoreBinding>"
        },
        {
            "name": "failureNode",
            "baseName": "failure_node",
            "type": "CoreNode"
        },
        {
            "name": "metadataDefaults",
            "baseName": "metadata_defaults",
            "type": "CoreWorkflowMetadataDefaults"
        }    ];

    static getAttributeTypeMap() {
        return CoreWorkflowTemplate.attributeTypeMap;
    }
}

/**
* - JSON: JSON / YAML for the metadata (which contains inlined primitive values). The representation is inline with the standard json specification as specified - https://www.json.org/json-en.html  - PROTO: Proto is a serialized binary of `core.LiteralMap` defined in flyteidl/core
*/
export class DataLoadingConfigLiteralMapFormat {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DataLoadingConfigLiteralMapFormat.attributeTypeMap;
    }
}

export class EventEventReason {
    'reason'?: string;
    'occurredAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "occurredAt",
            "baseName": "occurred_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return EventEventReason.attributeTypeMap;
    }
}

/**
* This message contains metadata about external resources produced or used by a specific task execution.
*/
export class EventExternalResourceInfo {
    /**
    * Identifier for an external resource created by this task execution, for example Qubole query ID or presto query ids.
    */
    'externalId'?: string;
    /**
    * A unique index for the external resource with respect to all external resources for this task. Although the identifier may change between task reporting events or retries, this will remain the same to enable aggregating information from multiple reports.
    */
    'index'?: number;
    'retryAttempt'?: number;
    'phase'?: CoreTaskExecutionPhase;
    /**
    * Captures the status of caching for this external resource execution.
    */
    'cacheStatus'?: CoreCatalogCacheStatus;
    'logs'?: Array<CoreTaskLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "externalId",
            "baseName": "external_id",
            "type": "string"
        },
        {
            "name": "index",
            "baseName": "index",
            "type": "number"
        },
        {
            "name": "retryAttempt",
            "baseName": "retry_attempt",
            "type": "number"
        },
        {
            "name": "phase",
            "baseName": "phase",
            "type": "CoreTaskExecutionPhase"
        },
        {
            "name": "cacheStatus",
            "baseName": "cache_status",
            "type": "CoreCatalogCacheStatus"
        },
        {
            "name": "logs",
            "baseName": "logs",
            "type": "Array<CoreTaskLog>"
        }    ];

    static getAttributeTypeMap() {
        return EventExternalResourceInfo.attributeTypeMap;
    }
}

export class EventNodeExecutionEvent {
    'id'?: CoreNodeExecutionIdentifier;
    'producerId'?: string;
    'phase'?: CoreNodeExecutionPhase;
    /**
    * This timestamp represents when the original event occurred, it is generated by the executor of the node.
    */
    'occurredAt'?: Date;
    'inputUri'?: string;
    /**
    * Raw input data consumed by this node execution.
    */
    'inputData'?: CoreLiteralMap;
    /**
    * URL to the output of the execution, it encodes all the information including Cloud source provider. ie., s3://...
    */
    'outputUri'?: string;
    'error'?: CoreExecutionError;
    /**
    * Raw output data produced by this node execution.
    */
    'outputData'?: CoreLiteralMap;
    'workflowNodeMetadata'?: FlyteidleventWorkflowNodeMetadata;
    'taskNodeMetadata'?: FlyteidleventTaskNodeMetadata;
    /**
    * [To be deprecated] Specifies which task (if any) launched this node.
    */
    'parentTaskMetadata'?: EventParentTaskExecutionMetadata;
    /**
    * Specifies the parent node of the current node execution. Node executions at level zero will not have a parent node.
    */
    'parentNodeMetadata'?: EventParentNodeExecutionMetadata;
    'retryGroup'?: string;
    'specNodeId'?: string;
    'nodeName'?: string;
    'eventVersion'?: number;
    /**
    * Whether this node launched a subworkflow.
    */
    'isParent'?: boolean;
    /**
    * Whether this node yielded a dynamic workflow.
    */
    'isDynamic'?: boolean;
    'deckUri'?: string;
    /**
    * This timestamp represents the instant when the event was reported by the executing framework. For example, when first processing a node the `occurred_at` timestamp should be the instant propeller makes progress, so when literal inputs are initially copied. The event however will not be sent until after the copy completes. Extracting both of these timestamps facilitates a more accurate portrayal of the evaluation time-series.
    */
    'reportedAt'?: Date;
    /**
    * Indicates if this node is an ArrayNode.
    */
    'isArray'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreNodeExecutionIdentifier"
        },
        {
            "name": "producerId",
            "baseName": "producer_id",
            "type": "string"
        },
        {
            "name": "phase",
            "baseName": "phase",
            "type": "CoreNodeExecutionPhase"
        },
        {
            "name": "occurredAt",
            "baseName": "occurred_at",
            "type": "Date"
        },
        {
            "name": "inputUri",
            "baseName": "input_uri",
            "type": "string"
        },
        {
            "name": "inputData",
            "baseName": "input_data",
            "type": "CoreLiteralMap"
        },
        {
            "name": "outputUri",
            "baseName": "output_uri",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "CoreExecutionError"
        },
        {
            "name": "outputData",
            "baseName": "output_data",
            "type": "CoreLiteralMap"
        },
        {
            "name": "workflowNodeMetadata",
            "baseName": "workflow_node_metadata",
            "type": "FlyteidleventWorkflowNodeMetadata"
        },
        {
            "name": "taskNodeMetadata",
            "baseName": "task_node_metadata",
            "type": "FlyteidleventTaskNodeMetadata"
        },
        {
            "name": "parentTaskMetadata",
            "baseName": "parent_task_metadata",
            "type": "EventParentTaskExecutionMetadata"
        },
        {
            "name": "parentNodeMetadata",
            "baseName": "parent_node_metadata",
            "type": "EventParentNodeExecutionMetadata"
        },
        {
            "name": "retryGroup",
            "baseName": "retry_group",
            "type": "string"
        },
        {
            "name": "specNodeId",
            "baseName": "spec_node_id",
            "type": "string"
        },
        {
            "name": "nodeName",
            "baseName": "node_name",
            "type": "string"
        },
        {
            "name": "eventVersion",
            "baseName": "event_version",
            "type": "number"
        },
        {
            "name": "isParent",
            "baseName": "is_parent",
            "type": "boolean"
        },
        {
            "name": "isDynamic",
            "baseName": "is_dynamic",
            "type": "boolean"
        },
        {
            "name": "deckUri",
            "baseName": "deck_uri",
            "type": "string"
        },
        {
            "name": "reportedAt",
            "baseName": "reported_at",
            "type": "Date"
        },
        {
            "name": "isArray",
            "baseName": "is_array",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EventNodeExecutionEvent.attributeTypeMap;
    }
}

export class EventParentNodeExecutionMetadata {
    'nodeId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nodeId",
            "baseName": "node_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventParentNodeExecutionMetadata.attributeTypeMap;
    }
}

export class EventParentTaskExecutionMetadata {
    'id'?: CoreTaskExecutionIdentifier;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreTaskExecutionIdentifier"
        }    ];

    static getAttributeTypeMap() {
        return EventParentTaskExecutionMetadata.attributeTypeMap;
    }
}

/**
* This message holds task execution metadata specific to resource allocation used to manage concurrent executions for a project namespace.
*/
export class EventResourcePoolInfo {
    /**
    * Unique resource ID used to identify this execution when allocating a token.
    */
    'allocationToken'?: string;
    /**
    * Namespace under which this task execution requested an allocation token.
    */
    'namespace'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allocationToken",
            "baseName": "allocation_token",
            "type": "string"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventResourcePoolInfo.attributeTypeMap;
    }
}

/**
* Plugin specific execution event information. For tasks like Python, Hive, Spark, DynamicJob.
*/
export class EventTaskExecutionEvent {
    /**
    * ID of the task. In combination with the retryAttempt this will indicate the task execution uniquely for a given parent node execution.
    */
    'taskId'?: CoreIdentifier;
    'parentNodeExecutionId'?: CoreNodeExecutionIdentifier;
    'retryAttempt'?: number;
    'phase'?: CoreTaskExecutionPhase;
    'producerId'?: string;
    'logs'?: Array<CoreTaskLog>;
    /**
    * This timestamp represents when the original event occurred, it is generated by the executor of the task.
    */
    'occurredAt'?: Date;
    /**
    * URI of the input file, it encodes all the information including Cloud source provider. ie., s3://...
    */
    'inputUri'?: string;
    /**
    * Raw input data consumed by this task execution.
    */
    'inputData'?: CoreLiteralMap;
    /**
    * URI to the output of the execution, it will be in a format that encodes all the information including Cloud source provider. ie., s3://...
    */
    'outputUri'?: string;
    'error'?: CoreExecutionError;
    /**
    * Raw output data produced by this task execution.
    */
    'outputData'?: CoreLiteralMap;
    /**
    * Custom data that the task plugin sends back. This is extensible to allow various plugins in the system.
    */
    'customInfo'?: ProtobufStruct;
    /**
    * Some phases, like RUNNING, can send multiple events with changed metadata (new logs, additional custom_info, etc) that should be recorded regardless of the lack of phase change. The version field should be incremented when metadata changes across the duration of an individual phase.
    */
    'phaseVersion'?: number;
    /**
    * An optional explanation for the phase transition. Deprecated: Use reasons instead.
    */
    'reason'?: string;
    /**
    * An optional list of explanations for the phase transition.
    */
    'reasons'?: Array<EventEventReason>;
    /**
    * A predefined yet extensible Task type identifier. If the task definition is already registered in flyte admin this type will be identical, but not all task executions necessarily use pre-registered definitions and this type is useful to render the task in the UI, filter task executions, etc.
    */
    'taskType'?: string;
    /**
    * Metadata around how a task was executed.
    */
    'metadata'?: FlyteidleventTaskExecutionMetadata;
    /**
    * The event version is used to indicate versioned changes in how data is reported using this proto message. For example, event_verison > 0 means that maps tasks report logs using the TaskExecutionMetadata ExternalResourceInfo fields for each subtask rather than the TaskLog in this message.
    */
    'eventVersion'?: number;
    /**
    * This timestamp represents the instant when the event was reported by the executing framework. For example, a k8s pod task may be marked completed at (ie. `occurred_at`) the instant the container running user code completes, but this event will not be reported until the pod is marked as completed. Extracting both of these timestamps facilitates a more accurate portrayal of the evaluation time-series.
    */
    'reportedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taskId",
            "baseName": "task_id",
            "type": "CoreIdentifier"
        },
        {
            "name": "parentNodeExecutionId",
            "baseName": "parent_node_execution_id",
            "type": "CoreNodeExecutionIdentifier"
        },
        {
            "name": "retryAttempt",
            "baseName": "retry_attempt",
            "type": "number"
        },
        {
            "name": "phase",
            "baseName": "phase",
            "type": "CoreTaskExecutionPhase"
        },
        {
            "name": "producerId",
            "baseName": "producer_id",
            "type": "string"
        },
        {
            "name": "logs",
            "baseName": "logs",
            "type": "Array<CoreTaskLog>"
        },
        {
            "name": "occurredAt",
            "baseName": "occurred_at",
            "type": "Date"
        },
        {
            "name": "inputUri",
            "baseName": "input_uri",
            "type": "string"
        },
        {
            "name": "inputData",
            "baseName": "input_data",
            "type": "CoreLiteralMap"
        },
        {
            "name": "outputUri",
            "baseName": "output_uri",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "CoreExecutionError"
        },
        {
            "name": "outputData",
            "baseName": "output_data",
            "type": "CoreLiteralMap"
        },
        {
            "name": "customInfo",
            "baseName": "custom_info",
            "type": "ProtobufStruct"
        },
        {
            "name": "phaseVersion",
            "baseName": "phase_version",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "reasons",
            "baseName": "reasons",
            "type": "Array<EventEventReason>"
        },
        {
            "name": "taskType",
            "baseName": "task_type",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "FlyteidleventTaskExecutionMetadata"
        },
        {
            "name": "eventVersion",
            "baseName": "event_version",
            "type": "number"
        },
        {
            "name": "reportedAt",
            "baseName": "reported_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return EventTaskExecutionEvent.attributeTypeMap;
    }
}

export class EventWorkflowExecutionEvent {
    'executionId'?: CoreWorkflowExecutionIdentifier;
    'producerId'?: string;
    'phase'?: CoreWorkflowExecutionPhase;
    /**
    * This timestamp represents when the original event occurred, it is generated by the executor of the workflow.
    */
    'occurredAt'?: Date;
    /**
    * URL to the output of the execution, it encodes all the information including Cloud source provider. ie., s3://...
    */
    'outputUri'?: string;
    'error'?: CoreExecutionError;
    /**
    * Raw output data produced by this workflow execution.
    */
    'outputData'?: CoreLiteralMap;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "executionId",
            "baseName": "execution_id",
            "type": "CoreWorkflowExecutionIdentifier"
        },
        {
            "name": "producerId",
            "baseName": "producer_id",
            "type": "string"
        },
        {
            "name": "phase",
            "baseName": "phase",
            "type": "CoreWorkflowExecutionPhase"
        },
        {
            "name": "occurredAt",
            "baseName": "occurred_at",
            "type": "Date"
        },
        {
            "name": "outputUri",
            "baseName": "output_uri",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "CoreExecutionError"
        },
        {
            "name": "outputData",
            "baseName": "output_data",
            "type": "CoreLiteralMap"
        }    ];

    static getAttributeTypeMap() {
        return EventWorkflowExecutionEvent.attributeTypeMap;
    }
}

export class ExecutionErrorErrorKind {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ExecutionErrorErrorKind.attributeTypeMap;
    }
}

/**
* The method by which this execution was launched.   - MANUAL: The default execution mode, MANUAL implies that an execution was launched by an individual.  - SCHEDULED: A schedule triggered this execution launch.  - SYSTEM: A system process was responsible for launching this execution rather an individual.  - RELAUNCH: This execution was launched with identical inputs as a previous execution.  - CHILD_WORKFLOW: This execution was triggered by another execution.  - RECOVERED: This execution was recovered from another execution.
*/
export class ExecutionMetadataExecutionMode {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ExecutionMetadataExecutionMode.attributeTypeMap;
    }
}

/**
* For dynamic workflow nodes we capture information about the dynamic workflow definition that gets generated.
*/
export class FlyteidladminDynamicWorkflowNodeMetadata {
    /**
    * id represents the unique identifier of the workflow.
    */
    'id'?: CoreIdentifier;
    /**
    * Represents the compiled representation of the embedded dynamic workflow.
    */
    'compiledWorkflow'?: CoreCompiledWorkflowClosure;
    /**
    * dynamic_job_spec_uri is the location of the DynamicJobSpec proto message for this DynamicWorkflow. This is required to correctly recover partially completed executions where the subworkflow has already been compiled.
    */
    'dynamicJobSpecUri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "compiledWorkflow",
            "baseName": "compiled_workflow",
            "type": "CoreCompiledWorkflowClosure"
        },
        {
            "name": "dynamicJobSpecUri",
            "baseName": "dynamic_job_spec_uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlyteidladminDynamicWorkflowNodeMetadata.attributeTypeMap;
    }
}

/**
* Encapsulates all details for a single node execution entity. A node represents a component in the overall workflow graph. A node launch a task, multiple tasks, an entire nested sub-workflow, or even a separate child-workflow execution. The same task can be called repeatedly in a single workflow but each node is unique.
*/
export class FlyteidladminNodeExecution {
    /**
    * Uniquely identifies an individual node execution.
    */
    'id'?: CoreNodeExecutionIdentifier;
    /**
    * Path to remote data store where input blob is stored.
    */
    'inputUri'?: string;
    /**
    * Computed results associated with this node execution.
    */
    'closure'?: AdminNodeExecutionClosure;
    'metadata'?: AdminNodeExecutionMetaData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreNodeExecutionIdentifier"
        },
        {
            "name": "inputUri",
            "baseName": "input_uri",
            "type": "string"
        },
        {
            "name": "closure",
            "baseName": "closure",
            "type": "AdminNodeExecutionClosure"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "AdminNodeExecutionMetaData"
        }    ];

    static getAttributeTypeMap() {
        return FlyteidladminNodeExecution.attributeTypeMap;
    }
}

export class FlyteidladminTaskCreateRequest {
    'id'?: CoreIdentifier;
    'spec'?: AdminTaskSpec;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "spec",
            "baseName": "spec",
            "type": "AdminTaskSpec"
        }    ];

    static getAttributeTypeMap() {
        return FlyteidladminTaskCreateRequest.attributeTypeMap;
    }
}

/**
* Represents a response structure if task creation succeeds.
*/
export class FlyteidladminTaskCreateResponse {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return FlyteidladminTaskCreateResponse.attributeTypeMap;
    }
}

/**
* Encapsulates all details for a single task execution entity. A task execution represents an instantiated task, including all inputs and additional metadata as well as computed results included state, outputs, and duration-based attributes.
*/
export class FlyteidladminTaskExecution {
    /**
    * Unique identifier for the task execution.
    */
    'id'?: CoreTaskExecutionIdentifier;
    /**
    * Path to remote data store where input blob is stored.
    */
    'inputUri'?: string;
    /**
    * Task execution details and results.
    */
    'closure'?: AdminTaskExecutionClosure;
    /**
    * Whether this task spawned nodes.
    */
    'isParent'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreTaskExecutionIdentifier"
        },
        {
            "name": "inputUri",
            "baseName": "input_uri",
            "type": "string"
        },
        {
            "name": "closure",
            "baseName": "closure",
            "type": "AdminTaskExecutionClosure"
        },
        {
            "name": "isParent",
            "baseName": "is_parent",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FlyteidladminTaskExecution.attributeTypeMap;
    }
}

export class FlyteidladminTaskNodeMetadata {
    /**
    * Captures the status of caching for this execution.
    */
    'cacheStatus'?: CoreCatalogCacheStatus;
    'catalogKey'?: CoreCatalogMetadata;
    'checkpointUri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cacheStatus",
            "baseName": "cache_status",
            "type": "CoreCatalogCacheStatus"
        },
        {
            "name": "catalogKey",
            "baseName": "catalog_key",
            "type": "CoreCatalogMetadata"
        },
        {
            "name": "checkpointUri",
            "baseName": "checkpoint_uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlyteidladminTaskNodeMetadata.attributeTypeMap;
    }
}

export class FlyteidladminWorkflowNodeMetadata {
    /**
    * The identifier for a workflow execution launched by a node.
    */
    'executionId'?: CoreWorkflowExecutionIdentifier;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "executionId",
            "baseName": "executionId",
            "type": "CoreWorkflowExecutionIdentifier"
        }    ];

    static getAttributeTypeMap() {
        return FlyteidladminWorkflowNodeMetadata.attributeTypeMap;
    }
}

/**
* For dynamic workflow nodes we send information about the dynamic workflow definition that gets generated.
*/
export class FlyteidleventDynamicWorkflowNodeMetadata {
    /**
    * id represents the unique identifier of the workflow.
    */
    'id'?: CoreIdentifier;
    /**
    * Represents the compiled representation of the embedded dynamic workflow.
    */
    'compiledWorkflow'?: CoreCompiledWorkflowClosure;
    /**
    * dynamic_job_spec_uri is the location of the DynamicJobSpec proto message for this DynamicWorkflow. This is required to correctly recover partially completed executions where the workflow has already been compiled.
    */
    'dynamicJobSpecUri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "CoreIdentifier"
        },
        {
            "name": "compiledWorkflow",
            "baseName": "compiled_workflow",
            "type": "CoreCompiledWorkflowClosure"
        },
        {
            "name": "dynamicJobSpecUri",
            "baseName": "dynamic_job_spec_uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FlyteidleventDynamicWorkflowNodeMetadata.attributeTypeMap;
    }
}

/**
* Holds metadata around how a task was executed. As a task transitions across event phases during execution some attributes, such its generated name, generated external resources, and more may grow in size but not change necessarily based on the phase transition that sparked the event update. Metadata is a container for these attributes across the task execution lifecycle.
*/
export class FlyteidleventTaskExecutionMetadata {
    /**
    * Unique, generated name for this task execution used by the backend.
    */
    'generatedName'?: string;
    /**
    * Additional data on external resources on other back-ends or platforms (e.g. Hive, Qubole, etc) launched by this task execution.
    */
    'externalResources'?: Array<EventExternalResourceInfo>;
    /**
    * Includes additional data on concurrent resource management used during execution.. This is a repeated field because a plugin can request multiple resource allocations during execution.
    */
    'resourcePoolInfo'?: Array<EventResourcePoolInfo>;
    /**
    * The identifier of the plugin used to execute this task.
    */
    'pluginIdentifier'?: string;
    'instanceClass'?: TaskExecutionMetadataInstanceClass;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "generatedName",
            "baseName": "generated_name",
            "type": "string"
        },
        {
            "name": "externalResources",
            "baseName": "external_resources",
            "type": "Array<EventExternalResourceInfo>"
        },
        {
            "name": "resourcePoolInfo",
            "baseName": "resource_pool_info",
            "type": "Array<EventResourcePoolInfo>"
        },
        {
            "name": "pluginIdentifier",
            "baseName": "plugin_identifier",
            "type": "string"
        },
        {
            "name": "instanceClass",
            "baseName": "instance_class",
            "type": "TaskExecutionMetadataInstanceClass"
        }    ];

    static getAttributeTypeMap() {
        return FlyteidleventTaskExecutionMetadata.attributeTypeMap;
    }
}

export class FlyteidleventTaskNodeMetadata {
    /**
    * Captures the status of caching for this execution.
    */
    'cacheStatus'?: CoreCatalogCacheStatus;
    'catalogKey'?: CoreCatalogMetadata;
    /**
    * Captures the status of cache reservations for this execution.
    */
    'reservationStatus'?: CatalogReservationStatus;
    'checkpointUri'?: string;
    /**
    * In the case this task launched a dynamic workflow we capture its structure here.
    */
    'dynamicWorkflow'?: FlyteidleventDynamicWorkflowNodeMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cacheStatus",
            "baseName": "cache_status",
            "type": "CoreCatalogCacheStatus"
        },
        {
            "name": "catalogKey",
            "baseName": "catalog_key",
            "type": "CoreCatalogMetadata"
        },
        {
            "name": "reservationStatus",
            "baseName": "reservation_status",
            "type": "CatalogReservationStatus"
        },
        {
            "name": "checkpointUri",
            "baseName": "checkpoint_uri",
            "type": "string"
        },
        {
            "name": "dynamicWorkflow",
            "baseName": "dynamic_workflow",
            "type": "FlyteidleventDynamicWorkflowNodeMetadata"
        }    ];

    static getAttributeTypeMap() {
        return FlyteidleventTaskNodeMetadata.attributeTypeMap;
    }
}

export class FlyteidleventWorkflowNodeMetadata {
    'executionId'?: CoreWorkflowExecutionIdentifier;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "executionId",
            "baseName": "execution_id",
            "type": "CoreWorkflowExecutionIdentifier"
        }    ];

    static getAttributeTypeMap() {
        return FlyteidleventWorkflowNodeMetadata.attributeTypeMap;
    }
}

/**
* - DOWNLOAD_EAGER: All data will be downloaded before the main container is executed  - DOWNLOAD_STREAM: Data will be downloaded as a stream and an End-Of-Stream marker will be written to indicate all data has been downloaded. Refer to protocol for details  - DO_NOT_DOWNLOAD: Large objects (offloaded) will not be downloaded
*/
export class IOStrategyDownloadMode {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return IOStrategyDownloadMode.attributeTypeMap;
    }
}

/**
* - UPLOAD_ON_EXIT: All data will be uploaded after the main container exits  - UPLOAD_EAGER: Data will be uploaded as it appears. Refer to protocol specification for details  - DO_NOT_UPLOAD: Data will not be uploaded, only references will be written
*/
export class IOStrategyUploadMode {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return IOStrategyUploadMode.attributeTypeMap;
    }
}

/**
*  - FAIL: By default, if this plugin is not enabled for a Flyte deployment then execution will fail.  - USE_DEFAULT: Uses the system-configured default implementation.
*/
export class PluginOverrideMissingPluginBehavior {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PluginOverrideMissingPluginBehavior.attributeTypeMap;
    }
}

/**
* The state of the project is used to control its visibility in the UI and validity.   - ACTIVE: By default, all projects are considered active.  - ARCHIVED: Archived projects are no longer visible in the UI and no longer valid.  - SYSTEM_GENERATED: System generated projects that aren't explicitly created or managed by a user.
*/
export class ProjectProjectState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ProjectProjectState.attributeTypeMap;
    }
}

/**
* `ListValue` is a wrapper around a repeated field of values.  The JSON representation for `ListValue` is JSON array.
*/
export class ProtobufListValue {
    /**
    * Repeated field of dynamically typed values.
    */
    'values'?: Array<ProtobufValue>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<ProtobufValue>"
        }    ];

    static getAttributeTypeMap() {
        return ProtobufListValue.attributeTypeMap;
    }
}

/**
* `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
*/
export class ProtobufNullValue {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ProtobufNullValue.attributeTypeMap;
    }
}

/**
* `Struct` represents a structured data value, consisting of fields which map to dynamically typed values. In some languages, `Struct` might be supported by a native representation. For example, in scripting languages like JS a struct is represented as an object. The details of that representation are described together with the proto support for the language.  The JSON representation for `Struct` is JSON object.
*/
export class ProtobufStruct {
    /**
    * Unordered map of dynamically typed values.
    */
    'fields'?: { [key: string]: ProtobufValue; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fields",
            "baseName": "fields",
            "type": "{ [key: string]: ProtobufValue; }"
        }    ];

    static getAttributeTypeMap() {
        return ProtobufStruct.attributeTypeMap;
    }
}

/**
* `Value` represents a dynamically typed value which can be either null, a number, a string, a boolean, a recursive struct value, or a list of values. A producer of value is expected to set one of that variants, absence of any variant indicates an error.  The JSON representation for `Value` is JSON value.
*/
export class ProtobufValue {
    /**
    * Represents a null value.
    */
    'nullValue'?: ProtobufNullValue;
    /**
    * Represents a double value.
    */
    'numberValue'?: number;
    /**
    * Represents a string value.
    */
    'stringValue'?: string;
    /**
    * Represents a boolean value.
    */
    'boolValue'?: boolean;
    /**
    * Represents a structured value.
    */
    'structValue'?: ProtobufStruct;
    /**
    * Represents a repeated `Value`.
    */
    'listValue'?: ProtobufListValue;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nullValue",
            "baseName": "null_value",
            "type": "ProtobufNullValue"
        },
        {
            "name": "numberValue",
            "baseName": "number_value",
            "type": "number"
        },
        {
            "name": "stringValue",
            "baseName": "string_value",
            "type": "string"
        },
        {
            "name": "boolValue",
            "baseName": "bool_value",
            "type": "boolean"
        },
        {
            "name": "structValue",
            "baseName": "struct_value",
            "type": "ProtobufStruct"
        },
        {
            "name": "listValue",
            "baseName": "list_value",
            "type": "ProtobufListValue"
        }    ];

    static getAttributeTypeMap() {
        return ProtobufValue.attributeTypeMap;
    }
}

/**
*  - UNDEFINED: Default: no quality of service specified.
*/
export class QualityOfServiceTier {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return QualityOfServiceTier.attributeTypeMap;
    }
}

/**
* Encapsulates a resource name and value.
*/
export class ResourcesResourceEntry {
    /**
    * Resource name.
    */
    'name'?: ResourcesResourceName;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "ResourcesResourceName"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ResourcesResourceEntry.attributeTypeMap;
    }
}

/**
* Known resource names.   - EPHEMERAL_STORAGE: For Kubernetes-based deployments, pods use ephemeral local storage for scratch space, caching, and for logs.
*/
export class ResourcesResourceName {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ResourcesResourceName.attributeTypeMap;
    }
}

export class RuntimeMetadataRuntimeType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RuntimeMetadataRuntimeType.attributeTypeMap;
    }
}

export class SchemaColumnSchemaColumnType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SchemaColumnSchemaColumnType.attributeTypeMap;
    }
}

export class SchemaTypeSchemaColumn {
    'name'?: string;
    /**
    * The column type. This allows a limited set of types currently.
    */
    'type'?: SchemaColumnSchemaColumnType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "SchemaColumnSchemaColumnType"
        }    ];

    static getAttributeTypeMap() {
        return SchemaTypeSchemaColumn.attributeTypeMap;
    }
}

/**
*  - ANY: Default case, indicates the client can tolerate either mounting options.  - ENV_VAR: ENV_VAR indicates the secret needs to be mounted as an environment variable.  - FILE: FILE indicates the secret needs to be mounted as a file.
*/
export class SecretMountType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SecretMountType.attributeTypeMap;
    }
}

/**
*  - DESCENDING: By default, fields are sorted in descending order.
*/
export class SortDirection {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SortDirection.attributeTypeMap;
    }
}

/**
* The dialect of the SQL statement. This is used to validate and parse SQL statements at compilation time to avoid expensive runtime operations. If set to an unsupported dialect, no validation will be done on the statement. We support the following dialect: ansi, hive.
*/
export class SqlDialect {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SqlDialect.attributeTypeMap;
    }
}

export class StructuredDatasetTypeDatasetColumn {
    /**
    * A unique name within the schema type for the column.
    */
    'name'?: string;
    /**
    * The column type.
    */
    'literalType'?: CoreLiteralType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "literalType",
            "baseName": "literal_type",
            "type": "CoreLiteralType"
        }    ];

    static getAttributeTypeMap() {
        return StructuredDatasetTypeDatasetColumn.attributeTypeMap;
    }
}

/**
* Includes the broad category of machine used for this specific task execution.   - DEFAULT: The default instance class configured for the flyte application platform.  - INTERRUPTIBLE: The instance class configured for interruptible tasks.
*/
export class TaskExecutionMetadataInstanceClass {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TaskExecutionMetadataInstanceClass.attributeTypeMap;
    }
}

export class TaskLogMessageFormat {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TaskLogMessageFormat.attributeTypeMap;
    }
}

/**
* - FAIL_IMMEDIATELY: FAIL_IMMEDIATELY instructs the system to fail as soon as a node fails in the workflow. It'll automatically abort all currently running nodes and clean up resources before finally marking the workflow executions as failed.  - FAIL_AFTER_EXECUTABLE_NODES_COMPLETE: FAIL_AFTER_EXECUTABLE_NODES_COMPLETE instructs the system to make as much progress as it can. The system will not alter the dependencies of the execution graph so any node that depend on the failed node will not be run. Other nodes that will be executed to completion before cleaning up resources and marking the workflow execution as failed.
*/
export class WorkflowMetadataOnFailurePolicy {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return WorkflowMetadataOnFailurePolicy.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "AdminAbortMetadata": AdminAbortMetadata,
    "AdminAnnotations": AdminAnnotations,
    "AdminAuth": AdminAuth,
    "AdminAuthRole": AdminAuthRole,
    "AdminClusterAssignment": AdminClusterAssignment,
    "AdminClusterResourceAttributes": AdminClusterResourceAttributes,
    "AdminCronSchedule": AdminCronSchedule,
    "AdminDescription": AdminDescription,
    "AdminDescriptionEntity": AdminDescriptionEntity,
    "AdminDescriptionEntityList": AdminDescriptionEntityList,
    "AdminDescriptionFormat": AdminDescriptionFormat,
    "AdminDomain": AdminDomain,
    "AdminEmailNotification": AdminEmailNotification,
    "AdminEnvs": AdminEnvs,
    "AdminExecution": AdminExecution,
    "AdminExecutionClosure": AdminExecutionClosure,
    "AdminExecutionClusterLabel": AdminExecutionClusterLabel,
    "AdminExecutionCreateRequest": AdminExecutionCreateRequest,
    "AdminExecutionCreateResponse": AdminExecutionCreateResponse,
    "AdminExecutionList": AdminExecutionList,
    "AdminExecutionMetadata": AdminExecutionMetadata,
    "AdminExecutionQueueAttributes": AdminExecutionQueueAttributes,
    "AdminExecutionRecoverRequest": AdminExecutionRecoverRequest,
    "AdminExecutionRelaunchRequest": AdminExecutionRelaunchRequest,
    "AdminExecutionSpec": AdminExecutionSpec,
    "AdminExecutionState": AdminExecutionState,
    "AdminExecutionStateChangeDetails": AdminExecutionStateChangeDetails,
    "AdminExecutionTerminateRequest": AdminExecutionTerminateRequest,
    "AdminExecutionTerminateResponse": AdminExecutionTerminateResponse,
    "AdminExecutionUpdateRequest": AdminExecutionUpdateRequest,
    "AdminExecutionUpdateResponse": AdminExecutionUpdateResponse,
    "AdminFixedRate": AdminFixedRate,
    "AdminFixedRateUnit": AdminFixedRateUnit,
    "AdminFlyteURLs": AdminFlyteURLs,
    "AdminGetVersionResponse": AdminGetVersionResponse,
    "AdminLabels": AdminLabels,
    "AdminLaunchPlan": AdminLaunchPlan,
    "AdminLaunchPlanClosure": AdminLaunchPlanClosure,
    "AdminLaunchPlanCreateRequest": AdminLaunchPlanCreateRequest,
    "AdminLaunchPlanCreateResponse": AdminLaunchPlanCreateResponse,
    "AdminLaunchPlanList": AdminLaunchPlanList,
    "AdminLaunchPlanMetadata": AdminLaunchPlanMetadata,
    "AdminLaunchPlanSpec": AdminLaunchPlanSpec,
    "AdminLaunchPlanState": AdminLaunchPlanState,
    "AdminLaunchPlanUpdateRequest": AdminLaunchPlanUpdateRequest,
    "AdminLaunchPlanUpdateResponse": AdminLaunchPlanUpdateResponse,
    "AdminListMatchableAttributesResponse": AdminListMatchableAttributesResponse,
    "AdminLiteralMapBlob": AdminLiteralMapBlob,
    "AdminMatchableAttributesConfiguration": AdminMatchableAttributesConfiguration,
    "AdminMatchableResource": AdminMatchableResource,
    "AdminMatchingAttributes": AdminMatchingAttributes,
    "AdminNamedEntity": AdminNamedEntity,
    "AdminNamedEntityIdentifier": AdminNamedEntityIdentifier,
    "AdminNamedEntityIdentifierList": AdminNamedEntityIdentifierList,
    "AdminNamedEntityList": AdminNamedEntityList,
    "AdminNamedEntityMetadata": AdminNamedEntityMetadata,
    "AdminNamedEntityState": AdminNamedEntityState,
    "AdminNamedEntityUpdateRequest": AdminNamedEntityUpdateRequest,
    "AdminNamedEntityUpdateResponse": AdminNamedEntityUpdateResponse,
    "AdminNodeExecutionClosure": AdminNodeExecutionClosure,
    "AdminNodeExecutionEventRequest": AdminNodeExecutionEventRequest,
    "AdminNodeExecutionEventResponse": AdminNodeExecutionEventResponse,
    "AdminNodeExecutionGetDataResponse": AdminNodeExecutionGetDataResponse,
    "AdminNodeExecutionList": AdminNodeExecutionList,
    "AdminNodeExecutionMetaData": AdminNodeExecutionMetaData,
    "AdminNotification": AdminNotification,
    "AdminNotificationList": AdminNotificationList,
    "AdminPagerDutyNotification": AdminPagerDutyNotification,
    "AdminPluginOverride": AdminPluginOverride,
    "AdminPluginOverrides": AdminPluginOverrides,
    "AdminProject": AdminProject,
    "AdminProjectAttributes": AdminProjectAttributes,
    "AdminProjectAttributesDeleteRequest": AdminProjectAttributesDeleteRequest,
    "AdminProjectAttributesDeleteResponse": AdminProjectAttributesDeleteResponse,
    "AdminProjectAttributesGetResponse": AdminProjectAttributesGetResponse,
    "AdminProjectAttributesUpdateRequest": AdminProjectAttributesUpdateRequest,
    "AdminProjectAttributesUpdateResponse": AdminProjectAttributesUpdateResponse,
    "AdminProjectDomainAttributes": AdminProjectDomainAttributes,
    "AdminProjectDomainAttributesDeleteRequest": AdminProjectDomainAttributesDeleteRequest,
    "AdminProjectDomainAttributesDeleteResponse": AdminProjectDomainAttributesDeleteResponse,
    "AdminProjectDomainAttributesGetResponse": AdminProjectDomainAttributesGetResponse,
    "AdminProjectDomainAttributesUpdateRequest": AdminProjectDomainAttributesUpdateRequest,
    "AdminProjectDomainAttributesUpdateResponse": AdminProjectDomainAttributesUpdateResponse,
    "AdminProjectRegisterRequest": AdminProjectRegisterRequest,
    "AdminProjectRegisterResponse": AdminProjectRegisterResponse,
    "AdminProjectUpdateResponse": AdminProjectUpdateResponse,
    "AdminProjects": AdminProjects,
    "AdminRawOutputDataConfig": AdminRawOutputDataConfig,
    "AdminReason": AdminReason,
    "AdminSchedule": AdminSchedule,
    "AdminSlackNotification": AdminSlackNotification,
    "AdminSort": AdminSort,
    "AdminSourceCode": AdminSourceCode,
    "AdminSystemMetadata": AdminSystemMetadata,
    "AdminTask": AdminTask,
    "AdminTaskClosure": AdminTaskClosure,
    "AdminTaskExecutionClosure": AdminTaskExecutionClosure,
    "AdminTaskExecutionEventRequest": AdminTaskExecutionEventRequest,
    "AdminTaskExecutionEventResponse": AdminTaskExecutionEventResponse,
    "AdminTaskExecutionGetDataResponse": AdminTaskExecutionGetDataResponse,
    "AdminTaskExecutionList": AdminTaskExecutionList,
    "AdminTaskList": AdminTaskList,
    "AdminTaskResourceAttributes": AdminTaskResourceAttributes,
    "AdminTaskResourceSpec": AdminTaskResourceSpec,
    "AdminTaskSpec": AdminTaskSpec,
    "AdminUrlBlob": AdminUrlBlob,
    "AdminVersion": AdminVersion,
    "AdminWorkflow": AdminWorkflow,
    "AdminWorkflowAttributes": AdminWorkflowAttributes,
    "AdminWorkflowAttributesDeleteRequest": AdminWorkflowAttributesDeleteRequest,
    "AdminWorkflowAttributesDeleteResponse": AdminWorkflowAttributesDeleteResponse,
    "AdminWorkflowAttributesGetResponse": AdminWorkflowAttributesGetResponse,
    "AdminWorkflowAttributesUpdateRequest": AdminWorkflowAttributesUpdateRequest,
    "AdminWorkflowAttributesUpdateResponse": AdminWorkflowAttributesUpdateResponse,
    "AdminWorkflowClosure": AdminWorkflowClosure,
    "AdminWorkflowCreateRequest": AdminWorkflowCreateRequest,
    "AdminWorkflowCreateResponse": AdminWorkflowCreateResponse,
    "AdminWorkflowExecutionConfig": AdminWorkflowExecutionConfig,
    "AdminWorkflowExecutionEventRequest": AdminWorkflowExecutionEventRequest,
    "AdminWorkflowExecutionEventResponse": AdminWorkflowExecutionEventResponse,
    "AdminWorkflowExecutionGetDataResponse": AdminWorkflowExecutionGetDataResponse,
    "AdminWorkflowExecutionGetMetricsResponse": AdminWorkflowExecutionGetMetricsResponse,
    "AdminWorkflowList": AdminWorkflowList,
    "AdminWorkflowSpec": AdminWorkflowSpec,
    "BlobTypeBlobDimensionality": BlobTypeBlobDimensionality,
    "CatalogReservationStatus": CatalogReservationStatus,
    "ComparisonExpressionOperator": ComparisonExpressionOperator,
    "ConjunctionExpressionLogicalOperator": ConjunctionExpressionLogicalOperator,
    "ConnectionSetIdList": ConnectionSetIdList,
    "ContainerArchitecture": ContainerArchitecture,
    "CoreAlias": CoreAlias,
    "CoreApproveCondition": CoreApproveCondition,
    "CoreArrayNode": CoreArrayNode,
    "CoreBinary": CoreBinary,
    "CoreBinding": CoreBinding,
    "CoreBindingData": CoreBindingData,
    "CoreBindingDataCollection": CoreBindingDataCollection,
    "CoreBindingDataMap": CoreBindingDataMap,
    "CoreBlob": CoreBlob,
    "CoreBlobMetadata": CoreBlobMetadata,
    "CoreBlobType": CoreBlobType,
    "CoreBooleanExpression": CoreBooleanExpression,
    "CoreBranchNode": CoreBranchNode,
    "CoreCatalogArtifactTag": CoreCatalogArtifactTag,
    "CoreCatalogCacheStatus": CoreCatalogCacheStatus,
    "CoreCatalogMetadata": CoreCatalogMetadata,
    "CoreComparisonExpression": CoreComparisonExpression,
    "CoreCompiledTask": CoreCompiledTask,
    "CoreCompiledWorkflow": CoreCompiledWorkflow,
    "CoreCompiledWorkflowClosure": CoreCompiledWorkflowClosure,
    "CoreConjunctionExpression": CoreConjunctionExpression,
    "CoreConnectionSet": CoreConnectionSet,
    "CoreContainer": CoreContainer,
    "CoreContainerPort": CoreContainerPort,
    "CoreDataLoadingConfig": CoreDataLoadingConfig,
    "CoreEnumType": CoreEnumType,
    "CoreError": CoreError,
    "CoreExecutionError": CoreExecutionError,
    "CoreExtendedResources": CoreExtendedResources,
    "CoreGPUAccelerator": CoreGPUAccelerator,
    "CoreGateNode": CoreGateNode,
    "CoreIOStrategy": CoreIOStrategy,
    "CoreIdentifier": CoreIdentifier,
    "CoreIdentity": CoreIdentity,
    "CoreIfBlock": CoreIfBlock,
    "CoreIfElseBlock": CoreIfElseBlock,
    "CoreK8sObjectMetadata": CoreK8sObjectMetadata,
    "CoreK8sPod": CoreK8sPod,
    "CoreKeyValuePair": CoreKeyValuePair,
    "CoreLiteral": CoreLiteral,
    "CoreLiteralCollection": CoreLiteralCollection,
    "CoreLiteralMap": CoreLiteralMap,
    "CoreLiteralType": CoreLiteralType,
    "CoreNode": CoreNode,
    "CoreNodeExecutionIdentifier": CoreNodeExecutionIdentifier,
    "CoreNodeExecutionPhase": CoreNodeExecutionPhase,
    "CoreNodeMetadata": CoreNodeMetadata,
    "CoreOAuth2Client": CoreOAuth2Client,
    "CoreOAuth2TokenRequest": CoreOAuth2TokenRequest,
    "CoreOAuth2TokenRequestType": CoreOAuth2TokenRequestType,
    "CoreOperand": CoreOperand,
    "CoreOutputReference": CoreOutputReference,
    "CoreParameter": CoreParameter,
    "CoreParameterMap": CoreParameterMap,
    "CorePrimitive": CorePrimitive,
    "CorePromiseAttribute": CorePromiseAttribute,
    "CoreQualityOfService": CoreQualityOfService,
    "CoreQualityOfServiceSpec": CoreQualityOfServiceSpec,
    "CoreResourceType": CoreResourceType,
    "CoreResources": CoreResources,
    "CoreRetryStrategy": CoreRetryStrategy,
    "CoreRuntimeMetadata": CoreRuntimeMetadata,
    "CoreScalar": CoreScalar,
    "CoreSchema": CoreSchema,
    "CoreSchemaType": CoreSchemaType,
    "CoreSecret": CoreSecret,
    "CoreSecurityContext": CoreSecurityContext,
    "CoreSignalCondition": CoreSignalCondition,
    "CoreSimpleType": CoreSimpleType,
    "CoreSleepCondition": CoreSleepCondition,
    "CoreSpan": CoreSpan,
    "CoreSql": CoreSql,
    "CoreStructuredDataset": CoreStructuredDataset,
    "CoreStructuredDatasetMetadata": CoreStructuredDatasetMetadata,
    "CoreStructuredDatasetType": CoreStructuredDatasetType,
    "CoreTaskExecutionIdentifier": CoreTaskExecutionIdentifier,
    "CoreTaskExecutionPhase": CoreTaskExecutionPhase,
    "CoreTaskLog": CoreTaskLog,
    "CoreTaskMetadata": CoreTaskMetadata,
    "CoreTaskNode": CoreTaskNode,
    "CoreTaskNodeOverrides": CoreTaskNodeOverrides,
    "CoreTaskTemplate": CoreTaskTemplate,
    "CoreTypeAnnotation": CoreTypeAnnotation,
    "CoreTypeStructure": CoreTypeStructure,
    "CoreTypedInterface": CoreTypedInterface,
    "CoreUnion": CoreUnion,
    "CoreUnionInfo": CoreUnionInfo,
    "CoreUnionType": CoreUnionType,
    "CoreVariable": CoreVariable,
    "CoreVariableMap": CoreVariableMap,
    "CoreVoid": CoreVoid,
    "CoreWorkflowExecutionIdentifier": CoreWorkflowExecutionIdentifier,
    "CoreWorkflowExecutionPhase": CoreWorkflowExecutionPhase,
    "CoreWorkflowMetadata": CoreWorkflowMetadata,
    "CoreWorkflowMetadataDefaults": CoreWorkflowMetadataDefaults,
    "CoreWorkflowNode": CoreWorkflowNode,
    "CoreWorkflowTemplate": CoreWorkflowTemplate,
    "DataLoadingConfigLiteralMapFormat": DataLoadingConfigLiteralMapFormat,
    "EventEventReason": EventEventReason,
    "EventExternalResourceInfo": EventExternalResourceInfo,
    "EventNodeExecutionEvent": EventNodeExecutionEvent,
    "EventParentNodeExecutionMetadata": EventParentNodeExecutionMetadata,
    "EventParentTaskExecutionMetadata": EventParentTaskExecutionMetadata,
    "EventResourcePoolInfo": EventResourcePoolInfo,
    "EventTaskExecutionEvent": EventTaskExecutionEvent,
    "EventWorkflowExecutionEvent": EventWorkflowExecutionEvent,
    "ExecutionErrorErrorKind": ExecutionErrorErrorKind,
    "ExecutionMetadataExecutionMode": ExecutionMetadataExecutionMode,
    "FlyteidladminDynamicWorkflowNodeMetadata": FlyteidladminDynamicWorkflowNodeMetadata,
    "FlyteidladminNodeExecution": FlyteidladminNodeExecution,
    "FlyteidladminTaskCreateRequest": FlyteidladminTaskCreateRequest,
    "FlyteidladminTaskCreateResponse": FlyteidladminTaskCreateResponse,
    "FlyteidladminTaskExecution": FlyteidladminTaskExecution,
    "FlyteidladminTaskNodeMetadata": FlyteidladminTaskNodeMetadata,
    "FlyteidladminWorkflowNodeMetadata": FlyteidladminWorkflowNodeMetadata,
    "FlyteidleventDynamicWorkflowNodeMetadata": FlyteidleventDynamicWorkflowNodeMetadata,
    "FlyteidleventTaskExecutionMetadata": FlyteidleventTaskExecutionMetadata,
    "FlyteidleventTaskNodeMetadata": FlyteidleventTaskNodeMetadata,
    "FlyteidleventWorkflowNodeMetadata": FlyteidleventWorkflowNodeMetadata,
    "IOStrategyDownloadMode": IOStrategyDownloadMode,
    "IOStrategyUploadMode": IOStrategyUploadMode,
    "PluginOverrideMissingPluginBehavior": PluginOverrideMissingPluginBehavior,
    "ProjectProjectState": ProjectProjectState,
    "ProtobufListValue": ProtobufListValue,
    "ProtobufNullValue": ProtobufNullValue,
    "ProtobufStruct": ProtobufStruct,
    "ProtobufValue": ProtobufValue,
    "QualityOfServiceTier": QualityOfServiceTier,
    "ResourcesResourceEntry": ResourcesResourceEntry,
    "ResourcesResourceName": ResourcesResourceName,
    "RuntimeMetadataRuntimeType": RuntimeMetadataRuntimeType,
    "SchemaColumnSchemaColumnType": SchemaColumnSchemaColumnType,
    "SchemaTypeSchemaColumn": SchemaTypeSchemaColumn,
    "SecretMountType": SecretMountType,
    "SortDirection": SortDirection,
    "SqlDialect": SqlDialect,
    "StructuredDatasetTypeDatasetColumn": StructuredDatasetTypeDatasetColumn,
    "TaskExecutionMetadataInstanceClass": TaskExecutionMetadataInstanceClass,
    "TaskLogMessageFormat": TaskLogMessageFormat,
    "WorkflowMetadataOnFailurePolicy": WorkflowMetadataOnFailurePolicy,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AdminServiceApiApiKeys {
}

export class AdminServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AdminServiceApiApiKeys, value: string) {
        (this.authentications as any)[AdminServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Triggers the creation of a :ref:`ref_flyteidl.admin.Execution`
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createExecution (body: AdminExecutionCreateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminExecutionCreateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/executions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createExecution.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminExecutionCreateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminExecutionCreateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminExecutionCreateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create and upload a :ref:`ref_flyteidl.admin.LaunchPlan` definition
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createLaunchPlan (body: AdminLaunchPlanCreateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminLaunchPlanCreateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/launch_plans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createLaunchPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminLaunchPlanCreateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminLaunchPlanCreateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminLaunchPlanCreateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Indicates a :ref:`ref_flyteidl.event.NodeExecutionEvent` has occurred.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createNodeEvent (body: AdminNodeExecutionEventRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminNodeExecutionEventResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/events/nodes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNodeEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminNodeExecutionEventRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminNodeExecutionEventResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminNodeExecutionEventResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create and upload a :ref:`ref_flyteidl.admin.Task` definition
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createTask (body: FlyteidladminTaskCreateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: FlyteidladminTaskCreateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/tasks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTask.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "FlyteidladminTaskCreateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FlyteidladminTaskCreateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlyteidladminTaskCreateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Indicates a :ref:`ref_flyteidl.event.TaskExecutionEvent` has occurred.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createTaskEvent (body: AdminTaskExecutionEventRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminTaskExecutionEventResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/events/tasks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTaskEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminTaskExecutionEventRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminTaskExecutionEventResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminTaskExecutionEventResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create and upload a :ref:`ref_flyteidl.admin.Workflow` definition
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createWorkflow (body: AdminWorkflowCreateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminWorkflowCreateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/workflows';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createWorkflow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminWorkflowCreateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminWorkflowCreateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminWorkflowCreateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Indicates a :ref:`ref_flyteidl.event.WorkflowExecutionEvent` has occurred.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createWorkflowEvent (body: AdminWorkflowExecutionEventRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminWorkflowExecutionEventResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/events/workflows';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createWorkflowEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminWorkflowExecutionEventRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminWorkflowExecutionEventResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminWorkflowExecutionEventResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param project Unique project id which this set of attributes references. +required
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public deleteProjectAttributes (project: string, body: AdminProjectAttributesDeleteRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminProjectAttributesDeleteResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/project_attributes/{project}'
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteProjectAttributes.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteProjectAttributes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminProjectAttributesDeleteRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminProjectAttributesDeleteResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminProjectAttributesDeleteResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param project Unique project id which this set of attributes references. +required
     * @param domain Unique domain id which this set of attributes references. +required
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public deleteProjectDomainAttributes (project: string, domain: string, body: AdminProjectDomainAttributesDeleteRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminProjectDomainAttributesDeleteResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/project_domain_attributes/{project}/{domain}'
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteProjectDomainAttributes.');
        }

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling deleteProjectDomainAttributes.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteProjectDomainAttributes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminProjectDomainAttributesDeleteRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminProjectDomainAttributesDeleteResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminProjectDomainAttributesDeleteResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param project Unique project id which this set of attributes references. +required
     * @param domain Unique domain id which this set of attributes references. +required
     * @param workflow Workflow name which this set of attributes references. +required
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public deleteWorkflowAttributes (project: string, domain: string, workflow: string, body: AdminWorkflowAttributesDeleteRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminWorkflowAttributesDeleteResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/workflow_attributes/{project}/{domain}/{workflow}'
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling deleteWorkflowAttributes.');
        }

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling deleteWorkflowAttributes.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling deleteWorkflowAttributes.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteWorkflowAttributes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminWorkflowAttributesDeleteRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminWorkflowAttributesDeleteResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminWorkflowAttributesDeleteResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch the active version of a :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {*} [options] Override http request options.
     */
    public getActiveLaunchPlan (idProject: string, idDomain: string, idName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminLaunchPlan;  }> {
        const localVarPath = this.basePath + '/api/v1/active_launch_plans/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling getActiveLaunchPlan.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling getActiveLaunchPlan.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling getActiveLaunchPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminLaunchPlan;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminLaunchPlan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a :ref:`ref_flyteidl.admin.DescriptionEntity` object.
     * @param idResourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource.
     * @param idVersion Specific version of the resource.
     * @param {*} [options] Override http request options.
     */
    public getDescriptionEntity (idResourceType: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', idProject: string, idDomain: string, idName: string, idVersion: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminDescriptionEntity;  }> {
        const localVarPath = this.basePath + '/api/v1/description_entities/{id.resource_type}/{id.project}/{id.domain}/{id.name}/{id.version}'
            .replace('{' + 'id.resource_type' + '}', encodeURIComponent(String(idResourceType)))
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)))
            .replace('{' + 'id.version' + '}', encodeURIComponent(String(idVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idResourceType' is not null or undefined
        if (idResourceType === null || idResourceType === undefined) {
            throw new Error('Required parameter idResourceType was null or undefined when calling getDescriptionEntity.');
        }

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling getDescriptionEntity.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling getDescriptionEntity.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling getDescriptionEntity.');
        }

        // verify required parameter 'idVersion' is not null or undefined
        if (idVersion === null || idVersion === undefined) {
            throw new Error('Required parameter idVersion was null or undefined when calling getDescriptionEntity.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminDescriptionEntity;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminDescriptionEntity");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches a :ref:`ref_flyteidl.admin.Execution`.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User or system provided value for the resource.
     * @param {*} [options] Override http request options.
     */
    public getExecution (idProject: string, idDomain: string, idName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminExecution;  }> {
        const localVarPath = this.basePath + '/api/v1/executions/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling getExecution.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling getExecution.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling getExecution.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminExecution;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminExecution");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.Execution`.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User or system provided value for the resource.
     * @param {*} [options] Override http request options.
     */
    public getExecutionData (idProject: string, idDomain: string, idName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminWorkflowExecutionGetDataResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/data/executions/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling getExecutionData.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling getExecutionData.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling getExecutionData.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminWorkflowExecutionGetDataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminWorkflowExecutionGetDataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches runtime metrics for a :ref:`ref_flyteidl.admin.Execution`.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User or system provided value for the resource.
     * @param depth depth defines the number of Flyte entity levels to traverse when breaking down execution details.
     * @param {*} [options] Override http request options.
     */
    public getExecutionMetrics (idProject: string, idDomain: string, idName: string, depth?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminWorkflowExecutionGetMetricsResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/metrics/executions/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling getExecutionMetrics.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling getExecutionMetrics.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling getExecutionMetrics.');
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminWorkflowExecutionGetMetricsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminWorkflowExecutionGetMetricsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a :ref:`ref_flyteidl.admin.LaunchPlan` definition.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource.
     * @param idVersion Specific version of the resource.
     * @param idResourceType Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request options.
     */
    public getLaunchPlan (idProject: string, idDomain: string, idName: string, idVersion: string, idResourceType?: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminLaunchPlan;  }> {
        const localVarPath = this.basePath + '/api/v1/launch_plans/{id.project}/{id.domain}/{id.name}/{id.version}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)))
            .replace('{' + 'id.version' + '}', encodeURIComponent(String(idVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling getLaunchPlan.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling getLaunchPlan.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling getLaunchPlan.');
        }

        // verify required parameter 'idVersion' is not null or undefined
        if (idVersion === null || idVersion === undefined) {
            throw new Error('Required parameter idVersion was null or undefined when calling getLaunchPlan.');
        }

        if (idResourceType !== undefined) {
            localVarQueryParameters['id.resource_type'] = ObjectSerializer.serialize(idResourceType, "'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminLaunchPlan;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminLaunchPlan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a :ref:`ref_flyteidl.admin.NamedEntity` object.
     * @param resourceType Resource type of the metadata to get. One of Task, Workflow or LaunchPlan. +required
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param {*} [options] Override http request options.
     */
    public getNamedEntity (resourceType: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', idProject: string, idDomain: string, idName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminNamedEntity;  }> {
        const localVarPath = this.basePath + '/api/v1/named_entities/{resource_type}/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'resource_type' + '}', encodeURIComponent(String(resourceType)))
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceType' is not null or undefined
        if (resourceType === null || resourceType === undefined) {
            throw new Error('Required parameter resourceType was null or undefined when calling getNamedEntity.');
        }

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling getNamedEntity.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling getNamedEntity.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling getNamedEntity.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminNamedEntity;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminNamedEntity");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches a :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param idExecutionIdProject Name of the project the resource belongs to.
     * @param idExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idExecutionIdName User or system provided value for the resource.
     * @param idNodeId 
     * @param {*} [options] Override http request options.
     */
    public getNodeExecution (idExecutionIdProject: string, idExecutionIdDomain: string, idExecutionIdName: string, idNodeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: FlyteidladminNodeExecution;  }> {
        const localVarPath = this.basePath + '/api/v1/node_executions/{id.execution_id.project}/{id.execution_id.domain}/{id.execution_id.name}/{id.node_id}'
            .replace('{' + 'id.execution_id.project' + '}', encodeURIComponent(String(idExecutionIdProject)))
            .replace('{' + 'id.execution_id.domain' + '}', encodeURIComponent(String(idExecutionIdDomain)))
            .replace('{' + 'id.execution_id.name' + '}', encodeURIComponent(String(idExecutionIdName)))
            .replace('{' + 'id.node_id' + '}', encodeURIComponent(String(idNodeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idExecutionIdProject' is not null or undefined
        if (idExecutionIdProject === null || idExecutionIdProject === undefined) {
            throw new Error('Required parameter idExecutionIdProject was null or undefined when calling getNodeExecution.');
        }

        // verify required parameter 'idExecutionIdDomain' is not null or undefined
        if (idExecutionIdDomain === null || idExecutionIdDomain === undefined) {
            throw new Error('Required parameter idExecutionIdDomain was null or undefined when calling getNodeExecution.');
        }

        // verify required parameter 'idExecutionIdName' is not null or undefined
        if (idExecutionIdName === null || idExecutionIdName === undefined) {
            throw new Error('Required parameter idExecutionIdName was null or undefined when calling getNodeExecution.');
        }

        // verify required parameter 'idNodeId' is not null or undefined
        if (idNodeId === null || idNodeId === undefined) {
            throw new Error('Required parameter idNodeId was null or undefined when calling getNodeExecution.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FlyteidladminNodeExecution;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlyteidladminNodeExecution");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param idExecutionIdProject Name of the project the resource belongs to.
     * @param idExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idExecutionIdName User or system provided value for the resource.
     * @param idNodeId 
     * @param {*} [options] Override http request options.
     */
    public getNodeExecutionData (idExecutionIdProject: string, idExecutionIdDomain: string, idExecutionIdName: string, idNodeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminNodeExecutionGetDataResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/data/node_executions/{id.execution_id.project}/{id.execution_id.domain}/{id.execution_id.name}/{id.node_id}'
            .replace('{' + 'id.execution_id.project' + '}', encodeURIComponent(String(idExecutionIdProject)))
            .replace('{' + 'id.execution_id.domain' + '}', encodeURIComponent(String(idExecutionIdDomain)))
            .replace('{' + 'id.execution_id.name' + '}', encodeURIComponent(String(idExecutionIdName)))
            .replace('{' + 'id.node_id' + '}', encodeURIComponent(String(idNodeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idExecutionIdProject' is not null or undefined
        if (idExecutionIdProject === null || idExecutionIdProject === undefined) {
            throw new Error('Required parameter idExecutionIdProject was null or undefined when calling getNodeExecutionData.');
        }

        // verify required parameter 'idExecutionIdDomain' is not null or undefined
        if (idExecutionIdDomain === null || idExecutionIdDomain === undefined) {
            throw new Error('Required parameter idExecutionIdDomain was null or undefined when calling getNodeExecutionData.');
        }

        // verify required parameter 'idExecutionIdName' is not null or undefined
        if (idExecutionIdName === null || idExecutionIdName === undefined) {
            throw new Error('Required parameter idExecutionIdName was null or undefined when calling getNodeExecutionData.');
        }

        // verify required parameter 'idNodeId' is not null or undefined
        if (idNodeId === null || idNodeId === undefined) {
            throw new Error('Required parameter idNodeId was null or undefined when calling getNodeExecutionData.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminNodeExecutionGetDataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminNodeExecutionGetDataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param project Unique project id which this set of attributes references. +required
     * @param resourceType Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request options.
     */
    public getProjectAttributes (project: string, resourceType?: 'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminProjectAttributesGetResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/project_attributes/{project}'
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling getProjectAttributes.');
        }

        if (resourceType !== undefined) {
            localVarQueryParameters['resource_type'] = ObjectSerializer.serialize(resourceType, "'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminProjectAttributesGetResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminProjectAttributesGetResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param project Unique project id which this set of attributes references. +required
     * @param domain Unique domain id which this set of attributes references. +required
     * @param resourceType Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request options.
     */
    public getProjectDomainAttributes (project: string, domain: string, resourceType?: 'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminProjectDomainAttributesGetResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/project_domain_attributes/{project}/{domain}'
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling getProjectDomainAttributes.');
        }

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling getProjectDomainAttributes.');
        }

        if (resourceType !== undefined) {
            localVarQueryParameters['resource_type'] = ObjectSerializer.serialize(resourceType, "'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminProjectDomainAttributesGetResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminProjectDomainAttributesGetResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a :ref:`ref_flyteidl.admin.Task` definition.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource.
     * @param idVersion Specific version of the resource.
     * @param idResourceType Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request options.
     */
    public getTask (idProject: string, idDomain: string, idName: string, idVersion: string, idResourceType?: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminTask;  }> {
        const localVarPath = this.basePath + '/api/v1/tasks/{id.project}/{id.domain}/{id.name}/{id.version}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)))
            .replace('{' + 'id.version' + '}', encodeURIComponent(String(idVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling getTask.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling getTask.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling getTask.');
        }

        // verify required parameter 'idVersion' is not null or undefined
        if (idVersion === null || idVersion === undefined) {
            throw new Error('Required parameter idVersion was null or undefined when calling getTask.');
        }

        if (idResourceType !== undefined) {
            localVarQueryParameters['id.resource_type'] = ObjectSerializer.serialize(idResourceType, "'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminTask;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminTask");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches a :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param idNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param idNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param idNodeExecutionIdNodeId 
     * @param idTaskIdProject Name of the project the resource belongs to.
     * @param idTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idTaskIdName User provided value for the resource.
     * @param idTaskIdVersion Specific version of the resource.
     * @param idRetryAttempt 
     * @param idTaskIdResourceType Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request options.
     */
    public getTaskExecution (idNodeExecutionIdExecutionIdProject: string, idNodeExecutionIdExecutionIdDomain: string, idNodeExecutionIdExecutionIdName: string, idNodeExecutionIdNodeId: string, idTaskIdProject: string, idTaskIdDomain: string, idTaskIdName: string, idTaskIdVersion: string, idRetryAttempt: number, idTaskIdResourceType?: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', options: any = {}) : Promise<{ response: http.ClientResponse; body: FlyteidladminTaskExecution;  }> {
        const localVarPath = this.basePath + '/api/v1/task_executions/{id.node_execution_id.execution_id.project}/{id.node_execution_id.execution_id.domain}/{id.node_execution_id.execution_id.name}/{id.node_execution_id.node_id}/{id.task_id.project}/{id.task_id.domain}/{id.task_id.name}/{id.task_id.version}/{id.retry_attempt}'
            .replace('{' + 'id.node_execution_id.execution_id.project' + '}', encodeURIComponent(String(idNodeExecutionIdExecutionIdProject)))
            .replace('{' + 'id.node_execution_id.execution_id.domain' + '}', encodeURIComponent(String(idNodeExecutionIdExecutionIdDomain)))
            .replace('{' + 'id.node_execution_id.execution_id.name' + '}', encodeURIComponent(String(idNodeExecutionIdExecutionIdName)))
            .replace('{' + 'id.node_execution_id.node_id' + '}', encodeURIComponent(String(idNodeExecutionIdNodeId)))
            .replace('{' + 'id.task_id.project' + '}', encodeURIComponent(String(idTaskIdProject)))
            .replace('{' + 'id.task_id.domain' + '}', encodeURIComponent(String(idTaskIdDomain)))
            .replace('{' + 'id.task_id.name' + '}', encodeURIComponent(String(idTaskIdName)))
            .replace('{' + 'id.task_id.version' + '}', encodeURIComponent(String(idTaskIdVersion)))
            .replace('{' + 'id.retry_attempt' + '}', encodeURIComponent(String(idRetryAttempt)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idNodeExecutionIdExecutionIdProject' is not null or undefined
        if (idNodeExecutionIdExecutionIdProject === null || idNodeExecutionIdExecutionIdProject === undefined) {
            throw new Error('Required parameter idNodeExecutionIdExecutionIdProject was null or undefined when calling getTaskExecution.');
        }

        // verify required parameter 'idNodeExecutionIdExecutionIdDomain' is not null or undefined
        if (idNodeExecutionIdExecutionIdDomain === null || idNodeExecutionIdExecutionIdDomain === undefined) {
            throw new Error('Required parameter idNodeExecutionIdExecutionIdDomain was null or undefined when calling getTaskExecution.');
        }

        // verify required parameter 'idNodeExecutionIdExecutionIdName' is not null or undefined
        if (idNodeExecutionIdExecutionIdName === null || idNodeExecutionIdExecutionIdName === undefined) {
            throw new Error('Required parameter idNodeExecutionIdExecutionIdName was null or undefined when calling getTaskExecution.');
        }

        // verify required parameter 'idNodeExecutionIdNodeId' is not null or undefined
        if (idNodeExecutionIdNodeId === null || idNodeExecutionIdNodeId === undefined) {
            throw new Error('Required parameter idNodeExecutionIdNodeId was null or undefined when calling getTaskExecution.');
        }

        // verify required parameter 'idTaskIdProject' is not null or undefined
        if (idTaskIdProject === null || idTaskIdProject === undefined) {
            throw new Error('Required parameter idTaskIdProject was null or undefined when calling getTaskExecution.');
        }

        // verify required parameter 'idTaskIdDomain' is not null or undefined
        if (idTaskIdDomain === null || idTaskIdDomain === undefined) {
            throw new Error('Required parameter idTaskIdDomain was null or undefined when calling getTaskExecution.');
        }

        // verify required parameter 'idTaskIdName' is not null or undefined
        if (idTaskIdName === null || idTaskIdName === undefined) {
            throw new Error('Required parameter idTaskIdName was null or undefined when calling getTaskExecution.');
        }

        // verify required parameter 'idTaskIdVersion' is not null or undefined
        if (idTaskIdVersion === null || idTaskIdVersion === undefined) {
            throw new Error('Required parameter idTaskIdVersion was null or undefined when calling getTaskExecution.');
        }

        // verify required parameter 'idRetryAttempt' is not null or undefined
        if (idRetryAttempt === null || idRetryAttempt === undefined) {
            throw new Error('Required parameter idRetryAttempt was null or undefined when calling getTaskExecution.');
        }

        if (idTaskIdResourceType !== undefined) {
            localVarQueryParameters['id.task_id.resource_type'] = ObjectSerializer.serialize(idTaskIdResourceType, "'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FlyteidladminTaskExecution;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FlyteidladminTaskExecution");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches input and output data for a :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param idNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param idNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param idNodeExecutionIdNodeId 
     * @param idTaskIdProject Name of the project the resource belongs to.
     * @param idTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idTaskIdName User provided value for the resource.
     * @param idTaskIdVersion Specific version of the resource.
     * @param idRetryAttempt 
     * @param idTaskIdResourceType Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request options.
     */
    public getTaskExecutionData (idNodeExecutionIdExecutionIdProject: string, idNodeExecutionIdExecutionIdDomain: string, idNodeExecutionIdExecutionIdName: string, idNodeExecutionIdNodeId: string, idTaskIdProject: string, idTaskIdDomain: string, idTaskIdName: string, idTaskIdVersion: string, idRetryAttempt: number, idTaskIdResourceType?: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminTaskExecutionGetDataResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/data/task_executions/{id.node_execution_id.execution_id.project}/{id.node_execution_id.execution_id.domain}/{id.node_execution_id.execution_id.name}/{id.node_execution_id.node_id}/{id.task_id.project}/{id.task_id.domain}/{id.task_id.name}/{id.task_id.version}/{id.retry_attempt}'
            .replace('{' + 'id.node_execution_id.execution_id.project' + '}', encodeURIComponent(String(idNodeExecutionIdExecutionIdProject)))
            .replace('{' + 'id.node_execution_id.execution_id.domain' + '}', encodeURIComponent(String(idNodeExecutionIdExecutionIdDomain)))
            .replace('{' + 'id.node_execution_id.execution_id.name' + '}', encodeURIComponent(String(idNodeExecutionIdExecutionIdName)))
            .replace('{' + 'id.node_execution_id.node_id' + '}', encodeURIComponent(String(idNodeExecutionIdNodeId)))
            .replace('{' + 'id.task_id.project' + '}', encodeURIComponent(String(idTaskIdProject)))
            .replace('{' + 'id.task_id.domain' + '}', encodeURIComponent(String(idTaskIdDomain)))
            .replace('{' + 'id.task_id.name' + '}', encodeURIComponent(String(idTaskIdName)))
            .replace('{' + 'id.task_id.version' + '}', encodeURIComponent(String(idTaskIdVersion)))
            .replace('{' + 'id.retry_attempt' + '}', encodeURIComponent(String(idRetryAttempt)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idNodeExecutionIdExecutionIdProject' is not null or undefined
        if (idNodeExecutionIdExecutionIdProject === null || idNodeExecutionIdExecutionIdProject === undefined) {
            throw new Error('Required parameter idNodeExecutionIdExecutionIdProject was null or undefined when calling getTaskExecutionData.');
        }

        // verify required parameter 'idNodeExecutionIdExecutionIdDomain' is not null or undefined
        if (idNodeExecutionIdExecutionIdDomain === null || idNodeExecutionIdExecutionIdDomain === undefined) {
            throw new Error('Required parameter idNodeExecutionIdExecutionIdDomain was null or undefined when calling getTaskExecutionData.');
        }

        // verify required parameter 'idNodeExecutionIdExecutionIdName' is not null or undefined
        if (idNodeExecutionIdExecutionIdName === null || idNodeExecutionIdExecutionIdName === undefined) {
            throw new Error('Required parameter idNodeExecutionIdExecutionIdName was null or undefined when calling getTaskExecutionData.');
        }

        // verify required parameter 'idNodeExecutionIdNodeId' is not null or undefined
        if (idNodeExecutionIdNodeId === null || idNodeExecutionIdNodeId === undefined) {
            throw new Error('Required parameter idNodeExecutionIdNodeId was null or undefined when calling getTaskExecutionData.');
        }

        // verify required parameter 'idTaskIdProject' is not null or undefined
        if (idTaskIdProject === null || idTaskIdProject === undefined) {
            throw new Error('Required parameter idTaskIdProject was null or undefined when calling getTaskExecutionData.');
        }

        // verify required parameter 'idTaskIdDomain' is not null or undefined
        if (idTaskIdDomain === null || idTaskIdDomain === undefined) {
            throw new Error('Required parameter idTaskIdDomain was null or undefined when calling getTaskExecutionData.');
        }

        // verify required parameter 'idTaskIdName' is not null or undefined
        if (idTaskIdName === null || idTaskIdName === undefined) {
            throw new Error('Required parameter idTaskIdName was null or undefined when calling getTaskExecutionData.');
        }

        // verify required parameter 'idTaskIdVersion' is not null or undefined
        if (idTaskIdVersion === null || idTaskIdVersion === undefined) {
            throw new Error('Required parameter idTaskIdVersion was null or undefined when calling getTaskExecutionData.');
        }

        // verify required parameter 'idRetryAttempt' is not null or undefined
        if (idRetryAttempt === null || idRetryAttempt === undefined) {
            throw new Error('Required parameter idRetryAttempt was null or undefined when calling getTaskExecutionData.');
        }

        if (idTaskIdResourceType !== undefined) {
            localVarQueryParameters['id.task_id.resource_type'] = ObjectSerializer.serialize(idTaskIdResourceType, "'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminTaskExecutionGetDataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminTaskExecutionGetDataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getVersion (options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminGetVersionResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/version';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminGetVersionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminGetVersionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a :ref:`ref_flyteidl.admin.Workflow` definition.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource.
     * @param idVersion Specific version of the resource.
     * @param idResourceType Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param {*} [options] Override http request options.
     */
    public getWorkflow (idProject: string, idDomain: string, idName: string, idVersion: string, idResourceType?: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminWorkflow;  }> {
        const localVarPath = this.basePath + '/api/v1/workflows/{id.project}/{id.domain}/{id.name}/{id.version}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)))
            .replace('{' + 'id.version' + '}', encodeURIComponent(String(idVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling getWorkflow.');
        }

        // verify required parameter 'idVersion' is not null or undefined
        if (idVersion === null || idVersion === undefined) {
            throw new Error('Required parameter idVersion was null or undefined when calling getWorkflow.');
        }

        if (idResourceType !== undefined) {
            localVarQueryParameters['id.resource_type'] = ObjectSerializer.serialize(idResourceType, "'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminWorkflow;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminWorkflow");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param project Unique project id which this set of attributes references. +required
     * @param domain Unique domain id which this set of attributes references. +required
     * @param workflow Workflow name which this set of attributes references. +required
     * @param resourceType Which type of matchable attributes to return. +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request options.
     */
    public getWorkflowAttributes (project: string, domain: string, workflow: string, resourceType?: 'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminWorkflowAttributesGetResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/workflow_attributes/{project}/{domain}/{workflow}'
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)))
            .replace('{' + 'workflow' + '}', encodeURIComponent(String(workflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling getWorkflowAttributes.');
        }

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling getWorkflowAttributes.');
        }

        // verify required parameter 'workflow' is not null or undefined
        if (workflow === null || workflow === undefined) {
            throw new Error('Required parameter workflow was null or undefined when calling getWorkflowAttributes.');
        }

        if (resourceType !== undefined) {
            localVarQueryParameters['resource_type'] = ObjectSerializer.serialize(resourceType, "'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminWorkflowAttributesGetResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminWorkflowAttributesGetResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List active versions of :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param project Name of the project that contains the identifiers. +required.
     * @param domain Name of the domain the identifiers belongs to within the project. +required.
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listActiveLaunchPlans (project: string, domain: string, limit?: number, token?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminLaunchPlanList;  }> {
        const localVarPath = this.basePath + '/api/v1/active_launch_plans/{project}/{domain}'
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling listActiveLaunchPlans.');
        }

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling listActiveLaunchPlans.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminLaunchPlanList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminLaunchPlanList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.
     * @param resourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listDescriptionEntities (resourceType: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', idProject: string, idDomain: string, idName: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminDescriptionEntityList;  }> {
        const localVarPath = this.basePath + '/api/v1/description_entities/{resource_type}/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'resource_type' + '}', encodeURIComponent(String(resourceType)))
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceType' is not null or undefined
        if (resourceType === null || resourceType === undefined) {
            throw new Error('Required parameter resourceType was null or undefined when calling listDescriptionEntities.');
        }

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling listDescriptionEntities.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling listDescriptionEntities.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling listDescriptionEntities.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminDescriptionEntityList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminDescriptionEntityList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.DescriptionEntity` definitions.
     * @param resourceType Identifies the specific type of resource that this identifier corresponds to.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listDescriptionEntities2 (resourceType: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', idProject: string, idDomain: string, idName?: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminDescriptionEntityList;  }> {
        const localVarPath = this.basePath + '/api/v1/description_entities/{resource_type}/{id.project}/{id.domain}'
            .replace('{' + 'resource_type' + '}', encodeURIComponent(String(resourceType)))
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceType' is not null or undefined
        if (resourceType === null || resourceType === undefined) {
            throw new Error('Required parameter resourceType was null or undefined when calling listDescriptionEntities2.');
        }

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling listDescriptionEntities2.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling listDescriptionEntities2.');
        }

        if (idName !== undefined) {
            localVarQueryParameters['id.name'] = ObjectSerializer.serialize(idName, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminDescriptionEntityList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminDescriptionEntityList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Execution`.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listExecutions (idProject: string, idDomain: string, idName?: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminExecutionList;  }> {
        const localVarPath = this.basePath + '/api/v1/executions/{id.project}/{id.domain}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling listExecutions.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling listExecutions.');
        }

        if (idName !== undefined) {
            localVarQueryParameters['id.name'] = ObjectSerializer.serialize(idName, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminExecutionList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminExecutionList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of launch plan objects.
     * @param project Name of the project that contains the identifiers. +required
     * @param domain Name of the domain the identifiers belongs to within the project. +required
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param filters Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request options.
     */
    public listLaunchPlanIds (project: string, domain: string, limit?: number, token?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', filters?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminNamedEntityIdentifierList;  }> {
        const localVarPath = this.basePath + '/api/v1/launch_plan_ids/{project}/{domain}'
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling listLaunchPlanIds.');
        }

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling listLaunchPlanIds.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminNamedEntityIdentifierList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminNamedEntityIdentifierList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listLaunchPlans (idProject: string, idDomain: string, idName: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminLaunchPlanList;  }> {
        const localVarPath = this.basePath + '/api/v1/launch_plans/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling listLaunchPlans.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling listLaunchPlans.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling listLaunchPlans.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminLaunchPlanList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminLaunchPlanList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.LaunchPlan` definitions.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listLaunchPlans2 (idProject: string, idDomain: string, idName?: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminLaunchPlanList;  }> {
        const localVarPath = this.basePath + '/api/v1/launch_plans/{id.project}/{id.domain}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling listLaunchPlans2.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling listLaunchPlans2.');
        }

        if (idName !== undefined) {
            localVarQueryParameters['id.name'] = ObjectSerializer.serialize(idName, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminLaunchPlanList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminLaunchPlanList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Lists custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a specific resource type.
     * @param resourceType +required.   - TASK_RESOURCE: Applies to customizable task resource requests and limits.  - CLUSTER_RESOURCE: Applies to configuring templated kubernetes cluster resources.  - EXECUTION_QUEUE: Configures task and dynamic task execution queue assignment.  - EXECUTION_CLUSTER_LABEL: Configures the K8s cluster label to be used for execution to be run  - QUALITY_OF_SERVICE_SPECIFICATION: Configures default quality of service when undefined in an execution spec.  - PLUGIN_OVERRIDE: Selects configurable plugin implementation behavior for a given task type.  - WORKFLOW_EXECUTION_CONFIG: Adds defaults for customizable workflow-execution specifications and overrides.  - CLUSTER_ASSIGNMENT: Controls how to select an available cluster on which this execution should run.
     * @param {*} [options] Override http request options.
     */
    public listMatchableAttributes (resourceType?: 'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminListMatchableAttributesResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/matchable_attributes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (resourceType !== undefined) {
            localVarQueryParameters['resource_type'] = ObjectSerializer.serialize(resourceType, "'TASK_RESOURCE' | 'CLUSTER_RESOURCE' | 'EXECUTION_QUEUE' | 'EXECUTION_CLUSTER_LABEL' | 'QUALITY_OF_SERVICE_SPECIFICATION' | 'PLUGIN_OVERRIDE' | 'WORKFLOW_EXECUTION_CONFIG' | 'CLUSTER_ASSIGNMENT'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminListMatchableAttributesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminListMatchableAttributesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a list of :ref:`ref_flyteidl.admin.NamedEntity` objects.
     * @param resourceType Resource type of the metadata to query. One of Task, Workflow or LaunchPlan. +required
     * @param project Name of the project that contains the identifiers. +required
     * @param domain Name of the domain the identifiers belongs to within the project.
     * @param limit Indicates the number of resources to be returned.
     * @param token In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param filters Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request options.
     */
    public listNamedEntities (resourceType: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', project: string, domain: string, limit?: number, token?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', filters?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminNamedEntityList;  }> {
        const localVarPath = this.basePath + '/api/v1/named_entities/{resource_type}/{project}/{domain}'
            .replace('{' + 'resource_type' + '}', encodeURIComponent(String(resourceType)))
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceType' is not null or undefined
        if (resourceType === null || resourceType === undefined) {
            throw new Error('Required parameter resourceType was null or undefined when calling listNamedEntities.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling listNamedEntities.');
        }

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling listNamedEntities.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminNamedEntityList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminNamedEntityList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution`.
     * @param workflowExecutionIdProject Name of the project the resource belongs to.
     * @param workflowExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param workflowExecutionIdName User or system provided value for the resource.
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token 
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param uniqueParentId Unique identifier of the parent node in the execution +optional.
     * @param {*} [options] Override http request options.
     */
    public listNodeExecutions (workflowExecutionIdProject: string, workflowExecutionIdDomain: string, workflowExecutionIdName: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', uniqueParentId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminNodeExecutionList;  }> {
        const localVarPath = this.basePath + '/api/v1/node_executions/{workflow_execution_id.project}/{workflow_execution_id.domain}/{workflow_execution_id.name}'
            .replace('{' + 'workflow_execution_id.project' + '}', encodeURIComponent(String(workflowExecutionIdProject)))
            .replace('{' + 'workflow_execution_id.domain' + '}', encodeURIComponent(String(workflowExecutionIdDomain)))
            .replace('{' + 'workflow_execution_id.name' + '}', encodeURIComponent(String(workflowExecutionIdName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'workflowExecutionIdProject' is not null or undefined
        if (workflowExecutionIdProject === null || workflowExecutionIdProject === undefined) {
            throw new Error('Required parameter workflowExecutionIdProject was null or undefined when calling listNodeExecutions.');
        }

        // verify required parameter 'workflowExecutionIdDomain' is not null or undefined
        if (workflowExecutionIdDomain === null || workflowExecutionIdDomain === undefined) {
            throw new Error('Required parameter workflowExecutionIdDomain was null or undefined when calling listNodeExecutions.');
        }

        // verify required parameter 'workflowExecutionIdName' is not null or undefined
        if (workflowExecutionIdName === null || workflowExecutionIdName === undefined) {
            throw new Error('Required parameter workflowExecutionIdName was null or undefined when calling listNodeExecutions.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        if (uniqueParentId !== undefined) {
            localVarQueryParameters['unique_parent_id'] = ObjectSerializer.serialize(uniqueParentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminNodeExecutionList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminNodeExecutionList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NodeExecution` launched by the reference :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param taskExecutionIdNodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param taskExecutionIdNodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param taskExecutionIdNodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param taskExecutionIdNodeExecutionIdNodeId 
     * @param taskExecutionIdTaskIdProject Name of the project the resource belongs to.
     * @param taskExecutionIdTaskIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param taskExecutionIdTaskIdName User provided value for the resource.
     * @param taskExecutionIdTaskIdVersion Specific version of the resource.
     * @param taskExecutionIdRetryAttempt 
     * @param taskExecutionIdTaskIdResourceType Identifies the specific type of resource that this identifier corresponds to.   - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects. Eventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects  in a similar manner to other Flyte objects
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, the, server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listNodeExecutionsForTask (taskExecutionIdNodeExecutionIdExecutionIdProject: string, taskExecutionIdNodeExecutionIdExecutionIdDomain: string, taskExecutionIdNodeExecutionIdExecutionIdName: string, taskExecutionIdNodeExecutionIdNodeId: string, taskExecutionIdTaskIdProject: string, taskExecutionIdTaskIdDomain: string, taskExecutionIdTaskIdName: string, taskExecutionIdTaskIdVersion: string, taskExecutionIdRetryAttempt: number, taskExecutionIdTaskIdResourceType?: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminNodeExecutionList;  }> {
        const localVarPath = this.basePath + '/api/v1/children/task_executions/{task_execution_id.node_execution_id.execution_id.project}/{task_execution_id.node_execution_id.execution_id.domain}/{task_execution_id.node_execution_id.execution_id.name}/{task_execution_id.node_execution_id.node_id}/{task_execution_id.task_id.project}/{task_execution_id.task_id.domain}/{task_execution_id.task_id.name}/{task_execution_id.task_id.version}/{task_execution_id.retry_attempt}'
            .replace('{' + 'task_execution_id.node_execution_id.execution_id.project' + '}', encodeURIComponent(String(taskExecutionIdNodeExecutionIdExecutionIdProject)))
            .replace('{' + 'task_execution_id.node_execution_id.execution_id.domain' + '}', encodeURIComponent(String(taskExecutionIdNodeExecutionIdExecutionIdDomain)))
            .replace('{' + 'task_execution_id.node_execution_id.execution_id.name' + '}', encodeURIComponent(String(taskExecutionIdNodeExecutionIdExecutionIdName)))
            .replace('{' + 'task_execution_id.node_execution_id.node_id' + '}', encodeURIComponent(String(taskExecutionIdNodeExecutionIdNodeId)))
            .replace('{' + 'task_execution_id.task_id.project' + '}', encodeURIComponent(String(taskExecutionIdTaskIdProject)))
            .replace('{' + 'task_execution_id.task_id.domain' + '}', encodeURIComponent(String(taskExecutionIdTaskIdDomain)))
            .replace('{' + 'task_execution_id.task_id.name' + '}', encodeURIComponent(String(taskExecutionIdTaskIdName)))
            .replace('{' + 'task_execution_id.task_id.version' + '}', encodeURIComponent(String(taskExecutionIdTaskIdVersion)))
            .replace('{' + 'task_execution_id.retry_attempt' + '}', encodeURIComponent(String(taskExecutionIdRetryAttempt)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taskExecutionIdNodeExecutionIdExecutionIdProject' is not null or undefined
        if (taskExecutionIdNodeExecutionIdExecutionIdProject === null || taskExecutionIdNodeExecutionIdExecutionIdProject === undefined) {
            throw new Error('Required parameter taskExecutionIdNodeExecutionIdExecutionIdProject was null or undefined when calling listNodeExecutionsForTask.');
        }

        // verify required parameter 'taskExecutionIdNodeExecutionIdExecutionIdDomain' is not null or undefined
        if (taskExecutionIdNodeExecutionIdExecutionIdDomain === null || taskExecutionIdNodeExecutionIdExecutionIdDomain === undefined) {
            throw new Error('Required parameter taskExecutionIdNodeExecutionIdExecutionIdDomain was null or undefined when calling listNodeExecutionsForTask.');
        }

        // verify required parameter 'taskExecutionIdNodeExecutionIdExecutionIdName' is not null or undefined
        if (taskExecutionIdNodeExecutionIdExecutionIdName === null || taskExecutionIdNodeExecutionIdExecutionIdName === undefined) {
            throw new Error('Required parameter taskExecutionIdNodeExecutionIdExecutionIdName was null or undefined when calling listNodeExecutionsForTask.');
        }

        // verify required parameter 'taskExecutionIdNodeExecutionIdNodeId' is not null or undefined
        if (taskExecutionIdNodeExecutionIdNodeId === null || taskExecutionIdNodeExecutionIdNodeId === undefined) {
            throw new Error('Required parameter taskExecutionIdNodeExecutionIdNodeId was null or undefined when calling listNodeExecutionsForTask.');
        }

        // verify required parameter 'taskExecutionIdTaskIdProject' is not null or undefined
        if (taskExecutionIdTaskIdProject === null || taskExecutionIdTaskIdProject === undefined) {
            throw new Error('Required parameter taskExecutionIdTaskIdProject was null or undefined when calling listNodeExecutionsForTask.');
        }

        // verify required parameter 'taskExecutionIdTaskIdDomain' is not null or undefined
        if (taskExecutionIdTaskIdDomain === null || taskExecutionIdTaskIdDomain === undefined) {
            throw new Error('Required parameter taskExecutionIdTaskIdDomain was null or undefined when calling listNodeExecutionsForTask.');
        }

        // verify required parameter 'taskExecutionIdTaskIdName' is not null or undefined
        if (taskExecutionIdTaskIdName === null || taskExecutionIdTaskIdName === undefined) {
            throw new Error('Required parameter taskExecutionIdTaskIdName was null or undefined when calling listNodeExecutionsForTask.');
        }

        // verify required parameter 'taskExecutionIdTaskIdVersion' is not null or undefined
        if (taskExecutionIdTaskIdVersion === null || taskExecutionIdTaskIdVersion === undefined) {
            throw new Error('Required parameter taskExecutionIdTaskIdVersion was null or undefined when calling listNodeExecutionsForTask.');
        }

        // verify required parameter 'taskExecutionIdRetryAttempt' is not null or undefined
        if (taskExecutionIdRetryAttempt === null || taskExecutionIdRetryAttempt === undefined) {
            throw new Error('Required parameter taskExecutionIdRetryAttempt was null or undefined when calling listNodeExecutionsForTask.');
        }

        if (taskExecutionIdTaskIdResourceType !== undefined) {
            localVarQueryParameters['task_execution_id.task_id.resource_type'] = ObjectSerializer.serialize(taskExecutionIdTaskIdResourceType, "'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminNodeExecutionList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminNodeExecutionList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches a list of :ref:`ref_flyteidl.admin.Project`
     * @param limit Indicates the number of projects to be returned. +required.
     * @param token In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listProjects (limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminProjects;  }> {
        const localVarPath = this.basePath + '/api/v1/projects';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminProjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminProjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetches a list of :ref:`ref_flyteidl.admin.TaskExecution`.
     * @param nodeExecutionIdExecutionIdProject Name of the project the resource belongs to.
     * @param nodeExecutionIdExecutionIdDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param nodeExecutionIdExecutionIdName User or system provided value for the resource.
     * @param nodeExecutionIdNodeId 
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listTaskExecutions (nodeExecutionIdExecutionIdProject: string, nodeExecutionIdExecutionIdDomain: string, nodeExecutionIdExecutionIdName: string, nodeExecutionIdNodeId: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminTaskExecutionList;  }> {
        const localVarPath = this.basePath + '/api/v1/task_executions/{node_execution_id.execution_id.project}/{node_execution_id.execution_id.domain}/{node_execution_id.execution_id.name}/{node_execution_id.node_id}'
            .replace('{' + 'node_execution_id.execution_id.project' + '}', encodeURIComponent(String(nodeExecutionIdExecutionIdProject)))
            .replace('{' + 'node_execution_id.execution_id.domain' + '}', encodeURIComponent(String(nodeExecutionIdExecutionIdDomain)))
            .replace('{' + 'node_execution_id.execution_id.name' + '}', encodeURIComponent(String(nodeExecutionIdExecutionIdName)))
            .replace('{' + 'node_execution_id.node_id' + '}', encodeURIComponent(String(nodeExecutionIdNodeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'nodeExecutionIdExecutionIdProject' is not null or undefined
        if (nodeExecutionIdExecutionIdProject === null || nodeExecutionIdExecutionIdProject === undefined) {
            throw new Error('Required parameter nodeExecutionIdExecutionIdProject was null or undefined when calling listTaskExecutions.');
        }

        // verify required parameter 'nodeExecutionIdExecutionIdDomain' is not null or undefined
        if (nodeExecutionIdExecutionIdDomain === null || nodeExecutionIdExecutionIdDomain === undefined) {
            throw new Error('Required parameter nodeExecutionIdExecutionIdDomain was null or undefined when calling listTaskExecutions.');
        }

        // verify required parameter 'nodeExecutionIdExecutionIdName' is not null or undefined
        if (nodeExecutionIdExecutionIdName === null || nodeExecutionIdExecutionIdName === undefined) {
            throw new Error('Required parameter nodeExecutionIdExecutionIdName was null or undefined when calling listTaskExecutions.');
        }

        // verify required parameter 'nodeExecutionIdNodeId' is not null or undefined
        if (nodeExecutionIdNodeId === null || nodeExecutionIdNodeId === undefined) {
            throw new Error('Required parameter nodeExecutionIdNodeId was null or undefined when calling listTaskExecutions.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminTaskExecutionList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminTaskExecutionList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of task objects.
     * @param project Name of the project that contains the identifiers. +required
     * @param domain Name of the domain the identifiers belongs to within the project. +required
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param filters Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request options.
     */
    public listTaskIds (project: string, domain: string, limit?: number, token?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', filters?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminNamedEntityIdentifierList;  }> {
        const localVarPath = this.basePath + '/api/v1/task_ids/{project}/{domain}'
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling listTaskIds.');
        }

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling listTaskIds.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminNamedEntityIdentifierList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminNamedEntityIdentifierList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listTasks (idProject: string, idDomain: string, idName: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminTaskList;  }> {
        const localVarPath = this.basePath + '/api/v1/tasks/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling listTasks.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling listTasks.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling listTasks.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminTaskList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminTaskList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Task` definitions.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listTasks2 (idProject: string, idDomain: string, idName?: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminTaskList;  }> {
        const localVarPath = this.basePath + '/api/v1/tasks/{id.project}/{id.domain}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling listTasks2.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling listTasks2.');
        }

        if (idName !== undefined) {
            localVarQueryParameters['id.name'] = ObjectSerializer.serialize(idName, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminTaskList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminTaskList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.NamedEntityIdentifier` of workflow objects.
     * @param project Name of the project that contains the identifiers. +required
     * @param domain Name of the domain the identifiers belongs to within the project. +required
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, the server-provided token can be used to fetch the next page in a query. +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param filters Indicates a list of filters passed as string. +optional.
     * @param {*} [options] Override http request options.
     */
    public listWorkflowIds (project: string, domain: string, limit?: number, token?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', filters?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminNamedEntityIdentifierList;  }> {
        const localVarPath = this.basePath + '/api/v1/workflow_ids/{project}/{domain}'
            .replace('{' + 'project' + '}', encodeURIComponent(String(project)))
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling listWorkflowIds.');
        }

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling listWorkflowIds.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminNamedEntityIdentifierList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminNamedEntityIdentifierList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listWorkflows (idProject: string, idDomain: string, idName: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminWorkflowList;  }> {
        const localVarPath = this.basePath + '/api/v1/workflows/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling listWorkflows.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling listWorkflows.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling listWorkflows.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminWorkflowList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminWorkflowList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch a list of :ref:`ref_flyteidl.admin.Workflow` definitions.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;.
     * @param limit Indicates the number of resources to be returned. +required.
     * @param token In the case of multiple pages of results, this server-provided token can be used to fetch the next page in a query. +optional.
     * @param filters Indicates a list of filters passed as string. More info on constructing filters : &lt;Link&gt; +optional.
     * @param sortByKey Indicates an attribute to sort the response values. +required.
     * @param sortByDirection Indicates the direction to apply sort key for response values. +optional.   - DESCENDING: By default, fields are sorted in descending order.
     * @param {*} [options] Override http request options.
     */
    public listWorkflows2 (idProject: string, idDomain: string, idName?: string, limit?: number, token?: string, filters?: string, sortByKey?: string, sortByDirection?: 'DESCENDING' | 'ASCENDING', options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminWorkflowList;  }> {
        const localVarPath = this.basePath + '/api/v1/workflows/{id.project}/{id.domain}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling listWorkflows2.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling listWorkflows2.');
        }

        if (idName !== undefined) {
            localVarQueryParameters['id.name'] = ObjectSerializer.serialize(idName, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        if (sortByKey !== undefined) {
            localVarQueryParameters['sort_by.key'] = ObjectSerializer.serialize(sortByKey, "string");
        }

        if (sortByDirection !== undefined) {
            localVarQueryParameters['sort_by.direction'] = ObjectSerializer.serialize(sortByDirection, "'DESCENDING' | 'ASCENDING'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminWorkflowList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminWorkflowList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Recreates a previously-run workflow execution that will only start executing from the last known failure point. In Recover mode, users cannot change any input parameters or update the version of the execution. This is extremely useful to recover from system errors and byzantine faults like - Loss of K8s cluster, bugs in platform or instability, machine failures, downstream system failures (downstream services), or simply to recover executions that failed because of retry exhaustion and should complete if tried again. See :ref:`ref_flyteidl.admin.ExecutionRecoverRequest` for more details.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public recoverExecution (body: AdminExecutionRecoverRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminExecutionCreateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/executions/recover';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling recoverExecution.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminExecutionRecoverRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminExecutionCreateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminExecutionCreateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Registers a :ref:`ref_flyteidl.admin.Project` with the Flyte deployment.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public registerProject (body: AdminProjectRegisterRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminProjectRegisterResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/projects';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling registerProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminProjectRegisterRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminProjectRegisterResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminProjectRegisterResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Triggers the creation of an identical :ref:`ref_flyteidl.admin.Execution`
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public relaunchExecution (body: AdminExecutionRelaunchRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminExecutionCreateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/executions/relaunch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling relaunchExecution.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminExecutionRelaunchRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminExecutionCreateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminExecutionCreateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Terminates an in-progress :ref:`ref_flyteidl.admin.Execution`.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User or system provided value for the resource.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public terminateExecution (idProject: string, idDomain: string, idName: string, body: AdminExecutionTerminateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminExecutionTerminateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/executions/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling terminateExecution.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling terminateExecution.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling terminateExecution.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling terminateExecution.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminExecutionTerminateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminExecutionTerminateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminExecutionTerminateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update execution belonging to project domain :ref:`ref_flyteidl.admin.Execution`.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User or system provided value for the resource.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public updateExecution (idProject: string, idDomain: string, idName: string, body: AdminExecutionUpdateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminExecutionUpdateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/executions/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling updateExecution.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling updateExecution.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling updateExecution.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateExecution.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminExecutionUpdateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminExecutionUpdateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminExecutionUpdateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the status of a registered :ref:`ref_flyteidl.admin.LaunchPlan`.
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource.
     * @param idVersion Specific version of the resource.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public updateLaunchPlan (idProject: string, idDomain: string, idName: string, idVersion: string, body: AdminLaunchPlanUpdateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminLaunchPlanUpdateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/launch_plans/{id.project}/{id.domain}/{id.name}/{id.version}'
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)))
            .replace('{' + 'id.version' + '}', encodeURIComponent(String(idVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling updateLaunchPlan.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling updateLaunchPlan.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling updateLaunchPlan.');
        }

        // verify required parameter 'idVersion' is not null or undefined
        if (idVersion === null || idVersion === undefined) {
            throw new Error('Required parameter idVersion was null or undefined when calling updateLaunchPlan.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateLaunchPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminLaunchPlanUpdateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminLaunchPlanUpdateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminLaunchPlanUpdateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a :ref:`ref_flyteidl.admin.NamedEntity` object.
     * @param resourceType Resource type of the metadata to update +required
     * @param idProject Name of the project the resource belongs to.
     * @param idDomain Name of the domain the resource belongs to. A domain can be considered as a subset within a specific project.
     * @param idName User provided value for the resource. The combination of project + domain + name uniquely identifies the resource. +optional - in certain contexts - like &#39;List API&#39;, &#39;Launch plans&#39;
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public updateNamedEntity (resourceType: 'UNSPECIFIED' | 'TASK' | 'WORKFLOW' | 'LAUNCH_PLAN' | 'DATASET', idProject: string, idDomain: string, idName: string, body: AdminNamedEntityUpdateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminNamedEntityUpdateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/named_entities/{resource_type}/{id.project}/{id.domain}/{id.name}'
            .replace('{' + 'resource_type' + '}', encodeURIComponent(String(resourceType)))
            .replace('{' + 'id.project' + '}', encodeURIComponent(String(idProject)))
            .replace('{' + 'id.domain' + '}', encodeURIComponent(String(idDomain)))
            .replace('{' + 'id.name' + '}', encodeURIComponent(String(idName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resourceType' is not null or undefined
        if (resourceType === null || resourceType === undefined) {
            throw new Error('Required parameter resourceType was null or undefined when calling updateNamedEntity.');
        }

        // verify required parameter 'idProject' is not null or undefined
        if (idProject === null || idProject === undefined) {
            throw new Error('Required parameter idProject was null or undefined when calling updateNamedEntity.');
        }

        // verify required parameter 'idDomain' is not null or undefined
        if (idDomain === null || idDomain === undefined) {
            throw new Error('Required parameter idDomain was null or undefined when calling updateNamedEntity.');
        }

        // verify required parameter 'idName' is not null or undefined
        if (idName === null || idName === undefined) {
            throw new Error('Required parameter idName was null or undefined when calling updateNamedEntity.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateNamedEntity.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminNamedEntityUpdateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminNamedEntityUpdateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminNamedEntityUpdateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates an existing :ref:`ref_flyteidl.admin.Project`  flyteidl.admin.Project should be passed but the domains property should be empty; it will be ignored in the handler as domains cannot be updated via this API.
     * @param id Globally unique project name.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public updateProject (id: string, body: AdminProject, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminProjectUpdateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/projects/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateProject.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminProject")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminProjectUpdateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminProjectUpdateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` at the project level
     * @param attributesProject Unique project id for which this set of attributes will be applied.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public updateProjectAttributes (attributesProject: string, body: AdminProjectAttributesUpdateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminProjectAttributesUpdateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/project_attributes/{attributes.project}'
            .replace('{' + 'attributes.project' + '}', encodeURIComponent(String(attributesProject)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attributesProject' is not null or undefined
        if (attributesProject === null || attributesProject === undefined) {
            throw new Error('Required parameter attributesProject was null or undefined when calling updateProjectAttributes.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateProjectAttributes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminProjectAttributesUpdateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminProjectAttributesUpdateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminProjectAttributesUpdateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project and domain.
     * @param attributesProject Unique project id for which this set of attributes will be applied.
     * @param attributesDomain Unique domain id for which this set of attributes will be applied.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public updateProjectDomainAttributes (attributesProject: string, attributesDomain: string, body: AdminProjectDomainAttributesUpdateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminProjectDomainAttributesUpdateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/project_domain_attributes/{attributes.project}/{attributes.domain}'
            .replace('{' + 'attributes.project' + '}', encodeURIComponent(String(attributesProject)))
            .replace('{' + 'attributes.domain' + '}', encodeURIComponent(String(attributesDomain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attributesProject' is not null or undefined
        if (attributesProject === null || attributesProject === undefined) {
            throw new Error('Required parameter attributesProject was null or undefined when calling updateProjectDomainAttributes.');
        }

        // verify required parameter 'attributesDomain' is not null or undefined
        if (attributesDomain === null || attributesDomain === undefined) {
            throw new Error('Required parameter attributesDomain was null or undefined when calling updateProjectDomainAttributes.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateProjectDomainAttributes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminProjectDomainAttributesUpdateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminProjectDomainAttributesUpdateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminProjectDomainAttributesUpdateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates or updates custom :ref:`ref_flyteidl.admin.MatchableAttributesConfiguration` for a project, domain and workflow.
     * @param attributesProject Unique project id for which this set of attributes will be applied.
     * @param attributesDomain Unique domain id for which this set of attributes will be applied.
     * @param attributesWorkflow Workflow name for which this set of attributes will be applied.
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public updateWorkflowAttributes (attributesProject: string, attributesDomain: string, attributesWorkflow: string, body: AdminWorkflowAttributesUpdateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: AdminWorkflowAttributesUpdateResponse;  }> {
        const localVarPath = this.basePath + '/api/v1/workflow_attributes/{attributes.project}/{attributes.domain}/{attributes.workflow}'
            .replace('{' + 'attributes.project' + '}', encodeURIComponent(String(attributesProject)))
            .replace('{' + 'attributes.domain' + '}', encodeURIComponent(String(attributesDomain)))
            .replace('{' + 'attributes.workflow' + '}', encodeURIComponent(String(attributesWorkflow)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attributesProject' is not null or undefined
        if (attributesProject === null || attributesProject === undefined) {
            throw new Error('Required parameter attributesProject was null or undefined when calling updateWorkflowAttributes.');
        }

        // verify required parameter 'attributesDomain' is not null or undefined
        if (attributesDomain === null || attributesDomain === undefined) {
            throw new Error('Required parameter attributesDomain was null or undefined when calling updateWorkflowAttributes.');
        }

        // verify required parameter 'attributesWorkflow' is not null or undefined
        if (attributesWorkflow === null || attributesWorkflow === undefined) {
            throw new Error('Required parameter attributesWorkflow was null or undefined when calling updateWorkflowAttributes.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateWorkflowAttributes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AdminWorkflowAttributesUpdateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdminWorkflowAttributesUpdateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AdminWorkflowAttributesUpdateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
